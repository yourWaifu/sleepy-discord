(window.webpackJsonp=window.webpackJsonp||[]).push([[232],{302:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return d}));var s=t(3),a=t(7),r=(t(0),t(323)),o={title:"include/sleepy_discord/client.h"},i={unversionedId:"reference/Files/client_8h",id:"reference/Files/client_8h",isDocsHomePage:!1,title:"include/sleepy_discord/client.h",description:"Namespaces",source:"@site/docs/reference/Files/client_8h.md",slug:"/reference/Files/client_8h",permalink:"/sleepy-discord/docs/reference/Files/client_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/client.cpp",permalink:"/sleepy-discord/docs/reference/Files/client_8cpp"},next:{title:"include/sleepy_discord/common_return_types.h",permalink:"/sleepy-discord/docs/reference/Files/common__return__types_8h"}},l=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Types",id:"types",children:[]},{value:"Defines",id:"defines",children:[]},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum Mode",id:"enum-mode",children:[]},{value:"enum TTS",id:"enum-tts",children:[]},{value:"enum RequestMode",id:"enum-requestmode",children:[]},{value:"enum Intent",id:"enum-intent",children:[]},{value:"using IntentsRaw",id:"using-intentsraw",children:[]}]},{value:"Macro Documentation",id:"macro-documentation",children:[{value:"define TOKEN_SIZE",id:"define-token_size",children:[]},{value:"define SLEEPY_DEFAULT_REQUEST_MODE",id:"define-sleepy_default_request_mode",children:[]},{value:"define RequestModeRequestDefine",id:"define-requestmoderequestdefine",children:[]},{value:"define SLEEPY_LOCK_CLIENT_FUNCTIONS",id:"define-sleepy_lock_client_functions",children:[]}]},{value:"Source code",id:"source-code",children:[]}],c={toc:l};function d(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(s.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"namespaces"},"Namespaces"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(r.b)("h2",{id:"classes"},"Classes"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"class"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/class_sleepy_discord_1_1_route"},"SleepyDiscord::Route")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_rate_limiter"},"SleepyDiscord::RateLimiter")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"class"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/class_sleepy_discord_1_1_base_discord_client"},"SleepyDiscord::BaseDiscordClient")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request"},"SleepyDiscord::BaseDiscordClient::Request")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_settings"},"SleepyDiscord::BaseDiscordClient::RequestSettings")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_raw_request_mode_type_helper"},"SleepyDiscord::BaseDiscordClient::RawRequestModeTypeHelper")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_mode_type"},"SleepyDiscord::BaseDiscordClient::RequestModeType")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_mode_type_3_01_async_01_4"},"SleepyDiscord::BaseDiscordClient::RequestModeType< Async >")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"struct"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_base_discord_client_1_1_request_mode_type_3_01_sync_01_4"},"SleepyDiscord::BaseDiscordClient::RequestModeType< Sync >")))))),Object(r.b)("h2",{id:"types"},"Types"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum char"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#enum-mode"},"Mode"))," { USER_CONTROLED_THREADS = 1, USE_RUN_THREAD = 3, DEFAULT_THREADS = USER_CONTROLED_THREADS}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum char"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#enum-tts"},"TTS"))," { DisableTTS, EnableTTS, Default = DisableTTS}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#enum-requestmode"},"RequestMode"))," { UseRequestAsync = 1 << 0, UseRequestSync = 0 << 0, ThrowError = 1 << 4, AsyncQueue = 1 << 5, Async = UseRequestAsync")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"enum IntentsRaw"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#enum-intent"},"Intent"))," { SERVERS = 1 << 0, SERVER_MEMBERS = 1 << 1, SERVER_BANS = 1 << 2, SERVER_EMOJIS = 1 << 3, SERVER_INTEGRATIONS = 1 << 4, SERVER_WEBHOOKS = 1 << 5, SERVER_INVITES = 1 << 6, SERVER_VOICE_STATES = 1 << 7, SERVER_PRESENCES = 1 << 8, SERVER_MESSAGES = 1 << 9, SERVER_MESSAGE_REACTIONS = 1 << 10, SERVER_MESSAGE_TYPING = 1 << 11, DIRECT_MESSAGES = 1 << 12, DIRECT_MESSAGE_REACTIONS = 1 << 13, DIRECT_MESSAGE_TYPING = 1 << 14}")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"using int32_t"),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#using-intentsraw"},"IntentsRaw")))))),Object(r.b)("h2",{id:"defines"},"Defines"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null}),Object(r.b)("th",{parentName:"tr",align:null},"Name"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#define-token_size"},"TOKEN_SIZE")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#define-sleepy_default_request_mode"},"SLEEPY_DEFAULT_REQUEST_MODE")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#define-requestmoderequestdefine"},"RequestModeRequestDefine")))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null},Object(r.b)("strong",{parentName:"td"},Object(r.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8h#define-sleepy_lock_client_functions"},"SLEEPY_LOCK_CLIENT_FUNCTIONS")))))),Object(r.b)("h2",{id:"types-documentation"},"Types Documentation"),Object(r.b)("h3",{id:"enum-mode"},"enum Mode"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"USER_CONTROLED_THREADS"),Object(r.b)("td",{parentName:"tr",align:null},"1"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"USE_RUN_THREAD"),Object(r.b)("td",{parentName:"tr",align:null},"3"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DEFAULT_THREADS"),Object(r.b)("td",{parentName:"tr",align:null},"USER_CONTROLED_THREADS"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"enum-tts"},"enum TTS"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DisableTTS"),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"EnableTTS"),Object(r.b)("td",{parentName:"tr",align:null}),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Default"),Object(r.b)("td",{parentName:"tr",align:null},"DisableTTS"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"enum-requestmode"},"enum RequestMode"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"UseRequestAsync"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"UseRequestSync"),Object(r.b)("td",{parentName:"tr",align:null},"0 << 0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"ThrowError"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 4"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"AsyncQueue"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 5"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Async"),Object(r.b)("td",{parentName:"tr",align:null},"UseRequestAsync"),Object(r.b)("td",{parentName:"tr",align:null},"AsyncQueue")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Sync"),Object(r.b)("td",{parentName:"tr",align:null},"UseRequestSync"),Object(r.b)("td",{parentName:"tr",align:null},"ThrowError")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Sync_AsyncQueue"),Object(r.b)("td",{parentName:"tr",align:null},"UseRequestSync"),Object(r.b)("td",{parentName:"tr",align:null},"ThrowError")))),Object(r.b)("h3",{id:"enum-intent"},"enum Intent"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(r.b)("th",{parentName:"tr",align:null},"Value"),Object(r.b)("th",{parentName:"tr",align:null},"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVERS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 0"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_MEMBERS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 1"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_BANS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 2"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_EMOJIS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 3"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_INTEGRATIONS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 4"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_WEBHOOKS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 5"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_INVITES"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 6"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_VOICE_STATES"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 7"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_PRESENCES"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 8"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_MESSAGES"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 9"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_MESSAGE_REACTIONS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 10"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"SERVER_MESSAGE_TYPING"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 11"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DIRECT_MESSAGES"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 12"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DIRECT_MESSAGE_REACTIONS"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 13"),Object(r.b)("td",{parentName:"tr",align:null})),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"DIRECT_MESSAGE_TYPING"),Object(r.b)("td",{parentName:"tr",align:null},"1 << 14"),Object(r.b)("td",{parentName:"tr",align:null})))),Object(r.b)("h3",{id:"using-intentsraw"},"using IntentsRaw"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::IntentsRaw = typedef int32_t;\n")),Object(r.b)("h2",{id:"macro-documentation"},"Macro Documentation"),Object(r.b)("h3",{id:"define-token_size"},"define TOKEN_SIZE"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"#define TOKEN_SIZE 64\n")),Object(r.b)("h3",{id:"define-sleepy_default_request_mode"},"define SLEEPY_DEFAULT_REQUEST_MODE"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"#define SLEEPY_DEFAULT_REQUEST_MODE Sync_AsyncQueue;\n")),Object(r.b)("h3",{id:"define-requestmoderequestdefine"},"define RequestModeRequestDefine"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"#define RequestModeRequestDefine        template<class ParmType, class Callback> \\\n        static ReturnType doRequest(BaseDiscordClient& client, const RequestMethod method, Route path, \\\n            const std::string jsonParameters, const std::initializer_list<Part>& multipartParameters, Callback callback)\n")),Object(r.b)("h3",{id:"define-sleepy_lock_client_functions"},"define SLEEPY_LOCK_CLIENT_FUNCTIONS"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"#define SLEEPY_LOCK_CLIENT_FUNCTIONS                                      private:                                  \\\n                                     using BaseDiscordClient::processMessage;  \\\n                                     using BaseDiscordClient::start;           \\\n                                     using BaseDiscordClient::sendHeartbeat;   \\\n                                     using BaseDiscordClient::initialize;      \\\n                                     using BaseDiscordClient::processCloseCode;\\\n                                     using BaseDiscordClient::reconnect;       \\\n                                     using BaseDiscordClient::stopClient;      \\\n")),Object(r.b)("h2",{id:"source-code"},"Source code"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <string>\n#ifndef SLEEPY_ONE_THREAD\n#include <thread>\n#endif\n#include <memory>\n#include <unordered_map>\n#include <functional>\n#include <forward_list>\n#include <atomic>\n#include <mutex>\n\n//objects\n#include "message.h"\n#include "channel.h"\n#include "server.h"\n#include "invite.h"\n#include "webhook.h"\n#include "permissions.h"\n#include "gateway.h"\n#include "voice.h"\n\n#include "error.h"\n#include "session.h"\n#include "common_return_types.h"\n#include "message_receiver.h"\n#include "timer.h"\n#include "voice_connection.h"\n#include "asio_schedule.h"\n#include "compression.h"\n\nnamespace SleepyDiscord {\n#define TOKEN_SIZE 64\n\n    struct Request;\n\n    //to dos\n    //intents\n    //custom rapid json error\n    //detect cloudflare error\n    //emojis rate limits\n    //async\n    //merge to master\n    //cache\n\n    //Modes\n    enum Mode : char {\n        USER_CONTROLED_THREADS = 1,\n        USE_RUN_THREAD = 3,\n        DEFAULT_THREADS = USER_CONTROLED_THREADS\n    };\n\n    class Route {\n    public:\n        using Bucket = std::string;\n        Route(const std::string route, const std::initializer_list<std::string>& _values = {});\n        Route(const char* route);\n        inline const std::string& url() {\n            return _url;\n        }\n        const Bucket bucket(RequestMethod method);\n        inline operator const std::string&() {\n            return url();\n        }\n\n    private:\n        const std::string path;\n        std::string _url;\n        const std::initializer_list<std::string>& values;\n\n        //for the snowflake part, discord class should do\n        std::unordered_map<std::string, Snowflake<User>::RawType>\n            majorParameters = {\n            { "channel.id", {} },\n            { "guild.id"  , {} },\n            { "webhook.id", {} }\n        };\n    };\n\n    struct RateLimiter {\n        std::atomic<bool> isGlobalRateLimited = { false };\n        std::atomic<time_t> nextRetry = { 0 };\n        void limitBucket(const Route::Bucket& bucket, const std::string& xBucket, time_t timestamp);\n        const time_t getLiftTime(Route::Bucket& bucket, const time_t& currentTime);\n        //isLimited also returns the next Retry timestamp\n    private:\n        std::unordered_map<Route::Bucket, std::string> buckets;\n        std::unordered_map<std::string, time_t> limits;\n        std::mutex mutex;\n    };\n\n    enum class TTS : char {\n        DisableTTS,\n        EnableTTS,\n        Default = DisableTTS,\n    };\n\n    enum RequestMode {\n        UseRequestAsync = 1 << 0,\n        UseRequestSync = 0 << 0,\n\n        ThrowError = 1 << 4,\n        AsyncQueue = 1 << 5,\n\n        Async           = UseRequestAsync | AsyncQueue,\n        Sync            = UseRequestSync | ThrowError,\n        Sync_AsyncQueue = UseRequestSync | ThrowError | AsyncQueue, //old behavior for backwards compat\n    };\n\n    using IntentsRaw = int32_t;\n\n    enum Intent : IntentsRaw {\n        SERVERS                  = 1 << 0,\n        SERVER_MEMBERS           = 1 << 1,\n        SERVER_BANS              = 1 << 2,\n        SERVER_EMOJIS            = 1 << 3,\n        SERVER_INTEGRATIONS      = 1 << 4,\n        SERVER_WEBHOOKS          = 1 << 5,\n        SERVER_INVITES           = 1 << 6,\n        SERVER_VOICE_STATES      = 1 << 7,\n        SERVER_PRESENCES         = 1 << 8,\n        SERVER_MESSAGES          = 1 << 9,\n        SERVER_MESSAGE_REACTIONS = 1 << 10,\n        SERVER_MESSAGE_TYPING    = 1 << 11,\n        DIRECT_MESSAGES          = 1 << 12,\n        DIRECT_MESSAGE_REACTIONS = 1 << 13,\n        DIRECT_MESSAGE_TYPING    = 1 << 14,\n    };\n\n    class BaseDiscordClient : public GenericMessageReceiver {\n    public:\n        BaseDiscordClient() = default;\n        BaseDiscordClient(const std::string _token) { start(_token); }\n        ~BaseDiscordClient();\n\n        //important note, all requests on sync mode throw on an http error\n\n        using RequestCallback = std::function<void(Response)>;\n        Response request(const RequestMethod method, Route path, const std::string jsonParameters = "",\n            const std::vector<Part>& multipartParameters = {},\n            RequestCallback callback = nullptr, const RequestMode mode = Sync_AsyncQueue);\n        struct Request {\n            BaseDiscordClient& client;\n            const RequestMethod method;\n            const Route url;\n            const std::string jsonParameters;\n            const std::vector<Part> multipartParameters;\n            const BaseDiscordClient::RequestCallback callback;\n            RequestMode mode;\n            inline void operator()() const {\n                client.request(method, url, jsonParameters, multipartParameters, callback, mode);\n            }\n        };\n\n        template<class ParmType>\n        void requestAsync(const RequestMethod method, Route path, std::function<void(ParmType)> callback, const std::string jsonParameters = "",\n            const std::vector<Part>& multipartParameters = {}, const RequestMode mode = Async) {\n            postTask(static_cast<PostableTask>(\n                Request{ *this, method, path, jsonParameters, multipartParameters, callback ? RequestCallback([callback](Response r) {\n                    callback(static_cast<ParmType>(r));\n                }) : RequestCallback(nullptr), mode }\n            ));\n        }\n\n        template<class ParmType>\n        Response requestSync(const RequestMethod method, Route path, std::function<void(ParmType)> callback, const std::string jsonParameters = "",\n            const std::vector<Part>& multipartParameters = {}, const RequestMode mode = Sync) {\n            return request(method, path, jsonParameters, multipartParameters, callback ? RequestCallback([callback](Response r) {\n                callback(static_cast<ParmType>(r));\n            }) : RequestCallback(nullptr), mode );\n        }\n\n        const Route path(const char* source, std::initializer_list<std::string> values = {});\n\n#ifndef SLEEPY_DEFAULT_REQUEST_MODE\n    #ifdef SLEEPY_DEFAULT_REQUEST_MODE_ASYNC\n        #define SLEEPY_DEFAULT_REQUEST_MODE Async;\n    #elif defined(SLEEPY_DEFAULT_REQUEST_MODE_SYNC)\n        #define SLEEPY_DEFAULT_REQUEST_MODE Sync;\n    #else\n        #define SLEEPY_DEFAULT_REQUEST_MODE Sync_AsyncQueue;\n    #endif\n#endif\n\n        template<class _ParmType>\n        struct RequestSettings {\n            RequestMode mode = SLEEPY_DEFAULT_REQUEST_MODE;\n            using ParmType = _ParmType;\n            using Callback = std::function<void(ParmType)>;\n            Callback callback = nullptr;\n\n            RequestSettings(RequestMode r) : mode(r) {}\n            RequestSettings(Callback c) : mode(Async), callback(c) {}\n            RequestSettings(RequestMode r, Callback c) : mode(r), callback(c) {}\n            RequestSettings() {}; //for some reason = default doesn\'t work\n        };\n\n        template<class RequestSettingsClass>\n        Response request(const RequestMethod method, Route path, RequestSettingsClass& settings,\n            const std::string jsonParameters = "", const std::initializer_list<Part>& multipartParameters = {}) {\n            if (settings.mode & UseRequestAsync) {\n                requestAsync<\n                    typename RequestSettingsClass::ParmType\n                >(method, path, settings.callback, jsonParameters, multipartParameters, settings.mode);\n            } else {\n                if (settings.callback)\n                    //having an invalid callback here would cause bugs\n                    return requestSync<\n                        typename RequestSettingsClass::ParmType\n                    >(method, path, settings.callback, jsonParameters, multipartParameters, settings.mode);\n                else\n                    return request(method, path, jsonParameters, multipartParameters, nullptr, settings.mode);\n            }\n            return Response();\n        }\n\n        template<RequestMode mode, class type>\n        struct RawRequestModeTypeHelper {\n            using ReturnType = type;\n            static type doRequest() {}\n        };\n\n        #define RequestModeRequestDefine template<class ParmType, class Callback> \\\n        static ReturnType doRequest(BaseDiscordClient& client, const RequestMethod method, Route path, \\\n            const std::string jsonParameters, const std::initializer_list<Part>& multipartParameters, Callback callback)\n\n        template<RequestMode mode> struct RequestModeType : RawRequestModeTypeHelper<Sync, void> {};\n\n        template<RequestMode mode, class ParmType = void, class Callback = RequestCallback>\n        typename RequestModeType<mode>::ReturnType request(const RequestMethod method, Route path, Callback callback,\n            const std::string jsonParameters = "", const std::initializer_list<Part>& multipartParameters = {}\n            ) {\n            return RequestModeType<mode>::template doRequest<ParmType, Callback>(*this, method, path, jsonParameters, multipartParameters, callback);\n        }\n\n        void testFunction(std::string teststring);\n\n        //channel functions\n        ObjectResponse<Channel     > getChannel              (Snowflake<Channel> channelID                                                                                 , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > editChannel             (Snowflake<Channel> channelID, std::string name = "", std::string topic = ""                                  , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > editChannelName         (Snowflake<Channel> channelID, std::string name                                                               , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > editChannelTopic        (Snowflake<Channel> channelID, std::string topic                                                              , RequestSettings<ObjectResponse<Channel>> settings = {});\n        ObjectResponse<Channel     > deleteChannel           (Snowflake<Channel> channelID                                                                                 , RequestSettings<ObjectResponse<Channel>> settings = {});\n        enum GetMessagesKey {na, around, before, after, limit};\n        ArrayResponse <Message     > getMessages             (Snowflake<Channel> channelID, GetMessagesKey when, Snowflake<Message> messageID, uint8_t limit = 0);\n        ObjectResponse<Message     > getMessage              (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<ObjectResponse<Message>> settings = {});  //to do add more then one message return\n        const Embed createInvalidEmbed() {\n            return Embed::Flag::INVALID_EMBED;\n        }\n        //maybe move this to message.h\n        ObjectResponse<Message     > sendMessage             (Snowflake<Channel> channelID, std::string message, Embed embed = Embed::Flag::INVALID_EMBED, TTS tts = TTS::Default, RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > sendMessage             (SendMessageParams params                                                                                     , RequestSettings<ObjectResponse<Message>> settings = {});\n        ObjectResponse<Message     > uploadFile              (Snowflake<Channel> channelID, std::string fileLocation, std::string message, Embed embed = Embed::Flag::INVALID_EMBED, RequestSettings<ObjectResponse<Message>> settings = {});\n        BoolResponse                 addReaction             (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji                                , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 removeReaction          (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, Snowflake<User> userID = "@me");\n        ArrayResponse <User        > getReactions            (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji                                , RequestSettings<ArrayResponse<Reaction>> settings = {});\n        StandardResponse             removeAllReactions      (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<StandardResponse       > settings = {});\n        ObjectResponse<Message     > editMessage             (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string newMessage, Embed embed = Embed::Flag::INVALID_EMBED, RequestSettings<ObjectResponse<Message>> settings = {});\n        BoolResponse                 deleteMessage           (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 bulkDeleteMessages      (Snowflake<Channel> channelID, std::vector<Snowflake<Message>> messageIDs                                     , RequestSettings<BoolResponse           > settings = {});\n        /*allow is a bitwise value of all allowed permissions\n        deny is a bitwise value of all deisallowed permissions\n        type is "member" for a user or "role" for a role*/\n        BoolResponse                 editChannelPermissions  (Snowflake<Channel> channelID, Snowflake<Overwrite> overwriteID, int allow, int deny, std::string type);           //to do test this\n        ArrayResponse <Invite      > getChannelInvites       (Snowflake<Channel> channelID                                                                                 , RequestSettings<ArrayResponse<Invite  >> settings = {});\n        ObjectResponse<Invite      > createChannelInvite     (Snowflake<Channel> channelID, const uint64_t maxAge = 0, const uint64_t maxUses = 0, const bool temporary = false, const bool unique = false);\n        BoolResponse                 removeChannelPermission (Snowflake<Channel> channelID, std::string ID                                                                 , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 sendTyping              (Snowflake<Channel> channelID                                                                                 , RequestSettings<BoolResponse           > settings = {});\n        ArrayResponse <Message     > getPinnedMessages       (Snowflake<Channel> channelID                                                                                 , RequestSettings<ArrayResponse<Message >> settings = {});\n        BoolResponse                 pinMessage              (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<BoolResponse           > settings = {});\n        BoolResponse                 unpinMessage            (Snowflake<Channel> channelID, Snowflake<Message> messageID                                                   , RequestSettings<BoolResponse           > settings = {});\n        StandardResponse             addRecipient            (Snowflake<Channel> channelID, Snowflake<User> userID                                                         , RequestSettings<StandardResponse       > settings = {});\n        StandardResponse             removeRecipient         (Snowflake<Channel> channelID, Snowflake<User> userID                                                         , RequestSettings<StandardResponse       > settings = {});\n        //IntelliSense Help\n        /*functions with more then one name to make life easy for users that use IntelliSense*/\n        inline BoolResponse          deleteReaction          (Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji) { return removeReaction         (channelID, messageID, emoji); }\n        inline StandardResponse      deleteAllReactions      (Snowflake<Channel> channelID, Snowflake<Message> messageID                   ) { return removeAllReactions     (channelID, messageID       ); }\n        inline BoolResponse          deleteChannelPermission (Snowflake<Channel> channelID, std::string               ID                   ) { return removeChannelPermission(channelID,        ID       ); }\n        inline StandardResponse      deleteRecipient         (Snowflake<Channel> channelID, Snowflake<User   >    _userID                  ) { return removeRecipient        (channelID,   _userID       ); }\n        //For Convenience\n        inline ObjectResponse<Message> editMessage(Message message, std::string newMessage, Embed embed = Embed::Flag::INVALID_EMBED) { return editMessage(message.channelID, message.ID, newMessage, embed); }\n        inline ObjectResponse<Message> sendMessage(Snowflake<Channel> channelID, std::string message, RequestSettings<ObjectResponse<Message>> settings) {\n            return sendMessage(channelID, message, Embed::Flag::INVALID_EMBED, TTS::Default, settings);\n        }\n\n        //server functions\n        //ObjectResponse<Server      > createServer to do add this\n        ObjectResponse<Server      > getServer               (Snowflake<Server> serverID                                                         , RequestSettings<ObjectResponse<Server      >> settings = {});\n        //edit Server       //to do add this\n        ObjectResponse<Server      > deleteServer            (Snowflake<Server> serverID                                                         , RequestSettings<ObjectResponse<Server      >> settings = {});\n        ArrayResponse <Channel     > getServerChannels       (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<Channel      >> settings = {});\n        ObjectResponse<Channel     > createTextChannel       (Snowflake<Server> serverID, std::string name                                       , RequestSettings<ObjectResponse<Channel     >> settings = {});\n        ArrayResponse <Channel     > editChannelPositions    (Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Channel      >> settings = {});\n        ObjectResponse<ServerMember> getMember               (Snowflake<Server> serverID, Snowflake<User> userID                                 , RequestSettings<ObjectResponse<ServerMember>> settings = {});\n        ArrayResponse <ServerMember> listMembers             (Snowflake<Server> serverID, uint16_t limit = 0, std::string after = ""             , RequestSettings<ArrayResponse<ServerMember >> settings = {});\n        ObjectResponse<ServerMember> addMember               (Snowflake<Server> serverID, Snowflake<User> userID, std::string accesToken, std::string nick = "", std::vector<Role> roles = {}, bool mute = false, bool deaf = false); //to do test this\n        BoolResponse                 editMember              (Snowflake<Server> serverID, Snowflake<User> userID, std::string nickname = "", std::vector<Snowflake<Role>> roles = {}, int8_t mute = -1, int8_t deaf = -1, Snowflake<Channel> channelID = {});\n        BoolResponse                 muteServerMember        (Snowflake<Server> serverID, Snowflake<User> userID, bool mute = true               , RequestSettings<BoolResponse                 > settings = {});  //to do test this\n        BoolResponse                 editNickname            (Snowflake<Server> serverID, std::string newNickname                                , RequestSettings<BoolResponse                 > settings = {});\n        BoolResponse                 addRole                 (Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID         , RequestSettings<BoolResponse                 > settings = {});\n        BoolResponse                 removeRole              (Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID         , RequestSettings<BoolResponse                 > settings = {});\n        BoolResponse                 kickMember              (Snowflake<Server> serverID, Snowflake<User> userID                                 , RequestSettings<BoolResponse                 > settings = {});\n        ArrayResponse <User        > getBans                 (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<User          >> settings = {});  //to do test this\n        BoolResponse                 banMember               (Snowflake<Server> serverID, Snowflake<User> userID, int deleteMessageDays = -1, std::string reason = "", RequestSettings<BoolResponse> settings = {});\n        BoolResponse                 unbanMember             (Snowflake<Server> serverID, Snowflake<User> userID                                 , RequestSettings<BoolResponse                 > settings = {});\n        ArrayResponse <Role        > getRoles                (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<Role          >> settings = {});\n        ObjectResponse<Role        > createRole              (Snowflake<Server> serverID, std::string name = "", Permission permissions = Permission::NONE, unsigned int color = 0, bool hoist = false, bool mentionable = false);\n        ArrayResponse <Role        > editRolePosition        (Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Role>> settings = {});  //to do test this\n        StringResponse               editRole                (Snowflake<Server> serverID, Snowflake<Role> roleID, std::string name = "", Permission permissions = Permission::NONE, uint32_t color = 1 << 24, int8_t hoist = -1, int8_t mentionable = -1);\n        BoolResponse                 deleteRole              (Snowflake<Server> serverID, Snowflake<Role> roleID                                 , RequestSettings<BoolResponse                 > settings = {});\n        //get prune count   needs testing to know what object they are talking about\n        StandardResponse             pruneMembers            (Snowflake<Server> serverID, const unsigned int numOfDays                           , RequestSettings<StandardResponse             > settings = {});  //to do test\n        ArrayResponse <VoiceRegion > getVoiceRegions         (                                                                                     RequestSettings<ArrayResponse<VoiceRegion   >> settings = {});\n        ArrayResponse <Invite      > getServerInvites        (Snowflake<Server> serverID                                                         , RequestSettings<ArrayResponse<Invite        >> settings = {});\n        StringResponse               getIntegrations         (Snowflake<Server> serverID                                                         , RequestSettings<StringResponse               > settings = {});  //needs whatever a integration class is  //to do test\n        BoolResponse                 createIntegration       (Snowflake<Server> serverID, std::string type, std::string integrationID            , RequestSettings<BoolResponse                 > settings = {});  //to do test\n        BoolResponse                 editIntergration        (Snowflake<Server> serverID, std::string integrationID, int expireBegavior, int expireGracePeriod, bool enbleEmoticons); //to do test\n        BoolResponse                 deleteIntegration       (Snowflake<Server> serverID, std::string integrationID                              , RequestSettings<BoolResponse                 > settings = {});  //to do test this\n        BoolResponse                 syncIntegration         (Snowflake<Server> serverID, std::string integrationID                              , RequestSettings<BoolResponse                 > settings = {});  //to do test this\n        ObjectResponse<ServerEmbed > getServerEmbed          (Snowflake<Server> serverID                                                         , RequestSettings<ObjectResponse<ServerEmbed  >> settings = {});\n        //edit server embed   I don\'t know what the perms are\n\n        //Invite functions\n        ObjectResponse<Invite      > inviteEndpoint          (RequestMethod method, std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings = {});\n        ObjectResponse<Invite      > getInvite               (std::string inviteCode                      , RequestSettings<ObjectResponse<Invite>> settings = {});  //to do test this\n        ObjectResponse<Invite      > deleteInvite            (std::string inviteCode                      , RequestSettings<ObjectResponse<Invite>> settings = {});  //to do test this\n        ObjectResponse<Invite      > acceptInvite            (std::string inviteCode                      , RequestSettings<ObjectResponse<Invite>> settings = {}); //not available to bot accounts  //to do test this\n\n        //User functions\n        ObjectResponse<User        > getCurrentUser          (                            RequestSettings<ObjectResponse<User     >> settings = {});\n        ObjectResponse<User        > getUser                 (Snowflake<User> userID    , RequestSettings<ObjectResponse<User     >> settings = {});\n        //User editCurrentUser();\n        ArrayResponse <Server>     getServers                (                            RequestSettings<ArrayResponse<Server    >> settings = {});\n        BoolResponse               leaveServer               (Snowflake<Server> serverID, RequestSettings<BoolResponse             > settings = {});\n        ArrayResponse <Channel   > getDirectMessageChannels  (                            RequestSettings<ArrayResponse<Channel   >> settings = {});\n        ObjectResponse<Channel   > createDirectMessageChannel(std::string recipientID   , RequestSettings<ObjectResponse<Channel  >> settings = {});\n        //ObjectResponse<DMChannel > createGroupDirectMessageChannel(std:vector<std::string> accessTokens, ) to do add this\n        ArrayResponse <Connection> getUserConnections        (                            RequestSettings<ArrayResponse<Connection>> settings = {});\n\n        //Voice Functions\n        //getVoiceRegions\n\n        //Webhook functions\n        ObjectResponse<Webhook> createWebhook                (Snowflake<Channel> channelID, std::string name, std::string avatar = "", RequestSettings<ObjectResponse<Webhook>> settings = {});  //to do test this\n        ArrayResponse <Webhook> getChannelWebhooks           (Snowflake<Channel> channelID                                           , RequestSettings<ArrayResponse <Webhook>> settings = {});\n        ArrayResponse <Webhook> getServerWebhooks            (Snowflake<Server> serverID                                             , RequestSettings<ArrayResponse <Webhook>> settings = {});\n        ObjectResponse<Webhook> getWebhook                   (Snowflake<Webhook> webhookID, std::string webhookToken = ""            , RequestSettings<ObjectResponse<Webhook>> settings = {});  //to do test this\n        ObjectResponse<Webhook> editWebhook                  (Snowflake<Webhook> webhookID, std::string webhookToken = "", std::string name = "", std::string avatar = "");    //you can leave token or name as null //to do test this\n        BoolResponse            deleteWebhook                (Snowflake<Webhook> webhookID, std::string webhookToken = ""            , RequestSettings<BoolResponse           > settings = {});\n        ObjectResponse<Webhook> requestExecuteWebhook        (Snowflake<Webhook> webhookID, std::string webhookToken, std::pair<std::string, std::string> pair, bool wait, std::string username, std::string avatar_url, bool tts);     //note: it\'s possiable to have both a file and embeds\n        ObjectResponse<Webhook> executeWebhook               (Snowflake<Webhook> webhookID, std::string webhookToken, std::string content, bool wait = false, std::string username = "", std::string avatar_url = "", bool tts = false);       //to do test this\n        ObjectResponse<Webhook> executeWebhook               (Snowflake<Webhook> webhookID, std::string webhookToken, std::vector<Embed> embeds, bool wait = false, std::string username = "", std::string avatar_url = "", bool tts = false); //to do test this\n        ObjectResponse<Webhook> executeWebhook               (Snowflake<Webhook> webhookID, std::string webhookToken, filePathPart file, bool wait = false, std::string username = "", std::string avatar_url = "", bool tts = false);         //to do test this\n\n        //websocket functions\n        void updateStatus(std::string gameName = "", uint64_t idleSince = 0, Status status = online, bool afk = false);\n        void requestServerMembers(ServerMembersRequest request);\n\n        void waitTilReady();  \n        const bool isReady() { return ready; }\n        const bool isQuiting() { return quiting; }\n        const bool isBot() { return bot; }\n        const Snowflake<User> getID() { return userID; }\n        void setShardID(int _shardID, int _shardCount); //Note: must be called before run or reconnect\n        const int getShardID() { return shardID; }\n        const int getShardCount() { return shardCount; }\n        const bool hasIntents() { return intentsIsSet; }\n        const IntentsRaw getIntents() { return intents; }\n        void setIntents(IntentsRaw newIntents) { intentsIsSet = true; intents = static_cast<Intent>(newIntents); }\n        void quit() { quit(false); }    //public function for diconnecting\n        virtual void run();\n\n        //array of intents\n        template<class Container, typename T = typename Container::value_type>\n        void setIntents(const Container& listOfIntents) {\n            IntentsRaw target = 0;\n            for (Intent intent : listOfIntents)\n                target = target | static_cast<IntentsRaw>(intent);\n            setIntents(target);\n        }\n\n        //parameter pack of intents\n        template<typename... Types>\n        void setIntents(Intent first, Intent second, Types... others) {\n            std::initializer_list<Intent> intents = { first, second, others... };\n            setIntents(intents);\n        }\n\n        template <class Handler, class... Types>\n        void useCompression(Types&&... arguments) {\n            compressionHandler = std::unique_ptr<GenericCompression>(\n                new Handler(std::forward<Types>(arguments)...));\n            if (useTrasportConnection == static_cast<int8_t>(-1)) //if not set yet\n                useTrasportConnection = true;\n        }\n\n        void useCompression(bool value = true) {\n#ifdef SLEEPY_DEFAULT_COMPRESSION\n            if (value) useCompression<DefaultCompression>();\n            else scheduleHandler = nullptr;\n#else\n            assert(((void)"No default compress handler, use zlib-ng or use template function instead", value == false));\n#endif\n        }\n\n        //time\n        template <class Handler, class... Types>\n        inline void setScheduleHandler(Types&&... arguments) {\n            scheduleHandler = std::unique_ptr<GenericScheduleHandler>(\n                new Handler(std::forward<Types>(arguments)...)\n            );\n        }\n        inline GenericScheduleHandler& getScheduleHandler() { return *scheduleHandler; }\n\n        enum AssignmentType : bool {\n            TilDueTime = 0,\n            EpochTime  = 1,\n        };\n        virtual Timer  schedule(TimedTask                 code   , const time_t millisecondsTilDueTime);\n        inline  Timer  schedule(TimedTask                 code   , const time_t milliseconds, AssignmentType mode) {\n            return     schedule(code, mode == TilDueTime ? milliseconds : milliseconds - getEpochTimeMillisecond());\n        }\n        inline  Timer  schedule(void (BaseDiscordClient::*code)(), const time_t milliseconds, AssignmentType mode = TilDueTime) {\n            return     schedule(std::bind(code, this), milliseconds, mode);\n        }\n        inline  void  unschedule(Timer& timer) { timer.stop(); }\n\n        typedef TimedTask PostableTask;\n        virtual void postTask(PostableTask code) {\n            schedule(code, 0);\n        }\n\n#ifdef SLEEPY_VOICE_ENABLED\n        //\n        //voice\n        //\n\n        friend VoiceConnection;\n\n        enum VoiceMode {\n            normal = 0,\n            mute = 1 << 0,\n            deafen = 1 << 1\n        };\n\n        VoiceContext& createVoiceContext(Snowflake<Server> server, Snowflake<Channel> channel, BaseVoiceEventHandler* eventHandler = nullptr);\n        inline VoiceContext& createVoiceContext(Snowflake<Channel> channel, BaseVoiceEventHandler* eventHandler = nullptr) {\n            return createVoiceContext("", channel, eventHandler);\n        }\n        void connectToVoiceChannel(VoiceContext& voiceContext, VoiceMode settings = normal);\n        VoiceContext& connectToVoiceChannel(Snowflake<Server> server, Snowflake<Channel> channel, VoiceMode settings = normal);\n        VoiceContext& connectToVoiceChannel(Snowflake<Channel> channel, VoiceMode settings = normal) {\n            return connectToVoiceChannel("", channel, settings);\n        }\n        inline void disconnectVoiceConnection(VoiceConnection & connection) {\n            connection.disconnect();\n        }\n\n        template<class Function>\n        void disconnectVoiceConnection_if(Function function) {\n            auto i = std::find_if(voiceConnections.begin(), voiceConnections.end(), function);\n            if (i != voiceConnections.end())\n                disconnectVoiceConnection(*i);\n        }\n\n        inline void disconnectVoiceContext(VoiceContext & context) {\n            disconnectVoiceConnection_if([&context](VoiceConnection& connection) {\n                return connection.getContext() == context;\n            });\n        }\n\n        inline void disconnectFromVoiceChannel(Snowflake<Channel>& channelID) {\n            disconnectVoiceConnection_if([&channelID](VoiceConnection& connection) {\n                return connection.getContext().getChannelID() == channelID;\n            });\n        }\n\n        inline void disconnectServerVoiceConnections(Snowflake<Server>& serverID) {\n            disconnectVoiceConnection_if([&serverID](VoiceConnection& connection) {\n                return connection.getContext().getServerID() == serverID;\n            });\n        }\n#endif\n\n        //Caching\n        std::shared_ptr<ServerCache> createServerCache();\n        void setServerCache(std::shared_ptr<ServerCache> cache);\n        inline std::shared_ptr<ServerCache>& getServerCache() {\n            return serverCache;\n        }\n\n    protected:\n        //Rest events\n        virtual void onDepletedRequestSupply(const Route::Bucket& bucket, time_t timeTilReset);\n        virtual void onExceededRateLimit(bool global, std::time_t timeTilRetry, Request request, bool& continueRequest);\n\n        /* list of events\n        READY\n        RESUMED\n        GUILD_CREATE\n        GUILD_DELETE\n        GUILD_UPDATE\n        GUILD_BAN_ADD\n        GUILD_BAN_REMOVE\n        GUILD_EMOJIS_UPDATE\n        *GUILD_INTEGRATIONS_UPDATE\n        GUILD_MEMBER_ADD\n        GUILD_MEMBER_REMOVE\n        GUILD_MEMBER_UPDATE\n        GUILD_MEMBERS_CHUNK\n        GUILD_ROLE_CREATE\n        GUILD_ROLE_UPDATE\n        GUILD_ROLE_DELETE\n        CHANNEL_CREATE\n        CHANNEL_DELETE\n        CHANNEL_UPDATE\n        CHANNEL_PINS_UPDATE\n        PRESENCE_UPDATE\n        *PRESENCES_REPLACE\n        USER_UPDATE\n        USER_NOTE_UPDATE\n        USER_SETTINGS_UPDATE\n        VOICE_STATE_UPDATE\n        TYPING_START\n        MESSAGE_CREATE\n        MESSAGE_UPDATE\n        MESSAGE_DELETE\n        MESSAGE_DELETE_BULK\n        MESSAGE_REACTION_ADD\n        MESSAGE_REACTION_REMOVE\n        MESSAGE_REACTION_REMOVE_ALL\n        VOICE_SERVER_UPDATE\n        GUILD_SYNC\n        RELATIONSHIP_ADD\n        RELATIONSHIP_REMOVE\n        * event that hasn\'t been added\n        */\n        //TODO: use references, using them now will break other\'s code\n        virtual void onReady             (Ready              readyData  );\n        virtual void onResumed           (                              );\n        virtual void onDeleteServer      (UnavailableServer server      );\n        virtual void onEditServer        (Server            server      );\n        virtual void onBan               (Snowflake<Server> serverID, User user);\n        virtual void onUnban             (Snowflake<Server> serverID, User user);\n        virtual void onMember            (Snowflake<Server> serverID, ServerMember member);\n        virtual void onRemoveMember      (Snowflake<Server> serverID, User user);\n        virtual void onEditMember        (Snowflake<Server> serverID, User user, std::vector<Snowflake<Role>> roles, std::string nick);\n        virtual void onRole              (Snowflake<Server> serverID, Role role);\n        virtual void onDeleteRole        (Snowflake<Server> serverID, Snowflake<Role> roleID);\n        virtual void onEditRole          (Snowflake<Server> serverID, Role role);\n        virtual void onEditEmojis        (Snowflake<Server> serverID, std::vector<Emoji> emojis);\n        virtual void onMemberChunk       (ServerMembersChunk memberChunk);\n        virtual void onDeleteChannel     (Channel            channel    );\n        virtual void onEditChannel       (Channel            channel    );\n        virtual void onPinMessage        (Snowflake<Channel> channelID, std::string lastPinTimestamp);\n        virtual void onPresenceUpdate    (PresenceUpdate     presenseUpdate);\n        virtual void onEditUser          (User               user       );\n        virtual void onEditUserSettings  (const json::Value& jsonMessage);\n        virtual void onEditVoiceState    (VoiceState&        state      );\n        virtual void onTyping            (Snowflake<Channel> channelID, Snowflake<User> userID, time_t timestamp);\n        virtual void onDeleteMessages    (Snowflake<Channel> channelID, std::vector<Snowflake<Message>> messages);\n        virtual void onEditMessage       (MessageRevisions   revisioins );\n        virtual void onEditVoiceServer   (VoiceServerUpdate& update     );\n        virtual void onReaction          (Snowflake<User> userID, Snowflake<Channel> channelID, Snowflake<Message> messageID, Emoji emoji);\n        virtual void onDeleteReaction    (Snowflake<User> userID, Snowflake<Channel> channelID, Snowflake<Message> messageID, Emoji emoji);\n        virtual void onDeleteAllReaction (Snowflake<Server> serverID, Snowflake<Channel> channelID, Snowflake<Message> messageID);\n        virtual void onMessage           (Message            message    );\n        virtual void onServer            (Server             server     );\n        virtual void onChannel           (Channel            channel    );\n        virtual void onDispatch          (const json::Value& jsonMessage);\n        virtual void onUnknownEvent      (std::string name, const json::Value& data); //for extending old library versions\n\n        //websocket stuff\n        virtual void onHeartbeat();\n        virtual void onHeartbeatAck();\n        virtual void onInvaldSession();\n        virtual void onDisconnect();\n        virtual void onResume();\n\n        virtual void onQuit();\n        virtual void onRestart() {}\n        virtual void onResponse(Response response);\n        virtual void sleep(const unsigned int milliseconds);  //Deprecated, use schedule instead\n        virtual void fileRead(const char* path, std::string*const file);\n        virtual void tick(float deltaTime);\n        virtual void onError(ErrorCode errorCode, const std::string errorMessage);\n\n        /*do not use or overwrite the protected values below,\n        unless you know what you are doing*/\n        void processMessage(const std::string &message) override;\n        void processMessage(const WebSocketMessage message) override;\n        void processCloseCode(const int16_t code) override;\n        void heartbeat();\n        void sendHeartbeat();\n        void resetHeartbeatValues();\n        inline std::string getToken() { return *token.get(); }\n        inline void setToken(const std::string& value) { token = std::unique_ptr<std::string>(new std::string(value)); }\n        void start(const std::string _token, const char maxNumOfThreads = DEFAULT_THREADS, int _shardID = 0, int _shardCount = 0);\n        inline void connect() {\n            postTask([this]() {\n                getTheGateway();\n                connect(theGateway, this, connection);\n            });\n        }\n        virtual bool connect(\n            const std::string & /*uri*/,                    //IN\n            GenericMessageReceiver* /*messageProcessor*/,   //IN  When a message is receved, this will process it\n            WebsocketConnection& /*connection*/             //OUT data needed in order to send a message. nullptr by default\n        ) { return false; }\n        void handleFailToConnect() override { reconnect(); }\n        virtual void send(std::string /*message*/, WebsocketConnection& /*connection*/) {}\n        virtual void disconnect(unsigned int /*code*/, const std::string /*reason*/, WebsocketConnection& /*connection*/) {}\n        void reconnect(const unsigned int status = 4900);\n        virtual void stopClient() {}\n        //the next 3 functions are part of BaseDiscordClient because VoiceConnection is a private nested class\n        inline void initialize(GenericMessageReceiver*& messageProcessor) const {\n            messageProcessor->initialize();\n        }\n        inline void processMessage(GenericMessageReceiver*& messageProcessor, const std::string& message) const {\n            messageProcessor->processMessage(message);\n        }\n        inline void processCloseCode(GenericMessageReceiver*& messageProcessor, const int16_t& code) const {\n            messageProcessor->processCloseCode(code);\n        }\n        virtual void runAsync();\n        virtual const time_t getEpochTimeMillisecond();\n\n    private:\n        using GenericMessageReceiver::initialize;\n\n        int heartbeatInterval = 0;\n        int64_t lastHeartbeat = 0;\n        int lastSReceived = 0;\n        bool wasHeartbeatAcked = true;\n        std::unique_ptr<GenericScheduleHandler> scheduleHandler = nullptr;\n        Timer heart;\n\n        enum OPCode {\n            DISPATCH              = 0,  //dispatches an event\n            HEARTHBEAT            = 1,  //used for ping checking\n            IDENTIFY              = 2,  //used for client handshake\n            STATUS_UPDATE         = 3,  //used to update the client status\n            VOICE_STATE_UPDATE    = 4,  //used to join / move / leave voice channels\n            VOICE_SERVER_PING     = 5,  //used for voice ping checking\n            RESUME                = 6,  //used to resume a closed connection\n            RECONNECT             = 7,  //used to tell clients to reconnect to the gateway\n            REQUEST_GUILD_MEMBERS = 8,  //used to request guild members\n            INVALID_SESSION       = 9,  //used to notify client they have an invalid session id\n            HELLO                 = 10, //sent immediately after connecting, contains heartbeat and server debug information\n            HEARTBEAT_ACK         = 11, //sent immediately following a client heartbeat that was received\n        };\n\n        std::unique_ptr<std::string> token;     //stored in a unique_ptr so that you can\'t see it in the debugger\n        std::string sessionID;  //TODO: replace this with a Ready object\n        int shardID = 0;\n        int shardCount = 0;\n        Intent intents;\n        bool intentsIsSet = false;\n        Snowflake<User> userID;\n        void getTheGateway();\n        std::string theGateway;\n        bool ready = false;\n        bool quiting = false;\n        bool bot = true;\n        void sendIdentity();\n        void sendResume();\n        void quit(bool isRestarting, bool isDisconnected = false);\n        void restart();\n        void disconnectWebsocket(unsigned int code, const std::string reason = "");\n        bool sendL(std::string message);    //the L stands for Limited\n        int64_t nextHalfMin = 0;\n\n        //Cache\n        std::shared_ptr<ServerCache> serverCache;\n\n        //rate limiting\n        int8_t messagesRemaining = 0;\n        RateLimiter rateLimiter;\n\n        //error handling\n        void setError(int errorCode);\n\n        //for endpoint functions\n        const std::string getEditPositionString(const std::vector<std::pair<std::string, uint64_t>>& positions);\n\n        //\n        //voice\n        //\n        std::forward_list<VoiceConnection> voiceConnections;\n        std::forward_list<VoiceContext> voiceContexts;\n        std::forward_list<VoiceContext*> waitingVoiceContexts;\n#ifdef SLEEPY_VOICE_ENABLED\n        void connectToVoiceIfReady(VoiceContext& context);\n        void removeVoiceConnectionAndContext(VoiceConnection& connection);\n#endif\n\n        //compression\n        std::unique_ptr<GenericCompression> compressionHandler;\n        int8_t useTrasportConnection = static_cast<int8_t>(-1); //-1 for not set\n\n        template<class Callback>\n        void findServerInCache(Snowflake<Server>& serverID, Callback onSuccessCallback) {\n            if (serverCache) {\n                ServerCache::iterator server = serverCache->findServer(serverID);\n                if (server != serverCache->end()) {\n                    onSuccessCallback(server);\n                }\n            }\n        }\n\n        template<class Callback>\n        void accessServerFromCache(Snowflake<Server>& serverID, Callback callback) {\n            findServerInCache(serverID, [callback](ServerCache::iterator& found) {\n                callback(*found);\n            });\n        }\n\n        template<class Container, class Callback>\n        void accessContainerFromCache(\n            Snowflake<Server>& serverID, Container Server::* container, Callback callback\n        ) {\n            accessServerFromCache(serverID, [callback, container](Server& server) {\n                callback(server, server.*(container));\n            });\n        }\n\n        template<class Container>\n        void appendObjectToCache(\n            Snowflake<Server>& serverID, Container Server::* container, typename Container::value_type& object\n        ) {\n            accessContainerFromCache(serverID, container,\n                [object](Server&, Container& found) {\n                    found.push_front(object);\n                }\n            );\n        }\n\n        template<class Type, class Container, class Callback>\n        void accessIteratorFromCache (\n            Snowflake<Server>& serverID, Container Server::* container, Type ID, Callback callback\n        ) {\n            accessContainerFromCache(serverID, container,\n                [callback, ID](Server& server, Container& foundContainter) {\n                    auto found = ID.findObject(foundContainter);\n                    if (found != foundContainter.end()) {\n                        callback(server, found);\n                    }\n                }\n            );\n        }\n\n        template<class Type, class Container, class Callback>\n        void accessObjectFromCache(\n            Snowflake<Server> serverID, Container Server::* container, Type ID, Callback callback\n        ) {\n            accessIteratorFromCache(serverID, container, ID,\n                [callback] (Server& server, typename Container::iterator& iterator) {\n                    callback(server, *iterator);\n                }\n            );\n        }\n\n        template<class Type, class Container>\n        void eraseObjectFromCache(\n            Snowflake<Server> serverID, Container Server::* container, Type ID\n        ) {\n            accessIteratorFromCache(serverID, container, ID,\n                [container](Server& server, typename Container::iterator& found) {\n                    (server.*(container)).erase(found);\n                }\n            );\n        }\n    };\n\n    template<> struct BaseDiscordClient::RequestModeType<Async> : BaseDiscordClient::RawRequestModeTypeHelper<Async, void> {\n        RequestModeRequestDefine {\n            client.requestAsync<ParmType, Callback>(method, path, callback, jsonParameters, multipartParameters);\n        }\n    };\n    template<> struct BaseDiscordClient::RequestModeType<Sync>  : BaseDiscordClient::RawRequestModeTypeHelper<Sync , Request> {\n        RequestModeRequestDefine {\n            return client.requestSync(method, path, callback, jsonParameters, multipartParameters);\n        }\n    };\n\n}\n\n//locks away functions that users shouldn\'t be using\n#define SLEEPY_LOCK_CLIENT_FUNCTIONS private:                                  \\\n                                     using BaseDiscordClient::processMessage;  \\\n                                     using BaseDiscordClient::start;           \\\n                                     using BaseDiscordClient::sendHeartbeat;   \\\n                                     using BaseDiscordClient::initialize;      \\\n                                     using BaseDiscordClient::processCloseCode;\\\n                                     using BaseDiscordClient::reconnect;       \\\n                                     using BaseDiscordClient::stopClient;      \\\n\n//This comment stops a warning\n')),Object(r.b)("hr",null),Object(r.b)("p",null,"Updated on 26 March 2021 at 18:19:45 UTC"))}d.isMDXComponent=!0},323:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return m}));var s=t(0),a=t.n(s);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,s,a=function(e,n){if(null==e)return{};var t,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=a.a.createContext({}),d=function(e){var n=a.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=d(e.components);return a.a.createElement(c.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},p=a.a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(t),p=s,m=u["".concat(o,".").concat(p)]||u[p]||b[p]||r;return t?a.a.createElement(m,i(i({ref:n},c),{},{components:t})):a.a.createElement(m,i({ref:n},c))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=p;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<r;c++)o[c]=t[c];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);