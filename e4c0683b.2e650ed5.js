(window.webpackJsonp=window.webpackJsonp||[]).push([[215],{288:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return c})),t.d(n,"toc",(function(){return i})),t.d(n,"default",(function(){return d}));var s=t(3),r=t(7),a=(t(0),t(321)),o={title:"include/sleepy_discord/message.h"},c={unversionedId:"reference/Files/message_8h",id:"reference/Files/message_8h",isDocsHomePage:!1,title:"include/sleepy_discord/message.h",description:"Namespaces",source:"@site/docs\\reference\\Files\\message_8h.md",slug:"/reference/Files/message_8h",permalink:"/sleepy-discord/docs/reference/Files/message_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/message.cpp",permalink:"/sleepy-discord/docs/reference/Files/message_8cpp"},next:{title:"include/sleepy_discord/message_receiver.h",permalink:"/sleepy-discord/docs/reference/Files/message__receiver_8h"}},i=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Source code",id:"source-code",children:[]}],l={toc:i};function d(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(s.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"namespaces"},"Namespaces"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",{parentName:"tr",align:null},"Name"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(a.b)("h2",{id:"classes"},"Classes"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",{parentName:"tr",align:null}),Object(a.b)("th",{parentName:"tr",align:null},"Name"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},"struct"),Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_emoji"},"SleepyDiscord::Emoji")))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},"struct"),Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_reaction"},"SleepyDiscord::Reaction")))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},"struct"),Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message"},"SleepyDiscord::Message")))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},"struct"),Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_message_revisions"},"SleepyDiscord::MessageRevisions")))),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},"struct"),Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_send_message_params"},"SleepyDiscord::SendMessageParams")))))),Object(a.b)("h2",{id:"source-code"},"Source code"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <tuple>\n#include "user.h"\n#include "attachment.h"\n#include "embed.h"\n#include "permissions.h"\n#include "webhook.h"\n#include "discord_object_interface.h"\n#include "snowflake.h"\n#include "channel.h"\n\n// <--- means to add later\n\nnamespace SleepyDiscord {\n    struct Emoji : public IdentifiableDiscordObject<Emoji> {\n    public:\n        ~Emoji();\n        Emoji() = default;\n        //Emoji(const std::string* rawJson);\n        Emoji(const json::Value & rawJSON);\n        Emoji(const nonstd::string_view& json);\n        //Emoji(const json::Values values);\n        std::string name;\n        std::vector<Snowflake<Role>> roles;\n        User user;  //optional\n        bool requireColons = false;\n        bool managed = false;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Emoji::ID           , "id"            , json::NULLABLE_FIELD),\n                json::pair                           (&Emoji::name         , "name"          , json::NULLABLE_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Emoji::roles        , "roles"         , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::user         , "user"          , json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::requireColons, "require_colons", json::OPTIONAL_FIELD),\n                json::pair                           (&Emoji::managed      , "managed"       , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n    \n    struct Reaction : public DiscordObject {\n    public:\n        Reaction() = default;\n        ~Reaction();\n        //Reaction(const std::string * rawJson);\n        Reaction(const json::Value & rawJSON);\n        Reaction(const nonstd::string_view & json);\n        //Reaction(const json::Values values);\n        int count = 0;\n        bool me = false;\n        Emoji emoji;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&Reaction::count, "count", json::REQUIRIED_FIELD),\n                json::pair(&Reaction::me   , "me"   , json::REQUIRIED_FIELD),\n                json::pair(&Reaction::emoji, "emoji", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    //forward declearion\n    class BaseDiscordClient;\n    struct Server;\n\n    struct Message : public IdentifiableDiscordObject<Message> {\n    public:\n        Message() = default;\n        ~Message() = default;\n        //Message(const json::Values values);\n        //Message(const std::string * rawJson);\n        Message(const json::Value& json);\n        Message(const nonstd::string_view& json);\n        //using DiscordObject::DiscordObject;\n        bool startsWith(const std::string& test);\n        std::size_t length();\n        bool isMentioned(Snowflake<User> ID);\n        bool isMentioned(User& _user);\n        Message send(BaseDiscordClient * client);\n        Message reply(BaseDiscordClient * client, std::string message,\n            Embed embed = Embed()\n        );\n\n        Snowflake<Channel> channelID;\n        Snowflake<Server> serverID;\n        User author;\n        ServerMember member;\n        std::string content;\n        std::string timestamp;\n        std::string editedTimestamp;\n        bool tts = false;\n        bool mentionEveryone = false;\n        std::vector<User> mentions;\n        std::vector<Snowflake<User>> mentionRoles;\n        std::vector<Attachment> attachments;\n        std::vector<Embed> embeds;\n        std::vector<Reaction> reactions;\n        bool pinned = false;\n        Snowflake<Webhook> webhookID;\n        enum MessageType {\n            DEFAULT                = 0,\n            RECIPIENT_ADD          = 1,\n            RECIPIENT_REMOVE       = 2,\n            CALL                   = 3,\n            CHANNEL_NAME_CHANGE    = 4,\n            CHANNEL_ICON_CHANGE    = 5,\n            CHANNEL_PINNED_MESSAGE = 6,\n            GUILD_MEMBER_JOIN      = 7\n        } type = DEFAULT;\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Message::ID             , "id"              , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::channelID      , "channel_id"      , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::serverID       , "guild_id"        , json::OPTIONAL_FIELD         ),\n                json::pair                           (&Message::author         , "author"          , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::content        , "content"         , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::member         , "member"          , json::OPTIONAL_FIELD         ),\n                json::pair                           (&Message::timestamp      , "timestamp"       , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::editedTimestamp, "edited_timestamp", json::NULLABLE_FIELD         ),\n                json::pair                           (&Message::tts            , "tts"             , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::mentionEveryone, "mention_everyone", json::REQUIRIED_FIELD        ),\n                json::pair<json::ContainerTypeHelper>(&Message::mentions       , "mentions"        , json::REQUIRIED_FIELD        ),\n                json::pair<json::ContainerTypeHelper>(&Message::mentionRoles   , "mention_roles"   , json::REQUIRIED_FIELD        ),\n                json::pair<json::ContainerTypeHelper>(&Message::attachments    , "attachments"     , json::REQUIRIED_FIELD        ),\n                json::pair<json::ContainerTypeHelper>(&Message::embeds         , "embeds"          , json::REQUIRIED_FIELD        ),\n                json::pair<json::ContainerTypeHelper>(&Message::reactions      , "reactions"       , json::OPTIONAL_FIELD         ),\n                json::pair                           (&Message::pinned         , "pinned"          , json::REQUIRIED_FIELD        ),\n                json::pair                           (&Message::webhookID      , "webhook_id"      , json::OPTIONAL_FIELD         ),\n                json::pair<json::EnumTypeHelper     >(&Message::type           , "type"            , json::REQUIRIED_FIELD        )\n            );\n        JSONStructEnd\n    };\n\n    struct MessageRevisions {\n        MessageRevisions(const json::Value& json) :\n            messageID(json["id"]), channelID(json["channel_id"]), RevisionsJSON(json)\n        {}\n        inline void applyChanges(Message& outOfDateMessage) {\n            assert(outOfDateMessage.ID == messageID);\n            json::fromJSON(outOfDateMessage, RevisionsJSON);\n        }\n        Snowflake<Message> messageID;\n        Snowflake<Channel> channelID;\n        const json::Value& RevisionsJSON;\n    };\n\n    struct SendMessageParams : public DiscordObject {\n    public:\n        Snowflake<Channel> channelID;\n        std::string content = {};\n        bool tts = false;\n        Embed embed = Embed::Flag::INVALID_EMBED;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&SendMessageParams::content, "content", json::REQUIRIED_FIELD),\n                json::pair(&SendMessageParams::tts    , "tts"    , json::OPTIONAL_FIELD ),\n                json::pair(&SendMessageParams::embed  , "embed"  , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n}\n')),Object(a.b)("hr",null),Object(a.b)("p",null,"Updated on  9 February 2021 at 07:04:58 Eastern Standard Time"))}d.isMDXComponent=!0},321:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return u}));var s=t(0),r=t.n(s);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,s,r=function(e,n){if(null==e)return{};var t,s,r={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=r.a.createContext({}),d=function(e){var n=r.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},p=function(e){var n=d(e.components);return r.a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},b=r.a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,o=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=d(t),b=s,u=p["".concat(o,".").concat(b)]||p[b]||m[b]||a;return t?r.a.createElement(u,c(c({ref:n},l),{},{components:t})):r.a.createElement(u,c({ref:n},l))}));function u(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var a=t.length,o=new Array(a);o[0]=b;var c={};for(var i in n)hasOwnProperty.call(n,i)&&(c[i]=n[i]);c.originalType=e,c.mdxType="string"==typeof e?e:s,o[1]=c;for(var l=2;l<a;l++)o[l]=t[l];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"}}]);