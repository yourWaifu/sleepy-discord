(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{117:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return d})),t.d(n,"default",(function(){return l}));var r=t(3),s=t(7),o=(t(0),t(364)),a={title:"include/sleepy_discord/embed.h"},i={unversionedId:"reference/Files/embed_8h",id:"reference/Files/embed_8h",isDocsHomePage:!1,title:"include/sleepy_discord/embed.h",description:"Namespaces",source:"@site/docs/reference/Files/embed_8h.md",slug:"/reference/Files/embed_8h",permalink:"/sleepy-discord/docs/reference/Files/embed_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/embed.cpp",permalink:"/sleepy-discord/docs/reference/Files/embed_8cpp"},next:{title:"sleepy_discord/endpoints.cpp",permalink:"/sleepy-discord/docs/reference/Files/endpoints_8cpp"}},d=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Source code",id:"source-code",children:[]}],c={toc:d};function l(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"namespaces"},"Namespaces"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",{parentName:"tr",align:null},"Name"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(o.b)("h2",{id:"classes"},"Classes"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",{parentName:"tr",align:null}),Object(o.b)("th",{parentName:"tr",align:null},"Name"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_thumbnail"},"SleepyDiscord::EmbedThumbnail")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_video"},"SleepyDiscord::EmbedVideo")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_image"},"SleepyDiscord::EmbedImage")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_provider"},"SleepyDiscord::EmbedProvider")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_author"},"SleepyDiscord::EmbedAuthor")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_footer"},"SleepyDiscord::EmbedFooter")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed_field"},"SleepyDiscord::EmbedField")))),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"struct"),Object(o.b)("td",{parentName:"tr",align:null},Object(o.b)("strong",{parentName:"td"},Object(o.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_embed"},"SleepyDiscord::Embed")))))),Object(o.b)("h2",{id:"source-code"},"Source code"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <string>\n#include "discord_object_interface.h"\n\nnamespace SleepyDiscord {\n    struct SendMessageParams;\n\n    struct EmbedThumbnail : public DiscordObject {\n    public:\n        EmbedThumbnail() = default;\n        //EmbedThumbnail(const std::string * rawJSON);\n        EmbedThumbnail(const json::Value & json);\n        EmbedThumbnail(const nonstd::string_view & json);\n        //EmbedThumbnail(const json::Values values);\n        std::string url;\n        std::string proxyUrl;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty();\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedThumbnail::url     , "url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::proxyUrl, "proxy_url", json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::height  , "height"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::width   , "width"    , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedVideo : public DiscordObject {\n    public:\n        EmbedVideo() = default;\n        EmbedVideo(const json::Value & json);\n        EmbedVideo(const nonstd::string_view & json);\n        std::string url;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedVideo::url   , "url"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedVideo::height, "height", json::OPTIONAL_FIELD),\n                json::pair(&EmbedVideo::width , "width" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n\n    struct EmbedImage : public DiscordObject {\n    public:\n        EmbedImage() = default;\n        EmbedImage(const json::Value & json);\n        EmbedImage(const nonstd::string_view & json);\n        std::string url;\n        std::string proxyUrl;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty() && proxyUrl.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedImage::url     , "url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::proxyUrl, "proxy_url", json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::height  , "height"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::width   , "width"    , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedProvider : public DiscordObject {\n    public:\n        EmbedProvider() = default;\n        //EmbedProvider(const std::string * rawJSON);\n        EmbedProvider(const json::Value & json);\n        EmbedProvider(const nonstd::string_view & json);\n        //EmbedProvider(const json::Values values);\n        std::string name;\n        std::string url;\n\n        bool empty() const {\n            return name.empty() && url.empty();\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedProvider::name, "name", json::OPTIONAL_FIELD),\n                json::pair(&EmbedProvider::url , "url" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedAuthor : public DiscordObject {\n    public:\n        EmbedAuthor() = default;\n        EmbedAuthor(const json::Value & json);\n        EmbedAuthor(const nonstd::string_view & json);\n        std::string name;\n        std::string url;\n        std::string iconUrl;\n        std::string proxyIconUrl;\n\n        bool empty() const {\n            return name.empty() && url.empty() && iconUrl.empty() && proxyIconUrl.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedAuthor::name        , "name"          , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::url         , "url"           , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::iconUrl     , "icon_url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::proxyIconUrl, "proxy_icon_url", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedFooter : public DiscordObject {\n    public:\n        EmbedFooter() = default;\n        EmbedFooter(const json::Value & json);\n        EmbedFooter(const nonstd::string_view & json);\n        std::string text;\n        std::string iconUrl;\n        std::string proxyIconUrl;\n\n        bool empty() const {\n            return text.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedFooter::text        , "text"          , json::REQUIRIED_FIELD),\n                json::pair(&EmbedFooter::iconUrl     , "icon_url"      , json::OPTIONAL_FIELD ),\n                json::pair(&EmbedFooter::proxyIconUrl, "proxy_icon_url", json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedField : public DiscordObject {\n    public:\n        EmbedField() = default;\n        EmbedField(const json::Value & json);\n        EmbedField(const nonstd::string_view & json);\n        EmbedField(std::string _name, std::string _value, bool _isInline = false)\n            : name(_name), value(_value), isInline(_isInline) {}\n        std::string name = "";\n        std::string value = "";\n        bool isInline = false;\n\n        bool empty() const {\n            return value.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedField::name    , "name"  , json::OPTIONAL_FIELD),\n                json::pair(&EmbedField::value   , "value" , json::OPTIONAL_FIELD),\n                json::pair(&EmbedField::isInline, "inline", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct Embed : public DiscordObject {\n    public:\n        Embed() = default;\n        //Embed(const std::string * rawJSON);\n        Embed(const json::Value & json);\n        Embed(const nonstd::string_view & json);\n        //Embed(const json::Values values);\n        enum class Flag {\n            INVALID_EMBED = 0,\n            VALID_EMBED = 1\n        };\n        Embed(const Flag f) : flags(f) {}\n        std::string title;\n        std::string type;\n        std::string description;\n        std::string url;\n        std::string timestamp;\n        int32_t color = -1;\n        EmbedFooter footer;\n        EmbedImage image;\n        EmbedThumbnail thumbnail;\n        EmbedVideo video;\n        EmbedProvider provider;\n        EmbedAuthor author;\n        std::vector<EmbedField> fields;\n\n        bool empty() const {\n            return (flags == Flag::INVALID_EMBED) || (title.empty() && description.empty() && url.empty() &&\n                color == -1 && footer.empty() && image.empty() && thumbnail.empty() && video.empty() &&\n                provider.empty() && author.empty() && fields.empty());\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Embed::title      , "title"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::type       , "type"       , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::description, "description", json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::url        , "url"        , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::timestamp  , "timestamp"  , json::OPTIONAL_FIELD),\n                json::pair<-1                       >(&Embed::color      , "color"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::footer     , "footer"     , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::image      , "image"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::thumbnail  , "thumbnail"  , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::video      , "video"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::provider   , "provider"   , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::author     , "author"     , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Embed::fields     , "fields"     , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n    private:\n        friend BaseDiscordClient;\n        friend SendMessageParams;\n\n        Flag flags = Flag::VALID_EMBED;\n    };\n}\n')),Object(o.b)("hr",null),Object(o.b)("p",null,"Updated on 30 April 2021 at 21:51:50 UTC"))}l.isMDXComponent=!0},364:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return u}));var r=t(0),s=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=s.a.createContext({}),l=function(e){var n=s.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},b=function(e){var n=l(e.components);return s.a.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return s.a.createElement(s.a.Fragment,{},n)}},p=s.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,a=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),b=l(t),p=r,u=b["".concat(a,".").concat(p)]||b[p]||m[p]||o;return t?s.a.createElement(u,i(i({ref:n},c),{},{components:t})):s.a.createElement(u,i({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,a=new Array(o);a[0]=p;var i={};for(var d in n)hasOwnProperty.call(n,d)&&(i[d]=n[d]);i.originalType=e,i.mdxType="string"==typeof e?e:r,a[1]=i;for(var c=2;c<o;c++)a[c]=t[c];return s.a.createElement.apply(null,a)}return s.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);