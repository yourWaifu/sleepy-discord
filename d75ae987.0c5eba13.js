(window.webpackJsonp=window.webpackJsonp||[]).push([[258],{328:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return i}));var a=n(3),r=n(7),l=(n(0),n(383)),s={title:"include/sleepy_discord/json_wrapper.h"},c={unversionedId:"reference/Files/json__wrapper_8h",id:"reference/Files/json__wrapper_8h",isDocsHomePage:!1,title:"include/sleepy_discord/json_wrapper.h",description:"Namespaces",source:"@site/docs/reference/Files/json__wrapper_8h.md",slug:"/reference/Files/json__wrapper_8h",permalink:"/sleepy-discord/docs/reference/Files/json__wrapper_8h",version:"current",sidebar:"Reference",previous:{title:"sleepy_discord/json_wrapper.cpp",permalink:"/sleepy-discord/docs/reference/Files/json__wrapper_8cpp"},next:{title:"sleepy_discord/message.cpp",permalink:"/sleepy-discord/docs/reference/Files/message_8cpp"}},o=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Types",id:"types",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Defines",id:"defines",children:[]},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum FieldType",id:"enum-fieldtype",children:[]},{value:"enum FromJSONMode",id:"enum-fromjsonmode",children:[]},{value:"typedef SizeType",id:"typedef-sizetype",children:[]},{value:"using Value",id:"using-value",children:[]},{value:"using Array",id:"using-array",children:[]},{value:"using Values",id:"using-values",children:[]},{value:"using JSONConverter",id:"using-jsonconverter",children:[]}]},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function createJSON",id:"function-createjson",children:[]},{value:"function string",id:"function-string",children:[]},{value:"function UInteger",id:"function-uinteger",children:[]},{value:"function optionalUInteger",id:"function-optionaluinteger",children:[]},{value:"function integer",id:"function-integer",children:[]},{value:"function optionalInteger",id:"function-optionalinteger",children:[]},{value:"function boolean",id:"function-boolean",children:[]},{value:"function createJSONArray",id:"function-createjsonarray",children:[]},{value:"function hasPushBack",id:"function-haspushback",children:[]},{value:"function hasPushBack",id:"function-haspushback-1",children:[]},{value:"function leaveAlone",id:"function-leavealone",children:[]},{value:"function toString",id:"function-tostring",children:[]},{value:"function toStdString",id:"function-tostdstring",children:[]},{value:"function toStdStringView",id:"function-tostdstringview",children:[]},{value:"function toInt",id:"function-toint",children:[]},{value:"function toUint",id:"function-touint",children:[]},{value:"function toInt64",id:"function-toint64",children:[]},{value:"function toUint64",id:"function-touint64",children:[]},{value:"function toDouble",id:"function-todouble",children:[]},{value:"function toFloat",id:"function-tofloat",children:[]},{value:"function toBool",id:"function-tobool",children:[]},{value:"function toArray",id:"function-toarray",children:[]},{value:"function toEnum",id:"function-toenum",children:[]},{value:"function toJSON",id:"function-tojson",children:[]},{value:"function pair",id:"function-pair",children:[]},{value:"function pair",id:"function-pair-1",children:[]},{value:"function pair",id:"function-pair-2",children:[]},{value:"function castValue",id:"function-castvalue",children:[]},{value:"function fromJSON",id:"function-fromjson",children:[]}]},{value:"Macro Documentation",id:"macro-documentation",children:[{value:"define RAPIDJSON_NO_SIZETYPEDEFINE",id:"define-rapidjson_no_sizetypedefine",children:[]},{value:"define JSONStruct",id:"define-jsonstruct",children:[]},{value:"define JSONStructStart",id:"define-jsonstructstart",children:[]},{value:"define JSONStructEnd",id:"define-jsonstructend",children:[]}]},{value:"Source code",id:"source-code",children:[]}],p={toc:o};function i(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"namespaces"},"Namespaces"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Name"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord_1_1json"},"SleepyDiscord::json")))))),Object(l.b)("h2",{id:"classes"},"Classes"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null}),Object(l.b)("th",{parentName:"tr",align:null},"Name"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_default"},"SleepyDiscord::GetDefault")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1_get_enum_base_type"},"SleepyDiscord::GetEnumBaseType")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper"},"SleepyDiscord::json::ClassTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_string_wrapper"},"SleepyDiscord::json::ArrayStringWrapper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_value_wrapper"},"SleepyDiscord::json::ArrayValueWrapper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_value_wrapper_3_01_type_00_01typename_01std_1_1enable__ic278f49c55d1ff83c8431dd68b94506f"},"SleepyDiscord::json::ArrayValueWrapper< Type, typename std::enable_if< std::is_constructible< Type, const Value >::value >::type >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_value_wrapper_3_01_type_00_01typename_01std_1_1enable__i57bef9183313cb1d101ea260a14b38a8"},"SleepyDiscord::json::ArrayValueWrapper< Type, typename std::enable_if< std::is_constructible< Type, Value >::value >::type >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_wrapper"},"SleepyDiscord::json::ArrayWrapper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_array_wrapper_3_01_value_00_01_base_01_4"},"SleepyDiscord::json::ArrayWrapper< Value, Base >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_empty_function"},"SleepyDiscord::json::EmptyFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_string_function"},"SleepyDiscord::json::IsStringFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_number_function"},"SleepyDiscord::json::IsNumberFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_bool_function"},"SleepyDiscord::json::IsBoolFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_array_function"},"SleepyDiscord::json::IsArrayFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_object_function"},"SleepyDiscord::json::IsObjectFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1has_serialize"},"SleepyDiscord::json::hasSerialize")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1has_is_type"},"SleepyDiscord::json::hasIsType")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper"},"SleepyDiscord::json::ClassTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01std_1_1string_01_4"},"SleepyDiscord::json::ClassTypeHelper< std::string >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01nonstd_1_1string__view_01_4"},"SleepyDiscord::json::ClassTypeHelper< nonstd::string_view >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01_value_01_4"},"SleepyDiscord::json::ClassTypeHelper< Value >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_primitive_type_function"},"SleepyDiscord::json::IsPrimitiveTypeFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_is_primitive_type_function_3_01bool_01_4"},"SleepyDiscord::json::IsPrimitiveTypeFunction< bool >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_primitive_type_helper"},"SleepyDiscord::json::PrimitiveTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01int_01_4"},"SleepyDiscord::json::ClassTypeHelper< int >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01uint32__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< uint32_t >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01int64__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< int64_t >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01uint64__t_01_4"},"SleepyDiscord::json::ClassTypeHelper< uint64_t >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01float_01_4"},"SleepyDiscord::json::ClassTypeHelper< float >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01double_01_4"},"SleepyDiscord::json::ClassTypeHelper< double >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_class_type_helper_3_01bool_01_4"},"SleepyDiscord::json::ClassTypeHelper< bool >")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_base_enum_type_helper"},"SleepyDiscord::json::BaseEnumTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_enum_type_helper"},"SleepyDiscord::json::EnumTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_from_container_function"},"SleepyDiscord::json::FromContainerFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_to_container_function"},"SleepyDiscord::json::ToContainerFunction")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_container_type_helper"},"SleepyDiscord::json::ContainerTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_std_array_type_helper"},"SleepyDiscord::json::StdArrayTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_smart_ptr_type_helper"},"SleepyDiscord::json::SmartPtrTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_optional_type_helper"},"SleepyDiscord::json::OptionalTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_nullable_type_helper"},"SleepyDiscord::json::NullableTypeHelper")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"struct"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Classes/struct_sleepy_discord_1_1json_1_1_pair_impl"},"SleepyDiscord::json::PairImpl")))))),Object(l.b)("h2",{id:"types"},"Types"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null}),Object(l.b)("th",{parentName:"tr",align:null},"Name"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"enum"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#enum-fieldtype"},"FieldType"))," { REQUIRIED_FIELD = 0, OPTIONAL_FIELD = 1 << 0, NULLABLE_FIELD = 1 << 1, OPTIONAL_NULLABLE_FIELD = OPTIONAL_FIELD")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"enum"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#enum-fromjsonmode"},"FromJSONMode"))," { Default = 0, ReturnOnError = 1}")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"typedef std::size_t"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#typedef-sizetype"},"SizeType")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"using rapidjson::Value"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#using-value"},"Value")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"using rapidjson::Value::ConstArray"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#using-array"},"Array")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"using Value"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#using-values"},"Values")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <class Return ",">"," ",Object(l.b)("br",null),"using Return(*)(const Value &)"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#using-jsonconverter"},"JSONConverter")))))),Object(l.b)("h2",{id:"functions"},"Functions"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null}),Object(l.b)("th",{parentName:"tr",align:null},"Name"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-createjson"},"createJSON")),"(std::initializer_list< std::pair< std::string, std::string >> json)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-string"},"string")),"(const std::string & s)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-uinteger"},"UInteger")),"(const uint64_t num)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-optionaluinteger"},"optionalUInteger")),"(const uint64_t num)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-integer"},"integer")),"(const int64_t num)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-optionalinteger"},"optionalInteger")),"(const int64_t num)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-boolean"},"boolean")),"(const bool boolean)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <class Type ",">"," ",Object(l.b)("br",null),"const std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-createjsonarray"},"createJSONArray")),"(const std::vector< Type > source)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <typename T ",">"," ",Object(l.b)("br",null),"constexpr auto"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-haspushback"},"hasPushBack")),"(int )")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <typename T ",">"," ",Object(l.b)("br",null),"constexpr std::false_type"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-haspushback"},"hasPushBack")),"(long )")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const Value &"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-leavealone"},"leaveAlone")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"const char *"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-tostring"},"toString")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"std::string"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-tostdstring"},"toStdString")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"nonstd::string_view"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-tostdstringview"},"toStdStringView")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"int"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-toint"},"toInt")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"unsigned int"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-touint"},"toUint")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"int64_t"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-toint64"},"toInt64")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"uint64_t"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-touint64"},"toUint64")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"double"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-todouble"},"toDouble")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"float"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-tofloat"},"toFloat")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"bool"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-tobool"},"toBool")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <class Type ,class Value ",">"," ",Object(l.b)("br",null),"ArrayWrapper< Type, ArrayStringWrapper< Value > >"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-toarray"},"toArray")),"(Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <class Type ",">"," ",Object(l.b)("br",null),"Type"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-toenum"},"toEnum")),"(const Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <class Object ",">"," ",Object(l.b)("br",null),"Value"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-tojson"},"toJSON")),"(const Object & object, Value::AllocatorType & allocator)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <int defaultValue,template< class, int > class TypeHelper =PrimitiveTypeHelper,class Class ,class Type ",">"," ",Object(l.b)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type, defaultValue > >"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",Object(l.b)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <template< class > class TypeHelper =ClassTypeHelper,class Class ,class Type ",">"," ",Object(l.b)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type > >"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",Object(l.b)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <template< class, template< class... > class > class TypeHelper,template< class... > class TypeHelper2 =ClassTypeHelper,class Class ,class Type ",">"," ",Object(l.b)("br",null),"constexpr PairImpl< Class, Type, TypeHelper< Type, TypeHelper2 > >"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-pair"},"pair")),"(Type Class::",Object(l.b)("em",{parentName:"td"}," member, const char ")," name, FieldType type)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <class Helper ,class ResultingObject ,class Value ",">"," ",Object(l.b)("br",null),"bool"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-castvalue"},"castValue")),"(ResultingObject & result, Value & value)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"template <FromJSONMode mode =FromJSONMode::Default,class ResultingObject ,class Value ,size_t i =0",">"," ",Object(l.b)("br",null),"std::enable_if< i==std::tuple_size< decltype(ResultingObject::JSONStruct)>::value, bool >::type"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#function-fromjson"},"fromJSON")),"(ResultingObject & , Value & )")))),Object(l.b)("h2",{id:"defines"},"Defines"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null}),Object(l.b)("th",{parentName:"tr",align:null},"Name"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null}),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#define-rapidjson_no_sizetypedefine"},"RAPIDJSON_NO_SIZETYPEDEFINE")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null}),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#define-jsonstruct"},"JSONStruct")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null}),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#define-jsonstructstart"},"JSONStructStart")))),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null}),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},Object(l.b)("a",{parentName:"strong",href:"/docs/reference/Files/json__wrapper_8h#define-jsonstructend"},"JSONStructEnd")))))),Object(l.b)("h2",{id:"types-documentation"},"Types Documentation"),Object(l.b)("h3",{id:"enum-fieldtype"},"enum FieldType"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(l.b)("th",{parentName:"tr",align:null},"Value"),Object(l.b)("th",{parentName:"tr",align:null},"Description"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"REQUIRIED_FIELD"),Object(l.b)("td",{parentName:"tr",align:null},"0"),Object(l.b)("td",{parentName:"tr",align:null})),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"OPTIONAL_FIELD"),Object(l.b)("td",{parentName:"tr",align:null},"1 << 0"),Object(l.b)("td",{parentName:"tr",align:null})),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"NULLABLE_FIELD"),Object(l.b)("td",{parentName:"tr",align:null},"1 << 1"),Object(l.b)("td",{parentName:"tr",align:null})),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"OPTIONAL_NULLABLE_FIELD"),Object(l.b)("td",{parentName:"tr",align:null},"OPTIONAL_FIELD"),Object(l.b)("td",{parentName:"tr",align:null},"NULLABLE_FIELD")))),Object(l.b)("h3",{id:"enum-fromjsonmode"},"enum FromJSONMode"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Enumerator"),Object(l.b)("th",{parentName:"tr",align:null},"Value"),Object(l.b)("th",{parentName:"tr",align:null},"Description"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"Default"),Object(l.b)("td",{parentName:"tr",align:null},"0"),Object(l.b)("td",{parentName:"tr",align:null})),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},"ReturnOnError"),Object(l.b)("td",{parentName:"tr",align:null},"1"),Object(l.b)("td",{parentName:"tr",align:null})))),Object(l.b)("h3",{id:"typedef-sizetype"},"typedef SizeType"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"typedef std::size_t SizeType;\n")),Object(l.b)("h3",{id:"using-value"},"using Value"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::json::Value = typedef rapidjson::Value;\n")),Object(l.b)("h3",{id:"using-array"},"using Array"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::json::Array = typedef rapidjson::Value::ConstArray;\n")),Object(l.b)("h3",{id:"using-values"},"using Values"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::json::Values = typedef Value;\n")),Object(l.b)("h3",{id:"using-jsonconverter"},"using JSONConverter"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Return >\nusing SleepyDiscord::json::JSONConverter = typedef Return(*)(const Value&);\n")),Object(l.b)("h2",{id:"functions-documentation"},"Functions Documentation"),Object(l.b)("h3",{id:"function-createjson"},"function createJSON"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string createJSON(\n    std::initializer_list< std::pair< std::string, std::string >> json\n)\n")),Object(l.b)("h3",{id:"function-string"},"function string"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string string(\n    const std::string & s\n)\n")),Object(l.b)("h3",{id:"function-uinteger"},"function UInteger"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string UInteger(\n    const uint64_t num\n)\n")),Object(l.b)("h3",{id:"function-optionaluinteger"},"function optionalUInteger"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string optionalUInteger(\n    const uint64_t num\n)\n")),Object(l.b)("h3",{id:"function-integer"},"function integer"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string integer(\n    const int64_t num\n)\n")),Object(l.b)("h3",{id:"function-optionalinteger"},"function optionalInteger"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string optionalInteger(\n    const int64_t num\n)\n")),Object(l.b)("h3",{id:"function-boolean"},"function boolean"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"const std::string boolean(\n    const bool boolean\n)\n")),Object(l.b)("h3",{id:"function-createjsonarray"},"function createJSONArray"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Type >\nconst std::string createJSONArray(\n    const std::vector< Type > source\n)\n")),Object(l.b)("h3",{id:"function-haspushback"},"function hasPushBack"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <typename T >\nconstexpr auto hasPushBack(\n    int \n)\n")),Object(l.b)("h3",{id:"function-haspushback-1"},"function hasPushBack"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <typename T >\nconstexpr std::false_type hasPushBack(\n    long \n)\n")),Object(l.b)("h3",{id:"function-leavealone"},"function leaveAlone"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline const Value & leaveAlone(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-tostring"},"function toString"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline const char * toString(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-tostdstring"},"function toStdString"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline std::string toStdString(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-tostdstringview"},"function toStdStringView"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline nonstd::string_view toStdStringView(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-toint"},"function toInt"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline int toInt(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-touint"},"function toUint"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline unsigned int toUint(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-toint64"},"function toInt64"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline int64_t toInt64(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-touint64"},"function toUint64"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline uint64_t toUint64(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-todouble"},"function toDouble"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline double toDouble(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-tofloat"},"function toFloat"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline float toFloat(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-tobool"},"function toBool"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"inline bool toBool(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-toarray"},"function toArray"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Type ,\nclass Value >\ninline ArrayWrapper< Type, ArrayStringWrapper< Value > > toArray(\n    Value & value\n)\n")),Object(l.b)("h3",{id:"function-toenum"},"function toEnum"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Type >\ninline Type toEnum(\n    const Value & value\n)\n")),Object(l.b)("h3",{id:"function-tojson"},"function toJSON"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Object >\ninline Value toJSON(\n    const Object & object,\n    Value::AllocatorType & allocator\n)\n")),Object(l.b)("h3",{id:"function-pair"},"function pair"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <int defaultValue,\ntemplate< class, int > class TypeHelper =PrimitiveTypeHelper,\nclass Class ,\nclass Type >\nconstexpr PairImpl< Class, Type, TypeHelper< Type, defaultValue > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),Object(l.b)("h3",{id:"function-pair-1"},"function pair"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <template< class > class TypeHelper =ClassTypeHelper,\nclass Class ,\nclass Type >\nconstexpr PairImpl< Class, Type, TypeHelper< Type > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),Object(l.b)("h3",{id:"function-pair-2"},"function pair"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <template< class, template< class... > class > class TypeHelper,\ntemplate< class... > class TypeHelper2 =ClassTypeHelper,\nclass Class ,\nclass Type >\nconstexpr PairImpl< Class, Type, TypeHelper< Type, TypeHelper2 > > pair(\n    Type Class::* member,\n    const char * name,\n    FieldType type\n)\n")),Object(l.b)("h3",{id:"function-castvalue"},"function castValue"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <class Helper ,\nclass ResultingObject ,\nclass Value >\ninline bool castValue(\n    ResultingObject & result,\n    Value & value\n)\n")),Object(l.b)("h3",{id:"function-fromjson"},"function fromJSON"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"template <FromJSONMode mode =FromJSONMode::Default,\nclass ResultingObject ,\nclass Value ,\nsize_t i =0>\ninline std::enable_if< i==std::tuple_size< decltype(ResultingObject::JSONStruct)>::value, bool >::type fromJSON(\n    ResultingObject & ,\n    Value & \n)\n")),Object(l.b)("h2",{id:"macro-documentation"},"Macro Documentation"),Object(l.b)("h3",{id:"define-rapidjson_no_sizetypedefine"},"define RAPIDJSON_NO_SIZETYPEDEFINE"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"#define RAPIDJSON_NO_SIZETYPEDEFINE \n")),Object(l.b)("h3",{id:"define-jsonstruct"},"define JSONStruct"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"#define JSONStruct JSONStructure\n")),Object(l.b)("h3",{id:"define-jsonstructstart"},"define JSONStructStart"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"#define JSONStructStart constexpr static auto JSONStruct =\n")),Object(l.b)("h3",{id:"define-jsonstructend"},"define JSONStructEnd"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},"#define JSONStructEnd \n")),Object(l.b)("h2",{id:"source-code"},"Source code"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <list>\n#include <utility>\n#include <vector>\n#include <array>\n#include <tuple>\n#include <memory>\n#include <type_traits>\n//for errrors\n#include <iostream>\n#include "nonstd/optional.hpp"\n\n#define RAPIDJSON_NO_SIZETYPEDEFINE\ntypedef std::size_t SizeType;\n#include "rapidjson/document.h"\n#include "rapidjson/writer.h"\n#include "rapidjson/stringbuffer.h"\n#include "nonstd/string_view.hpp"\n//#include "json.h"\n\nnamespace SleepyDiscord {\n    //this is outside of the json namespace\n    //to stop us from hiting some compiler bugs\n    template<class Type>\n    struct GetDefault {\n        static inline const Type get() {\n            return static_cast<Type>(0);\n        }\n    };\n\n    template<class Type>\n    struct GetEnumBaseType {\n        using Value = int64_t;\n    };\n\n    namespace json {\n        //using Value = nonstd::string_view;\n        //using Values = std::vector<Value>;\n\n        using Value = rapidjson::Value;\n        using Array = rapidjson::Value::ConstArray;\n        using Values = Value;\n\n        //Values getArray(const Value& source);\n        //Values getValues(const char* source, std::initializer_list<const char *const> const &names);\n        //Value getValue(const char* source, const char * name);\n\n        const std::string createJSON(std::initializer_list<std::pair<std::string, std::string>> json);\n        const std::string string(const std::string& s);\n        const std::string UInteger(const uint64_t num);\n        const std::string optionalUInteger(const uint64_t num);\n        const std::string integer(const int64_t num);\n        const std::string optionalInteger(const int64_t num);\n        const std::string boolean(const bool boolean);\n\n        template<class Type>\n        const std::string createJSONArray(const std::vector<Type> source) {\n            if (source.empty())\n                return "";\n            std::string target;\n            target += \'[\';\n            for (std::string value : source) {\n                if (!value.empty()) {\n                    target += value;\n                    target += \',\';\n                }\n            }\n            char& back = target.back();\n            if (back == \',\') {\n                back = \']\';\n            } else {\n                target += \']\';\n            }\n            return target;\n        }\n\n        template <class Type>\n        struct ClassTypeHelper;\n\n        template<class Value = const json::Value>\n        struct ArrayStringWrapper {\n            Value& json;\n            ArrayStringWrapper(Value& json) : json(json) {}\n            inline Value& getDoc() const { return json; }\n            operator Value&() const { return getDoc(); }\n            template<class Callback>\n            const bool getDoc(const Callback& callback) const {\n                callback(json);\n                return true;\n            }\n        };\n\n        template<class Type, class Enable = void>\n        struct ArrayValueWrapper {\n            using value = const Value;\n            using type = ArrayStringWrapper<value>;\n        };\n\n        template<class Type>\n        struct ArrayValueWrapper<\n            Type, typename std::enable_if<std::is_constructible<Type, const Value>::value>::type\n        > {\n            using value = const Value;\n            using type = ArrayStringWrapper<value>;\n        };\n\n        template<class Type>\n        struct ArrayValueWrapper<\n            Type, typename std::enable_if<std::is_constructible<Type, Value>::value>::type\n        > {\n            using value = Value;\n            using type = ArrayStringWrapper<value>;\n        };\n\n        template <typename T>\n        constexpr auto hasPushBack(int)\n            -> decltype( std::declval<T>().push_back(*(std::declval<T>().begin())),\n                            std::true_type() );\n        \n        template <typename T>\n        constexpr std::false_type hasPushBack(long);\n\n        template<class TypeToConvertTo, class Base = typename ArrayValueWrapper<TypeToConvertTo>::type>\n        struct ArrayWrapper : public Base {\n            using base = Base;\n            using Base::Base;\n            using DocType = decltype(((Base*)nullptr)->getDoc());\n\n            template<class Container, class Value>\n            static inline Container get(Value& value, std::true_type) {\n                auto jsonArray = value.GetArray(); //can be ether const Array or Array, so we use auto\n                return Container(jsonArray.begin(), jsonArray.end());\n            }\n\n            template<class Container, class Value>\n            static inline Container get(Value&& value, std::false_type) {\n                DocType v = std::move(value);\n                return get<Container>(v, std::true_type{});\n            }\n\n            template<class Container, class Value>\n            static inline Container get(Value&& value) { //lvalue check\n                return get<Container>(value, std::is_lvalue_reference<Value&&>());\n            }\n\n            template<class Container>\n            Container get() {\n                return get<Container>(Base::getDoc());\n            }\n\n            template<template<class...> class Container, typename Type = TypeToConvertTo>\n            Container<Type> get() {\n                return get<Container<Type>>();\n            }\n\n            template<class Container>\n            bool get(Container& value) {\n                static const auto getter = [&](DocType& doc) {\n                    value = get<Container>(doc);\n                };\n                return Base::getDoc(getter);\n            }\n\n            template<template<class...> class Container, typename Type = TypeToConvertTo>\n            bool get(Container<Type>& value) {\n                return get<Container<Type>>(value);\n            }\n\n            inline std::vector<TypeToConvertTo> vector() { return get<std::vector>(); }\n            inline std::list  <TypeToConvertTo> list  () { return get<std::list>();   }\n\n            //c arrays\n            inline TypeToConvertTo* cArray() { return &vector()[0]; }\n\n            operator Values() { return Base::getArray(); }\n            operator std::vector<TypeToConvertTo>() { return vector(); }\n            operator std::list<TypeToConvertTo>() { return list(); }\n        };\n\n        template<class Return>\n        using JSONConverter = Return(*)(const Value&);\n\n        inline const Value& leaveAlone(const Value& value) {\n            return value;\n        }\n\n        inline const char* toString(const Value& value) {\n            return value.GetString();\n        }\n\n        inline std::string toStdString(const Value& value) {\n            return std::string(value.GetString(), value.GetStringLength());\n        }\n\n        inline nonstd::string_view toStdStringView(const Value& value) {\n            return nonstd::string_view(value.GetString(), value.GetStringLength());\n        }\n\n        inline int toInt(const Value& value) {\n            return value.GetInt();\n        }\n\n        inline unsigned int toUint(const Value& value) {\n            return value.GetUint();\n        }\n\n        inline int64_t toInt64(const Value& value) {\n            return value.GetInt64();\n        }\n\n        inline uint64_t toUint64(const Value& value) {\n            return value.GetUint64();\n        }\n\n        inline double toDouble(const Value& value) {\n            return value.GetDouble();\n        }\n\n        inline float toFloat(const Value& value) {\n            return value.GetFloat();\n        }\n\n        inline bool toBool(const Value& value) {\n            return value.GetBool();\n        }\n\n        template<class Type, class Value>\n        inline ArrayWrapper<Type, ArrayStringWrapper<Value>> toArray(Value& value) {\n            return ArrayWrapper<Type, ArrayStringWrapper<Value>>(value);\n        }\n\n        template<class Type>\n        inline Type toEnum(const Value& value) {\n            return static_cast<Type>(value.Get<typename GetEnumBaseType<Type>::Value>());\n        }\n\n        template<class Base>\n        struct ArrayWrapper<Value, Base> : public Base {\n            using Base::Base;\n            operator Values() {\n                return Base::getArray();\n            }\n        };\n\n        template <class Type>\n        struct EmptyFunction {\n            static inline bool empty(const Type& value) {\n                return value.empty();\n            }\n        };\n\n        struct IsStringFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsString();\n            }\n        };\n\n        struct IsNumberFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsNumber();\n            }\n        };\n\n        struct IsBoolFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsBool();\n            }\n        };\n\n        struct IsArrayFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsArray();\n            }\n        };\n\n        struct IsObjectFunction {\n            static inline bool isType(const Value& value) {\n                return value.IsObject();\n            }\n        };\n\n        //ClassTypeHelper needs to be able to call toJSON so it\'s forward decleared\n        template<class Object>\n        inline Value toJSON(const Object& object, Value::AllocatorType& allocator);\n\n        //ClassTypeHelper needs to know if object has a serialize member\n        template<class Object>\n        struct hasSerialize {\n        private:\n            template<typename T>\n            static constexpr auto check(T*)\n            -> typename\n                std::is_same<\n                    decltype( std::declval<T>().serialize(\n                        std::declval<Value::AllocatorType&>()\n                    ) ),\n                    Value\n                >::type;\n            \n            template<typename>\n            static constexpr std::false_type check(...);\n        \n        public:\n            using type = decltype(check<Object>(0));\n            static constexpr bool value = type::value;\n        };\n\n        template<class Object>\n        struct hasIsType {\n        private:\n            template<typename T>\n            static constexpr auto check(T*)\n            -> typename\n                std::is_same<\n                    decltype( std::declval<T>().isType(\n                        std::declval<Value&>()\n                    ) ),\n                    bool\n                >::type;\n            \n            template<typename>\n            static constexpr std::false_type check(...);\n        \n        public:\n            using type = decltype(check<Object>(0));\n            static constexpr bool value = type::value;\n        };\n\n        template <class Type>\n        struct ClassTypeHelper : public EmptyFunction<Type> {\n            template<class Value>\n            static inline Type toType(Value& value) {\n                return value;\n            }\n\n            template<class T>\n            static inline typename std::enable_if<hasSerialize<T>::value, Value>::type\n            fromType(const T& value, Value::AllocatorType& allocator) {\n                return value.serialize(allocator);\n            }\n\n            template<class T>\n            static inline typename std::enable_if<hasSerialize<T>::value == false, Value>::type\n            fromType(const T& value, Value::AllocatorType& allocator) {\n                return toJSON(value, allocator);\n            }\n\n            template<class T = Type>\n            static inline typename std::enable_if<hasIsType<T>::value, bool>::type\n            isType(const Value& value) {\n                return Type::isType(value);\n            }\n\n            template<class T = Type>\n            static inline typename std::enable_if<!hasIsType<T>::value, bool>::type\n            isType(const Value& value) {\n                return value.IsObject();\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<std::string> :\n            public EmptyFunction<std::string>, public IsStringFunction\n        {\n            static inline std::string toType(const Value& value) {\n                return toStdString(value);\n            }\n            static inline Value fromType(const std::string& value) {\n                return Value(value.c_str(), value.length());\n            }\n            static inline Value fromType(const std::string& value, Value::AllocatorType&) {\n                return fromType(value);\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<nonstd::string_view> :\n            public EmptyFunction<nonstd::string_view>, public IsStringFunction\n        {\n            static inline nonstd::string_view toType(const Value& value) {\n                return toStdStringView(value);\n            }\n            static inline Value fromType(const nonstd::string_view& value) {\n                return Value(value.data(), value.length());\n            }\n            static inline Value fromType(const nonstd::string_view& value, Value::AllocatorType&) {\n                return fromType(value);\n            }\n        };\n\n        template<>\n        struct ClassTypeHelper<Value> {\n            static inline rapidjson::Type toType(const Value& value) {\n                //this doesn\'t really do anything\n                //we can\'t copy without allocator\n                //we can only have one return type\n                return value.GetType();\n            }\n            static inline Value& toType(Value& value) {\n                return value; // moves\n            }\n            static inline bool empty(const Value& value) {\n                return value.Empty();\n            }\n            static inline Value fromType(const Value& value, Value::AllocatorType& alloc) {\n                return Value{value, alloc}; //copys\n            }\n            static inline bool isType(const Value&) {\n                return true;\n            }\n        };\n\n        template<class PrimitiveType>\n        struct IsPrimitiveTypeFunction : IsNumberFunction {};\n\n        template<>\n        struct IsPrimitiveTypeFunction<bool> : IsBoolFunction {};\n\n        template <class PrimitiveType, int defaultValue = 0>\n        struct PrimitiveTypeHelper : public IsPrimitiveTypeFunction<PrimitiveType> {\n            static inline PrimitiveType toType(const Value& value) {\n                return value.Get<PrimitiveType>();\n            }\n            static inline bool empty(const PrimitiveType& value) {\n                return value == static_cast<PrimitiveType>(defaultValue);\n            }\n            static inline Value fromType(const PrimitiveType& value) {\n                return Value(value);\n            }\n            static inline Value fromType(const PrimitiveType& value, Value::AllocatorType& /*allocator*/) {\n                return fromType(value);\n            }\n        };\n\n        //for some reason, some compilers need this\n        //template <int defaultValue>\n        //struct PrimitiveTypeHelper<long int, defaultValue> : public PrimitiveTypeHelper<long long, defaultValue> {};\n\n        template<> struct ClassTypeHelper<int     > : public PrimitiveTypeHelper<int     > {};\n        template<> struct ClassTypeHelper<uint32_t> : public PrimitiveTypeHelper<uint32_t> {};\n        template<> struct ClassTypeHelper<int64_t > : public PrimitiveTypeHelper<int64_t > {};\n        template<> struct ClassTypeHelper<uint64_t> : public PrimitiveTypeHelper<uint64_t> {};\n        template<> struct ClassTypeHelper<float   > : public PrimitiveTypeHelper<float   > {};\n        template<> struct ClassTypeHelper<double  > : public PrimitiveTypeHelper<double  > {};\n        template<> struct ClassTypeHelper<bool    > : public PrimitiveTypeHelper<bool    > {};\n\n        template<class Type, class GetDefault, class BaseType>\n        struct BaseEnumTypeHelper {\n            static inline Type toType(const Value& value) {\n                return toEnum<Type>(value);\n            }\n            static inline Value fromType(const Type& value) {\n                return Value(static_cast<BaseType>(value));\n            }\n            static inline Value fromType(const Type& value, Value::AllocatorType&) {\n                return fromType(value);\n            }\n            static inline bool empty(const Type& value) {\n                return value == GetDefault::get();\n            }\n            static inline bool isType(const Value& value) {\n                return ClassTypeHelper<BaseType>::isType(value);\n            }\n        };\n\n        template<class Type>\n        struct EnumTypeHelper : public\n            BaseEnumTypeHelper<Type, GetDefault<Type>, typename GetEnumBaseType<Type>::Value> {};\n\n        template<class Container, template<class...> class TypeHelper>\n        struct FromContainerFunction {\n            static inline Value fromType(const Container& values, Value::AllocatorType& allocator) {\n                Value arr(rapidjson::kArrayType);\n                arr.Reserve(values.size(), allocator);\n                for (const typename Container::value_type& value : values)\n                    arr.PushBack(TypeHelper<typename Container::value_type>::fromType(value, allocator), allocator);\n                return arr;\n            } \n        };\n\n        template<class Container, template<class...> class TypeHelper>\n        struct ToContainerFunction {\n            template<class Value>\n            static inline Container toType(Value& value) {\n                auto jsonArray = value.GetArray();\n                using Helper = TypeHelper<typename Container::value_type>;\n                Container result;\n                std::transform(jsonArray.begin(), jsonArray.end(),\n                    std::back_inserter(result),\n                    [](Value& value){ \n                        return Helper::toType(value);\n                    }\n                );\n                return result;\n            }\n        };\n\n        template<class Container, template<class...> class TypeHelper>\n        struct ContainerTypeHelper :\n            public ToContainerFunction<Container, TypeHelper>,\n            public EmptyFunction<Container>,\n            public FromContainerFunction<Container, TypeHelper>,\n            public IsArrayFunction {};\n\n        template<class StdArray, template<class...> class TypeHelper>\n        struct StdArrayTypeHelper :\n            public EmptyFunction<StdArray>,\n            public FromContainerFunction<StdArray, TypeHelper>,\n            public IsArrayFunction\n        {\n            static inline StdArray toType(const Value& value) {\n                ArrayWrapper<typename StdArray::value_type> arrayWrapper(value);\n                std::array<typename StdArray::value_type, std::tuple_size<StdArray>::value> arr;\n                Array jsonArray = arrayWrapper.getDoc().template Get<Array>();\n                Value::ConstValueIterator iterator = jsonArray.Begin();\n                for (typename StdArray::value_type& v : arr) {\n                    if (iterator == jsonArray.End())\n                        break;\n                    v = TypeHelper<typename StdArray::value_type>::toType(*iterator);\n                    ++iterator;\n                }\n                return arr;\n                //return toArray<typename StdArray::value_type, std::tuple_size<StdArray>::value>(value);\n            }\n        };\n\n        template<class SmartPtr, template<class...> class TypeHelper>\n        struct SmartPtrTypeHelper {\n            template<class Value>\n            static inline SmartPtr toType(Value& value) {\n                return SmartPtr{new typename SmartPtr::element_type{\n                    //copy object to pointer\n                    TypeHelper<typename SmartPtr::element_type>::toType(value)\n                }};\n            }\n            static inline Value fromType(const SmartPtr& value, Value::AllocatorType& allocator) {\n                return TypeHelper<typename SmartPtr::element_type>::fromType(*value, allocator);\n            }\n            static inline bool empty(const SmartPtr& value) {\n                return value == nullptr;\n            }\n            static inline bool isType(const Value& value) {\n                return TypeHelper<typename SmartPtr::element_type>::isType(value);\n            }\n        };\n\n        //almost the same as SmartPtr\n        //maybe find a way to marge the two\n        template<class Optional, template<class...> class TypeHelper>\n        struct OptionalTypeHelper {\n            static inline Optional toType(const Value& value) {\n                return Optional{ TypeHelper<typename Optional::value_type>::toType(value) };\n            }\n            static inline Value fromType(const Optional& value, Value::AllocatorType& allocator) {\n                return TypeHelper<typename Optional::value_type>::fromType(*value, allocator);\n            }\n            static inline bool empty(const Optional& value) {\n                return !value.has_value();\n            }\n            static inline bool isType(const Value& value) {\n                 return TypeHelper<typename Optional::value_type>::isType(value);\n            }\n        };\n\n        template<class Nullable, template<class...> class TypeHelper>\n        struct NullableTypeHelper {\n            static inline Nullable toType(const Value& value) {\n                if (value.IsNull()) {\n                    return Nullable{ tl::nullopt };\n                } else {\n                    return Nullable{ TypeHelper<typename Nullable::value_type>::toType(value) };\n                }\n            }\n            static inline Value fromType(const Nullable& value, Value::AllocatorType& allocator) {\n                if (value) {\n                    return Value{ rapidjson::kNullType };\n                } else {\n                    return TypeHelper<typename Nullable::value_type>::fromType(*value, allocator);\n                }\n            }\n            static inline bool empty(const Nullable& value) {\n                return !value.has_value();\n            }\n            static inline bool isType(const Value& value) {\n                return value.IsNull() || TypeHelper<typename Nullable::value_type>::isType(value);\n            }\n        };\n\n        enum FieldType {\n            REQUIRIED_FIELD = 0,\n            OPTIONAL_FIELD  = 1 << 0,\n            NULLABLE_FIELD  = 1 << 1,\n            OPTIONAL_NULLABLE_FIELD = OPTIONAL_FIELD | NULLABLE_FIELD\n        };\n\n        template <class Class, class Type, class TypeHelper>\n        struct PairImpl {\n            using T = Type;\n            using Helper = TypeHelper;\n            Type Class::*member;\n            const char* name;\n            const FieldType type;\n        };\n\n        template <int defaultValue, template<class, int> class TypeHelper = PrimitiveTypeHelper, class Class, class Type>\n        constexpr PairImpl<Class, Type, TypeHelper<Type, defaultValue>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type, defaultValue>>{member, name, type};\n        }\n\n        template <template<class> class TypeHelper = ClassTypeHelper, class Class, class Type>\n        constexpr PairImpl<Class, Type, TypeHelper<Type>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type>>{member, name, type};\n        }\n\n        template <template<class, template<class...> class> class TypeHelper, template<class...> class TypeHelper2 = ClassTypeHelper, class Class, class Type>\n        constexpr PairImpl<Class, Type, TypeHelper<Type, TypeHelper2>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, TypeHelper<Type, TypeHelper2>>{member, name, type};\n        }\n\n        //There needs to be a workaround for Visual C++ and clang for this to compile. However, this workaround relys on c++14.\n#if __cpp_return_type_deduction\n#define JSONStruct getJSONStructure()\n#define JSONStructStart constexpr static auto JSONStruct { return\n#define JSONStructEnd }\n#else\n#define JSONStruct JSONStructure\n#define JSONStructStart constexpr static auto JSONStruct =\n#define JSONStructEnd\n#endif\n\n        enum class FromJSONMode {\n            Default = 0,\n            ReturnOnError = 1\n        };\n\n        template<class Helper, class ResultingObject, class Value>\n        inline bool castValue(ResultingObject& result, Value& value) {\n            if (Helper::isType(value))\n                result = Helper::toType(value);\n            else\n                return false;\n            return true;\n        }\n\n        template<FromJSONMode mode = FromJSONMode::Default, class ResultingObject, class Value, size_t i = 0>\n        inline typename std::enable_if<i == std::tuple_size<decltype(ResultingObject::JSONStruct)>::value, bool>::type\n            fromJSON(ResultingObject&, Value&)\n        {\n            return true;\n        }\n\n        template<FromJSONMode mode = FromJSONMode::Default, class ResultingObject, class Value, size_t i = 0>\n        inline typename std::enable_if<i < std::tuple_size<decltype(ResultingObject::JSONStruct)>::value, bool>::type\n            fromJSON(ResultingObject& object, Value& value)\n        {\n            constexpr auto field = std::get<i>(ResultingObject::JSONStruct);\n            using Helper = typename decltype(field)::Helper;\n            auto iterator = value.FindMember(field.name);\n            if (iterator != value.MemberEnd()) {\n                if (castValue<Helper>(object.*(field.member), iterator->value)) {\n                    //success\n                } else if (field.type != REQUIRIED_FIELD && iterator->value.IsNull()) {\n                    //ignore\n                } else /*error*/ if (mode == FromJSONMode::ReturnOnError) {\n                    return false;\n                }\n            } else if (field.type == REQUIRIED_FIELD) {\n                //error\n                std::cout << \n                "JSON Parse Error: "\n                "variable #" << i << ": \\"" << field.name << "\\" not found. "\n                "Please look at call stack from your debugger for more details.";\n                if (mode == FromJSONMode::ReturnOnError)\n                    return false;\n            }\n            return fromJSON<mode, ResultingObject, Value, i + 1>(object, value);\n        }\n\n        template<class ResultingObject, class Value>\n        inline ResultingObject fromJSON(Value& value) {\n            ResultingObject object;\n            fromJSON(object, value);\n            return object;\n        }\n\n        template<class ResultingObject>\n        inline rapidjson::ParseResult fromJSON(ResultingObject& obj, const nonstd::string_view& json) {\n            rapidjson::Document doc;\n            rapidjson::ParseResult isOK = doc.Parse(json.data(), json.length());\n            if (isOK)\n                obj = ResultingObject{doc};\n            return isOK;\n        }\n\n        inline rapidjson::Document parse(const nonstd::string_view& json) {\n            rapidjson::Document doc;\n            doc.Parse(json.data(), json.length());\n            return doc;\n        }\n\n        template<class ResultingObject>\n        inline ResultingObject fromJSON(const nonstd::string_view& json) {\n            rapidjson::Document doc = parse(json);\n            //note: some objects have different value consturctors\n            //so we need to call the Object\'s value constructor\n            return ResultingObject(doc);\n        }\n\n        constexpr std::size_t stringLength(const char*const& string, std::size_t i = 0) {\n            return string[i] == \'\\0\' ? i : stringLength(string, i + 1);\n        }\n\n        template<class SourceObject, size_t i = 0>\n        inline typename std::enable_if<i == std::tuple_size<decltype(SourceObject::JSONStruct)>::value, void>::type\n            toJSON(const SourceObject& /*object*/, Value& /*value*/, Value::AllocatorType& /*allocator*/) {\n        }\n\n        template<class SourceObject, size_t i = 0>\n        inline typename std::enable_if < i < std::tuple_size<decltype(SourceObject::JSONStruct)>::value, void>::type\n            toJSON(const SourceObject& object, Value& value, Value::AllocatorType& allocator) {\n            constexpr auto field = std::get<i>(SourceObject::JSONStruct);\n            using Helper = typename decltype(field)::Helper;\n            //value[field.name] = object.*(field.member);\n            if (!(field.type & OPTIONAL_NULLABLE_FIELD) || !Helper::empty(object.*(field.member))) {\n                constexpr std::size_t nameLength = stringLength(field.name);\n                value.AddMember(\n                    Value::StringRefType(field.name, nameLength),\n                    Helper::fromType(object.*(field.member), allocator),\n                    allocator\n                );\n            }\n            toJSON<SourceObject, i + 1>(object, value, allocator);\n        }\n\n        template<class Object>\n        inline Value toJSON(const Object& object, Value::AllocatorType& allocator) {\n            Value obj(rapidjson::kObjectType);\n            toJSON(object, obj, allocator);\n            return obj;\n        }\n\n        template<class Object>\n        inline rapidjson::Document toJSON(const Object& object) {\n            rapidjson::Document doc;\n            doc.SetObject();\n            toJSON(object, doc, doc.GetAllocator());\n            return doc;\n        }\n\n        inline std::string stringify(const Value& value) {\n            rapidjson::StringBuffer buffer;\n            rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);\n            value.Accept(writer);\n            return std::string(buffer.GetString(), buffer.GetSize());\n        }\n\n        template<class Object>\n        inline std::string stringifyObj(const Object& object) {\n            rapidjson::MemoryPoolAllocator<> allocator;\n            return stringify(toJSON(object, allocator));\n        }\n\n        template<class Object, size_t i = 0>\n        inline typename std::enable_if<i == std::tuple_size<decltype(Object::JSONStruct)>::value, void>::type\n            mergeObj(Object& object, const Object& objectChanges) {\n        }\n\n        template<class Object, size_t i = 0>\n        inline typename std::enable_if < i < std::tuple_size<decltype(Object::JSONStruct)>::value, void>::type\n            mergeObj(Object& object, const Object& objectChanges) {\n            constexpr auto field = std::get<i>(Object::JSONStruct);\n            using Helper = typename decltype(field)::Helper;\n            if (!Helper::empty(objectChanges.*(field.member))) {\n                object.*(field.member) = objectChanges.*(field.member);\n            }\n            mergeObj<Object, i + 1>(object, objectChanges);\n        }\n\n        inline json::Value copy(const json::Value& value) {\n            rapidjson::Document doc;\n            return std::move(doc.CopyFrom(value, doc.GetAllocator()));\n        }\n\n        //json optional and null emulation\n        struct UndefinedType {};\n\n        template<class Type>\n        struct Maybe {\n            using FlagType = bool;\n            static constexpr FlagType undefined = 0;\n            static constexpr FlagType defined = 1;\n\n            using ValueType = Type;\n            using element_type = Type;\n            using Container = std::shared_ptr<Type>;\n            using weak_ptr = typename Container::weak_ptr;\n\n            const bool isUndefined() const {\n                return ( flags & defined ) == undefined;\n            }\n            const bool isDefined() const {\n                return !isUndefined();\n            }\n            const bool isAvaiable() const {\n                return isDefined() && static_cast<bool>(value);\n            }\n            const bool isNull() const {\n                return isDefined() && !static_cast<bool>(value);\n            }\n             \n            Type copy(Type& defaultValue) const {\n                return isDefined() ? static_cast<bool>(value) ? *get() : defaultValue : defaultValue;\n            }\n            \n            void copyTo(Type& dest) const {\n                if (isAvaiable())\n                    dest = *get();\n            }\n\n            constexpr Maybe() = default;\n            constexpr Maybe(std::nullptr_t) noexcept : value(std::nullptr_t{}), flags(defined) {};\n            Maybe& operator=(std::nullptr_t) noexcept {\n                value = std::nullptr_t{};\n                flags |= defined;\n            }\n            constexpr Maybe(UndefinedType) {};\n            template<class TypeY>\n            explicit Maybe(TypeY* ptr) noexcept : value(ptr), flags(defined) {}\n            template<class TypeY, class Deleter>\n            Maybe(Type* ptr, Deleter deleter) noexcept :\n                value(ptr, deleter), flags(defined) {}\n            template<class TypeY, class Deleter, class Alloc>\n            Maybe(Type* ptr, Deleter deleter, Alloc allocator) noexcept :\n                value(ptr, deleter, allocator), flags(defined) {}\n            template<class Deleter>\n            Maybe(std::nullptr_t, Deleter deleter) : value(nullptr, deleter), flags(defined) {}\n            template<class Deleter, class Alloc>\n            Maybe(std::nullptr_t, Deleter deleter, Alloc allocator) noexcept :\n                value(nullptr, deleter, allocator), flags(defined) {}\n            template<class Deleter>\n            Maybe(UndefinedType, Deleter deleter) : value(nullptr, deleter) {}\n            template<class Deleter, class Alloc>\n            Maybe(UndefinedType, Deleter deleter, Alloc allocator) noexcept :\n                value(nullptr, deleter, allocator) {}\n            template<class Type2>\n            Maybe(const Maybe<Type2>& right, ValueType* pointer) noexcept :\n                value(right.value, pointer), flags(defined) {}\n            template<class Type2>\n            Maybe(const Maybe<Type2>&& right, ValueType* pointer) noexcept :\n                value(std::move(right.value), pointer), flags(defined) {}\n            Maybe(const Maybe& other) noexcept : value(other), flags(other.flags) {}\n            explicit Maybe(Container&& right) noexcept :\n                value(std::move(right)), flags(defined) {}\n            Maybe(Maybe&& right) noexcept :\n                value(std::move(right.value)), flags(right.flags) {}\n            template<class Type2>\n            Maybe(Maybe<Type2>&& right) noexcept :\n                value(std::move(right.value)), flags(right.value) {}\n            template<class Type2>\n            explicit Maybe(std::shared_ptr<Type2>&& right) noexcept :\n                value(std::move(right)), flags(defined) {}\n            template<class Type2>\n            explicit Maybe(const weak_ptr& other) :\n                value(other), flags(defined) {}\n            template<class Type2, class Deleter>\n            Maybe(std::unique_ptr<Type2, Deleter>&& other) :\n                value(std::move(other)), flags(defined) {}\n            \n\n            Maybe& operator=(const Maybe& right) noexcept {\n                Maybe(right).swap(*this);\n                return *this;\n            }\n\n            template<class Type2>\n            Maybe& operator=(const Maybe<Type2>& right) noexcept {\n                Maybe(right).swap(*this);\n                return *this;\n            }\n\n            Maybe& operator=(Maybe&& right) noexcept {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            template<class Type2>\n            Maybe& operator=(Maybe<Type2>&& right) noexcept {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            template<class TypeX, class Deleter>\n            Maybe& operator=(std::unique_ptr<TypeX, Deleter>&& right) {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            Maybe& operator=(const Container& right) noexcept {\n                Maybe(right).swap(*this);\n                return *this;\n            }\n\n            Maybe& operator=(Container&& right) noexcept {\n                Maybe(std::move(right)).swap(*this);\n                return *this;\n            }\n\n            void swap(Maybe& right) noexcept {\n                value.swap(right.value);\n                std::swap(flags, right.flags);\n            }\n\n            ValueType& operator*() const noexcept {\n                return *value;\n            }\n\n            ValueType* operator->() const noexcept {\n                return value.operator->();\n            }\n\n            ValueType* get() const noexcept {\n                return value.get();\n            }\n\n            explicit operator bool() const noexcept {\n                return isAvaiable();\n            }\n\n            bool empty() const noexcept {\n                return isAvaiable();\n            }\n\n            ValueType* release() noexcept {\n                flags = undefined;\n                return value.release();\n            }\n\n            void reset() noexcept {\n                value.reset();\n            }\n\n            template<class TypeX>\n            void reset(ValueType* ptr) noexcept {\n                value.reset(ptr);\n            }\n\n            template<class TypeX, class Deleter>\n            void reset(ValueType* ptr, Deleter deleter) noexcept {\n                value.reset(ptr, deleter);\n            }\n\n            template<class TypeX, class Deleter, class Alloc>\n            void reset(ValueType* ptr, Deleter deleter, Alloc allocator) noexcept {\n                value.reset(ptr, deleter, allocator);\n            }\n\n            long use_count() const noexcept {\n                return value.use_count();\n            }\n\n            void setToUndefined() noexcept {\n                reset();\n                flags = undefined;\n            }\n\n            Container& getSmartPtr() const noexcept {\n                return value;\n            }\n\n        private:\n            Container value;\n            FlagType flags = undefined;\n        };\n\n        template<class MaybeType, template<class...> class TypeHelper>\n        struct MaybeTypeHelper : public EmptyFunction<MaybeType> {\n            static inline MaybeType toType(const Value& value) {\n                return TypeHelper<typename MaybeType::element_type>::toType(value);\n            }\n            static inline Value fromType(const MaybeType& value, Value::AllocatorType& allocator) {\n                return TypeHelper<typename MaybeType::element_type>::fromType(*value, allocator);\n            }\n        };\n\n        template <template<class...> class TypeHelper2 = ClassTypeHelper, class Class, class Type,\n            typename std::enable_if<\n                std::is_same<\n                    Type, Maybe<typename Type::ValueType>\n                >::value\n            >::type = true\n        >\n        constexpr PairImpl<Class, Type, MaybeTypeHelper<Type, TypeHelper2>> pair(Type Class::*member, const char* name, FieldType type) {\n            return PairImpl<Class, Type, MaybeTypeHelper<Type, TypeHelper2>>{member, name, type};\n        }       \n    }\n}\n')),Object(l.b)("hr",null),Object(l.b)("p",null,"Updated on  2 July 2021 at 03:30:35 UTC"))}i.isMDXComponent=!0},383:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=r.a.createContext({}),i=function(e){var t=r.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=i(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=i(n),d=a,m=u["".concat(s,".").concat(d)]||u[d]||b[d]||l;return n?r.a.createElement(m,c(c({ref:t},p),{},{components:n})):r.a.createElement(m,c({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,s=new Array(l);s[0]=d;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,s[1]=c;for(var p=2;p<l;p++)s[p]=n[p];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);