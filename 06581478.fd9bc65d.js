(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{307:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return p}));var r=t(0),s=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var d=s.a.createContext({}),l=function(e){var n=s.a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return s.a.createElement(d.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return s.a.createElement(s.a.Fragment,{},n)}},m=s.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=l(t),m=r,p=u["".concat(i,".").concat(m)]||u[m]||h[m]||a;return t?s.a.createElement(p,o(o({ref:n},d),{},{components:t})):s.a.createElement(p,o({ref:n},d))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=m;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<a;d++)i[d]=t[d];return s.a.createElement.apply(null,i)}return s.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},77:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return o})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return l}));var r=t(3),s=t(7),a=(t(0),t(307)),i={title:"sleepy_discord/client.cpp"},o={unversionedId:"reference/Files/client_8cpp",id:"reference/Files/client_8cpp",isDocsHomePage:!1,title:"sleepy_discord/client.cpp",description:"Namespaces",source:"@site/docs/reference/Files/client_8cpp.md",slug:"/reference/Files/client_8cpp",permalink:"/sleepy-discord/docs/reference/Files/client_8cpp",version:"current",sidebar:"Reference",previous:{title:"include/sleepy_discord/channel.h",permalink:"/sleepy-discord/docs/reference/Files/channel_8h"},next:{title:"include/sleepy_discord/client.h",permalink:"/sleepy-discord/docs/reference/Files/client_8h"}},c=[{value:"Namespaces",id:"namespaces",children:[]},{value:"Functions",id:"functions",children:[]},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function hash",id:"function-hash",children:[]}]},{value:"Source code",id:"source-code",children:[]}],d={toc:c};function l(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"namespaces"},"Namespaces"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",{parentName:"tr",align:null},"Name"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),Object(a.b)("h2",{id:"functions"},"Functions"),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",{parentName:"tr",align:null}),Object(a.b)("th",{parentName:"tr",align:null},"Name"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",{parentName:"tr",align:null},"constexpr unsigned int"),Object(a.b)("td",{parentName:"tr",align:null},Object(a.b)("strong",{parentName:"td"},Object(a.b)("a",{parentName:"strong",href:"/docs/reference/Files/client_8cpp#function-hash"},"hash")),"(const char * key, unsigned int i =0)")))),Object(a.b)("h2",{id:"functions-documentation"},"Functions Documentation"),Object(a.b)("h3",{id:"function-hash"},"function hash"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-cpp"},"constexpr unsigned int hash(\n    const char * key,\n    unsigned int i =0\n)\n")),Object(a.b)("h2",{id:"source-code"},"Source code"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-cpp"},'#if _MSC_VER && !__INTEL_COMPILER\n#pragma warning( disable: 4307 )  //ignore integer overflow, becuase we are taking advantage of it\n#endif\n\n#include <chrono>\n#include <functional>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <cstring>\n#include "client.h"\n#include "version_helper.h"\n//#include "json.h"\n#include "rapidjson/document.h"\n#ifdef SLEEPY_USE_HARD_CODED_GATEWAY\n    #include <cstring>\n#endif\n\nnamespace SleepyDiscord {\n    void BaseDiscordClient::start(const std::string _token, const char maxNumOfThreads, int _shardID, int _shardCount) {\n        if (!scheduleHandler) {\n            setError(CANT_SCHEDULE);\n            return;\n        }\n        \n        ready = false;\n        quiting = false;\n        bot = true;\n        token = std::unique_ptr<std::string>(new std::string(_token)); //add client to list\n        if (_shardID != 0 || _shardCount != 0)\n            setShardID(_shardID, _shardCount);\n\n        messagesRemaining = 4;\n        getTheGateway();\n        connect(theGateway, this, connection);\n#ifndef SLEEPY_ONE_THREAD\n        if (USE_RUN_THREAD <= maxNumOfThreads) runAsync();\n#endif\n    }\n\n    BaseDiscordClient::~BaseDiscordClient() {\n        ready = false;\n        if (heart.isValid()) heart.stop();\n    }\n\n    void RateLimiter::limitBucket(Route::Bucket& bucket, time_t timestamp) {\n        std::lock_guard<std::mutex> lock(mutex);\n        buckets[bucket] = timestamp;\n    }\n\n    const time_t RateLimiter::getLiftTime(Route::Bucket& bucket, const time_t& currentTime) {\n        if (isGlobalRateLimited && currentTime < nextRetry)\n                return nextRetry;\n        isGlobalRateLimited = false;\n        std::lock_guard<std::mutex> lock(mutex);\n        auto bucketResetTimestamp = buckets.find(bucket);\n        if (bucketResetTimestamp != buckets.end()) {\n            if (currentTime < bucketResetTimestamp->second)\n                return bucketResetTimestamp->second;\n            buckets.erase(bucketResetTimestamp);\n        }\n        return 0;\n    }\n\n    Response BaseDiscordClient::request(const RequestMethod method, Route path, const std::string jsonParameters,\n        const std::vector<Part>& multipartParameters, RequestCallback callback, const RequestMode mode\n    ) {\n        //check if rate limited\n        Response response;\n        const time_t currentTime = getEpochTimeMillisecond();\n        response.birth = currentTime;\n        Route::Bucket bucket = path.bucket(method);\n        time_t nextTry = rateLimiter.getLiftTime(bucket, currentTime);\n        if (0 < nextTry) {\n            onExceededRateLimit(\n                rateLimiter.isGlobalRateLimited, nextTry - currentTime,\n                { *this, method, path, jsonParameters, multipartParameters, callback, mode }\n            );\n            response.statusCode = TOO_MANY_REQUESTS;\n            setError(response.statusCode);\n            return response;\n        }\n        {   //the { is used so that onResponse is called after session is removed to make debugging performance issues easier\n            //request starts here\n            Session session;\n            session.setUrl("https://discord.com/api/v6/" + path.url());\n            std::vector<HeaderPair> header = {\n                { "Authorization", bot ? "Bot " + getToken() : getToken() },\n                { "User-Agent", userAgent },\n            };\n            if (jsonParameters != "") {\n                session.setBody(&jsonParameters);\n                header.push_back({ "Content-Type"  , "application/json"                      });\n                header.push_back({ "Content-Length", std::to_string(jsonParameters.length()) });\n            } else if (0 < multipartParameters.size()) {\n                session.setMultipart(multipartParameters);\n                header.push_back({ "Content-Type", "multipart/form-data" });\n            } else {\n                header.push_back({ "Content-Length", "0" });\n            }\n            session.setHeader(header);\n\n            //Do the response\n            switch (method) {\n            case Post: case Patch: case Delete: case Get: case Put:\n                response = session.request(method);\n                break;\n            default: response.statusCode = BAD_REQUEST; break; //unexpected method\n            }\n\n            //status checking\n            switch (response.statusCode) {\n            case OK: case CREATED: case NO_CONTENT: case NOT_MODIFIED: break;\n            case TOO_MANY_REQUESTS:\n                {   //this should fall down to default\n                    std::string rawRetryAfter = response.header["Retry-After"];\n                    //the 5 is an arbitrary number, and there\'s 1000 ms in a second\n                    int retryAfter = rawRetryAfter != "" ? std::stoi(rawRetryAfter) : 5 * 1000;\n                    rateLimiter.isGlobalRateLimited = response.header.find("X-RateLimit-Global") != response.header.end();\n                    rateLimiter.nextRetry = getEpochTimeMillisecond() + retryAfter;\n                    if (!rateLimiter.isGlobalRateLimited) {\n                        rateLimiter.limitBucket(bucket, rateLimiter.nextRetry);\n                        onDepletedRequestSupply(bucket, retryAfter);\n                    }\n                    onExceededRateLimit(\n                        rateLimiter.isGlobalRateLimited, retryAfter,\n                        { *this, method, path, jsonParameters, multipartParameters, callback, mode }\n                    );\n                }\n            default:\n                {       //error\n                    const ErrorCode code = static_cast<ErrorCode>(response.statusCode);\n                    setError(code);     //https error\n                    if (!response.text.empty()) {\n                    //json::Values values = json::getValues(response.text.c_str(),\n                    //{ "code", "message" });   //parse json to get code and message\n                    rapidjson::Document document;\n                    document.Parse(response.text.c_str());\n                        if (!document.IsObject()) {\n                            onError(GENERAL_ERROR, "No error code or message from Discord");\n                        }\n\n                    auto errorCode = document.FindMember("code");\n                    auto errorMessage = document.FindMember("message");\n                    if (errorCode != document.MemberEnd())\n                        onError(\n                            static_cast<ErrorCode>(errorCode->value.GetInt()),\n                            { errorMessage != document.MemberEnd() ? errorMessage->value.GetString() : "" }\n                    );\n                    else if (!response.text.empty())\n                        onError(ERROR_NOTE, response.text);\n#if defined(__cpp_exceptions) || defined(__EXCEPTIONS)\n                        if (static_cast<int>(mode) & static_cast<int>(ThrowError))\n                            throw code;\n#endif\n                    }\n                } break;\n            }\n\n            //rate limit check\n            if (response.header["X-RateLimit-Remaining"] == "0" && response.statusCode != TOO_MANY_REQUESTS) {\n                std::tm date = {};\n                //for some reason std::get_time requires gcc 5\n                std::istringstream dateStream(response.header["Date"]);\n                dateStream >> std::get_time(&date, "%a, %d %b %Y %H:%M:%S GMT");\n                const time_t reset = std::stoi(response.header["X-RateLimit-Reset"]);\n#if defined(_WIN32) || defined(_WIN64)\n                std::tm gmTM;\n                std::tm*const resetGM = &gmTM;\n                gmtime_s(resetGM, &reset);\n#else\n                std::tm* resetGM = std::gmtime(&reset);\n#endif\n                const time_t resetDelta = (std::mktime(resetGM) - std::mktime(&date)) * 1000;\n                rateLimiter.limitBucket(bucket, resetDelta + getEpochTimeMillisecond());\n                onDepletedRequestSupply(bucket, resetDelta);\n            }\n\n            if (callback)\n                callback(response);\n        }\n        onResponse(response);\n        return response;\n    }\n\n    const Route BaseDiscordClient::path(const char * source, std::initializer_list<std::string> values) {\n        return Route(source, values);\n    }\n\n    std::shared_ptr<ServerCache> BaseDiscordClient::createServerCache() {\n        setServerCache(std::make_shared<ServerCache>());\n        return getServerCache();\n    }\n\n    void BaseDiscordClient::setServerCache(std::shared_ptr<ServerCache> cache) {\n        serverCache = cache;\n        if ((ready || !isBot()) && serverCache->size() == 0)\n            *serverCache = getServers().get<Cache>();\n    }\n\n    void BaseDiscordClient::onDepletedRequestSupply(const Route::Bucket&, time_t) {\n    }\n\n    void BaseDiscordClient::onExceededRateLimit(bool, std::time_t timeTilRetry, Request request) {\n        if (static_cast<int>(request.mode) & static_cast<int>(AsyncQueue)) {\n            //since we are scheduling the request, I think we should make it async\n            request.mode = Async;\n            schedule(request, timeTilRetry);\n        }\n    }\n\n    void BaseDiscordClient::updateStatus(std::string gameName, uint64_t idleSince, Status status, bool afk) {\n        std::string statusString[] = {\n            "", "online", "dnd", "idle", "invisible", "offline"\n        };\n\n        sendL(json::createJSON({\n            { "op", json::integer(STATUS_UPDATE) },\n            { "d", json::createJSON({\n                {"since", idleSince != 0 ? json::UInteger(idleSince) : "null"},\n                {"game", gameName != "" ? json::createJSON({\n                    {"name", json::string(gameName)},\n                    {"type", json::integer(0)}\n                }) : "null"},\n                { "status", SleepyDiscord::json::string(statusString[status]) },\n                { "afk", SleepyDiscord::json::boolean(afk) }\n            })}\n        }));\n    }\n\n    void BaseDiscordClient::waitTilReady() {\n        while (!ready) sleep(1000);\n    }\n\n    void BaseDiscordClient::setShardID(int _shardID, int _shardCount) {\n        shardID = _shardID;\n        shardCount = _shardCount;\n    }\n\n    void BaseDiscordClient::getTheGateway() {\n#ifdef SLEEPY_USE_HARD_CODED_GATEWAY\n        theGateway = "wss://gateway.discord.gg/?v=6";   //This is needed for when session is disabled\n#else\n        Session session;\n        session.setUrl("https://discordapp.com/api/gateway");\n        Response a = session.request(Get);  //todo change this back to a post\n        if (!a.text.length()) { //error check\n            quit(false, true);\n            return setError(GATEWAY_FAILED);\n        }\n        if (!theGateway.empty())\n            theGateway.clear();\n        //getting the gateway\n        for (unsigned int position = 0, j = 0; ; ++position) {\n            if (a.text[position] == \'"\')\n                ++j;\n            else if (j == 3) {\n                const unsigned int start = position;\n                while (a.text[++position] != \'"\');\n                unsigned int size = position - start;\n                theGateway.reserve(32);\n                theGateway.append(a.text, start, size);\n                theGateway += "/?v=6";\n                break;\n            }\n        }\n#endif\n    }\n\n    void BaseDiscordClient::sendIdentity() {\n        //{\n        //  "op":2,\n        //   "d":{\n        //      "token":my_token,\n        //      "properties":{\n        //          $os":"windows 10",\n        //          "$browser":"Sleepy_Discord",\n        //          "$device":"Sleepy_Discord",\n        //          "$referrer":"",         //I don\'t know what this does\n        //          "$referring_domain":""      //I don\'t know what this does\n        //      },\n        //      "compress":false,\n        //      "large_threshold":250           /I don\'t know what this does\n        //  }\n        //}\n#if defined(_WIN32) || defined(_WIN64)\n        const char * os = "Windows";\n#elif defined(__APPLE__) || defined(__MACH__)\n        const char * os = "macOS";\n#elif defined(__linux__) || defined(linux) || defined(__linux)\n        const char * os = "Linux";\n#elif defined __FreeBSD__\n        const char * os = "FreeBSD";\n#elif defined(unix) || defined(__unix__) || defined(__unix)\n        const char * os = "Unix";\n#else\n        const char* os = "\\\\u00AF\\\\\\\\_(\\\\u30C4)_\\\\/\\\\u00AF";  //shrug I dunno\n#endif\n        std::string identity;\n        identity.reserve(272); //remember to change this number when editing identity\n        identity += \n        "{"\n            "\\"op\\":2,"\n            "\\"d\\":{"\n                "\\"token\\":\\""; identity += getToken(); identity += "\\","\n                "\\"properties\\":{"\n                    "\\"$os\\":\\""; identity += os; identity += "\\","\n                    "\\"$browser\\":\\"Sleepy_Discord\\","\n                    "\\"$device\\":\\"Sleepy_Discord\\","\n                    "\\"$referrer\\":\\"\\","\n                    "\\"$referring_domain\\":\\"\\""\n                "},"\n                "\\"compress\\":false,";\n        if (shardCount != 0 && shardID <= shardCount) {\n            identity +=\n                "\\"shard\\":[";\n            identity += \n                    std::to_string(shardID); identity += ",";\n            identity +=\n                    std::to_string(shardCount);\n            identity +=\n                "],";\n        }\n        if (hasIntents()) {\n            identity +=\n                "\\"intents\\":";\n            identity +=\n                std::to_string(intents);\n        identity +=\n                \',\';\n        }\n        identity +=\n                "\\"large_threshold\\":250"\n            "}"\n        "}";\n        sendL(identity);\n    }\n\n    void BaseDiscordClient::sendResume() {\n        std::string resume;\n        resume.reserve(208);\n        resume +=\n        "{"\n            "\\"op\\":6,"\n            "\\"d\\":{"\n                "\\"token\\":\\""; resume += getToken(); resume += "\\","\n                "\\"session_id\\":\\""; resume += sessionID; resume += "\\","\n                "\\"seq\\":"; resume += std::to_string(lastSReceived); resume +=\n            "}"\n        "}";\n        sendL(resume);\n        onResume();\n    }\n\n    void BaseDiscordClient::quit(bool isRestarting, bool isDisconnected) {\n        if (!isRestarting)\n            quiting = true;\n\n#ifdef SLEEPY_VOICE_ENABLED\n        //quit all voice connections\n        for (VoiceConnection& voiceConnection : voiceConnections)\n            voiceConnection.disconnect();\n#endif\n        if (heart.isValid()) heart.stop(); //stop heartbeating\n        if (!isDisconnected) disconnectWebsocket(1000);\n        stopClient();\n        if (quiting) onQuit();\n    }\n\n    void BaseDiscordClient::restart() {\n        quit(true);\n        connect(theGateway, this, connection);\n        onRestart();\n    }\n\n    void BaseDiscordClient::reconnect(const unsigned int status) {\n        if (status != 1000) {         //check for a deliberate reconnect\n            heartbeatInterval = 0;    //stop heartbeating\n            wasHeartbeatAcked = true; //stops the library from spamming discord\n        }\n        disconnectWebsocket(status);\n        if (consecutiveReconnectsCount == 10) getTheGateway();\n        if (reconnectTimer.isValid())\n            reconnectTimer.stop();\n        reconnectTimer = schedule([this]() {\n            connect(theGateway, this, connection);\n        }, getRetryDelay());\n        ++consecutiveReconnectsCount;\n\n        for (VoiceConnection& voiceConnection : voiceConnections) {\n            disconnect(1001, "", voiceConnection.connection);\n    }\n    }\n\n    void BaseDiscordClient::disconnectWebsocket(unsigned int code, const std::string reason) {\n        disconnect(code, reason, connection);\n        onDisconnect();\n    }\n\n    bool BaseDiscordClient::sendL(std::string message) {\n        if (nextHalfMin <= getEpochTimeMillisecond()) {\n            const unsigned int maxMessagesPerMin = 116;\n            const unsigned int halfMinMilliseconds = 30000;\n            const unsigned int maxMessagesPerHalfMin = maxMessagesPerMin / 2;\n\n            nextHalfMin += halfMinMilliseconds;\n            messagesRemaining = maxMessagesPerHalfMin;\n        }\n\n        if (--messagesRemaining < 0) {\n            messagesRemaining = 0;\n            setError(RATE_LIMITED);\n            return false;\n        }\n        send(message, connection);\n        return true;\n    }\n\n    constexpr unsigned int hash(const char* key, unsigned int i = 0) {\n        return !key[i] ? 0 : (hash(key, i + 1) * 31) + key[i] - \'A\';\n    }\n\n    void BaseDiscordClient::processMessage(const std::string &message) {\n        rapidjson::Document document;\n        document.Parse(message.c_str(), message.length());\n        //json::Values values = json::getValues(message.c_str(),\n        //  { "op", "d", "s", "t" });\n        int op = document["op"].GetInt();\n        const json::Value& t = document["t"];\n        //const nonstd::string_view t(tValue.GetString(), tValue.GetStringLength);\n        const json::Value& d = document["d"];\n        switch (op) {\n        case DISPATCH:\n            lastSReceived = document["s"].GetInt();\n            consecutiveReconnectsCount = 0; //Successfully connected\n            switch (hash(json::toStdString(t).c_str())) {\n            case hash("READY"                      ): {\n                Ready readyData = d;\n                sessionID = readyData.sessionID;\n                bot = readyData.user.bot;\n                userID = readyData.user;\n                onReady(readyData);\n                ready = true;\n                } break;\n            case hash("RESUMED"                    ): onResumed            (); break;\n            case hash("GUILD_CREATE"               ): {\n                Server server(d);\n                if (serverCache)\n                    serverCache->insert(server);\n                onServer(server);\n                } break;\n            case hash("GUILD_DELETE"               ): {\n                UnavailableServer server(d);\n                if (serverCache) {\n                    findServerInCache(server.ID, [=](ServerCache::iterator& found) {\n                        serverCache->erase(found);\n                    });\n                }\n                onDeleteServer(server);\n                } break;\n            case hash("GUILD_UPDATE"               ): {\n                Server server(d);\n                accessServerFromCache(server.ID, [server](Server& foundServer) {\n                    foundServer = server;\n                });\n                onEditServer(server);\n                } break;\n            case hash("GUILD_BAN_ADD"              ): onBan  (d["guild_id"], d["user"]); break;\n            case hash("GUILD_BAN_REMOVE"           ): onUnban(d["guild_id"], d["user"]); break;\n            case hash("GUILD_INTEGRATIONS_UPDATE"  ):                          break; //to do add this\n            case hash("GUILD_MEMBER_ADD"           ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                ServerMember member(d);\n                appendObjectToCache(serverID, &Server::members, member);\n                onMember(serverID, member);\n                } break;\n            case hash("GUILD_MEMBER_REMOVE"        ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                User user = d["user"];\n                eraseObjectFromCache(serverID, &Server::members, user.ID);\n                onRemoveMember(serverID, user);\n                } break;\n            case hash("GUILD_MEMBER_UPDATE"        ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                User user = d["user"];\n                std::vector<Snowflake<Role>> roles = json::toArray<Snowflake<Role>>(d["roles"]);\n                auto nickValue = d.FindMember("nick");\n                std::string nick = nickValue != d.MemberEnd() && nickValue->value.IsString() ?\n                    json::toStdString(nickValue->value) : "";\n                accessObjectFromCache(serverID, &Server::members, user.ID,\n                    [user, roles, nick](Server&, ServerMember& member) {\n                        member.user = user;\n                        member.roles = roles;\n                        member.nick = nick;\n                    }\n                );\n                onEditMember(serverID, user, roles, nick);\n                } break;\n            case hash("GUILD_MEMBERS_CHUNK"        ): onMemberChunk       (d["guild_id"], json::toArray<ServerMember>(d["members"])); break;\n            case hash("GUILD_ROLE_CREATE"          ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                Role role = d["role"];\n                appendObjectToCache(serverID, &Server::roles, role);\n                onRole(serverID, role);\n                } break;\n            case hash("GUILD_ROLE_UPDATE"):\n            {\n                Snowflake<Server> serverID = d["guild_id"];\n                Role role = d["role"];\n                accessObjectFromCache(serverID, &Server::roles, role.ID,\n                    [role](Server&, Role& foundRole) {\n                        foundRole = role;\n                    }\n                );\n                onEditRole(serverID, role);\n            } break;\n            case hash("GUILD_ROLE_DELETE"          ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                Snowflake<Role> roleID = d["role_id"];\n                eraseObjectFromCache(serverID, &Server::roles, roleID);\n                onDeleteRole(serverID, roleID);\n                } break;\n            case hash("GUILD_EMOJIS_UPDATE"        ): onEditEmojis        (d["guild_id"], json::toArray<Emoji>(d["emojis"])); break;\n            case hash("CHANNEL_CREATE"             ): {\n                Channel channel = d;\n                appendObjectToCache(channel.serverID, &Server::channels, channel);\n                onChannel(d);\n                } break;\n            case hash("CHANNEL_UPDATE"             ): {\n                Channel channel = d;\n                accessObjectFromCache(channel.serverID, &Server::channels, channel.ID,\n                    [channel](Server&, Channel& foundChannel) {\n                        foundChannel = channel;\n                    }\n                );\n                onEditChannel(d); \n                } break;\n            case hash("CHANNEL_DELETE"             ): {\n                Channel channel = d;\n                eraseObjectFromCache(channel.serverID, &Server::channels, channel.ID);\n                onDeleteChannel(d);\n                } break;\n            case hash("CHANNEL_PINS_UPDATE"): {\n                const json::Value& lastPinTimeValue = d["last_pin_timestamp"];\n                onPinMessage(\n                    d["channel_id"],\n                    lastPinTimeValue.IsString() ?\n                    json::toStdString(d["last_pin_timestamp"]) : ""\n                );\n            } break;\n            case hash("PRESENCE_UPDATE"            ): onPresenceUpdate    (d); break;\n            case hash("PRESENCES_REPLACE"          ):                          break;\n            case hash("USER_UPDATE"                ): onEditUser          (d); break;\n            case hash("USER_NOTE_UPDATE"           ): onEditUserNote      (d); break;\n            case hash("USER_SETTINGS_UPDATE"       ): onEditUserSettings  (d); break;\n            case hash("VOICE_STATE_UPDATE"         ): {\n                VoiceState state(d);\n#ifdef SLEEPY_VOICE_ENABLED\n                if (!waitingVoiceContexts.empty()) {\n                    auto iterator = find_if(waitingVoiceContexts.begin(), waitingVoiceContexts.end(),\n                        [&state](const VoiceContext* w) { \n                        return state.channelID == w->channelID && w->sessionID == "";\n                    });\n                    if (iterator != waitingVoiceContexts.end()) {\n                        VoiceContext& context = **iterator;\n                        context.sessionID = state.sessionID;\n                        connectToVoiceIfReady(context);\n                    }\n                }\n#endif\n                onEditVoiceState(state);\n                } break;\n            case hash("TYPING_START"               ): onTyping            (d["channel_id"], d["user_id"], d["timestamp"].GetInt64() * 1000); break;\n            case hash("MESSAGE_CREATE"             ): onMessage           (d); break;\n            case hash("MESSAGE_UPDATE"             ): onEditMessage       (d); break;\n            case hash("MESSAGE_DELETE"             ): onDeleteMessages    (d["channel_id"], { d["id"] }); break;\n            case hash("MESSAGE_DELETE_BULK"        ): onDeleteMessages    (d["channel_id"], json::toArray<Snowflake<Message>>(d["ids"])); break;\n            case hash("VOICE_SERVER_UPDATE"        ): {\n                VoiceServerUpdate voiceServer(d);\n#ifdef SLEEPY_VOICE_ENABLED\n                if (!waitingVoiceContexts.empty()) {\n                    auto iterator = find_if(waitingVoiceContexts.begin(), waitingVoiceContexts.end(),\n                        [&voiceServer](const VoiceContext* w) {\n                        return voiceServer.serverID == w->serverID && w->endpoint == "";\n                    });\n                    if (iterator != waitingVoiceContexts.end()) {\n                        VoiceContext& context = **iterator;\n                        context.token    = voiceServer.token;\n                        context.endpoint = voiceServer.endpoint;\n                        connectToVoiceIfReady(context);\n                    }\n                }\n#endif\n                onEditVoiceServer(voiceServer);\n                } break;\n            case hash("GUILD_SYNC"                 ): onServerSync        (d); break;\n            case hash("RELATIONSHIP_ADD"           ): onRelationship      (d); break;\n            case hash("RELATIONSHIP_REMOVE"        ): onDeleteRelationship(d); break;\n            case hash("MESSAGE_REACTION_ADD"       ): onReaction          (d["user_id"], d["channel_id"], d["message_id"], d["emoji"]); break;\n            case hash("MESSAGE_REACTION_REMOVE"    ): onDeleteReaction    (d["user_id"], d["channel_id"], d["message_id"], d["emoji"]); break;\n            case hash("MESSAGE_REACTION_REMOVE_ALL"): onDeleteAllReaction (d["guild_id"], d["channel_id"], d["message_id"]); break;\n            default: \n                setError(EVENT_UNKNOWN);\n                onError(ERROR_NOTE, json::toStdString(t));\n                break;\n            }\n            onDispatch(d);\n        break;\n        case HELLO:\n            heartbeatInterval = d["heartbeat_interval"].GetInt();\n            heartbeat();\n            if (!ready) sendIdentity();\n            else sendResume();\n            if (reconnectTimer.isValid())\n                reconnectTimer.stop();\n            break;\n        case RECONNECT:\n            reconnect();\n            break;\n        case INVALID_SESSION:\n            if (json::toBool(d) == true) {\n                schedule(&BaseDiscordClient::sendResume, 2500);\n            } else {\n                sessionID = "";\n                schedule(&BaseDiscordClient::sendIdentity, 2500);\n            }\n            break;\n        case HEARTBEAT_ACK:\n            wasHeartbeatAcked = true;\n            onHeartbeatAck();\n            break;\n        }\n    }\n\n    void BaseDiscordClient::processCloseCode(const int16_t code) {\n        setError(code);\n\n        switch (code) {\n        //Just reconnect\n        case 1006:\n        case UNKNOWN_ERROR:\n        case UNKNOWN_OPCODE:\n        case DECODE_ERROR:\n        case NOT_AUTHENTICATED:\n        case ALREADY_AUTHENTICATED:\n        case INVALID_SEQ:\n        case RATE_LIMITED:\n        case SESSION_TIMEOUT:\n        default:\n            break;\n\n        case 1000:\n            if (!isQuiting())\n                break;\n            //else fall through\n\n        //Might be Unrecoveralbe\n        //We may need to stop to prevent a restart loop.\n        case AUTHENTICATION_FAILED:\n        case INVALID_SHARD:\n        case SHARDING_REQUIRED:\n        case INVALID_INTENTS:\n        case DISALLOWED_INTENTS:\n            return quit(false, true);\n            break;\n        }\n        reconnect(1001);\n    }\n\n    void BaseDiscordClient::heartbeat() {\n        if (heartbeatInterval <= 0 || isQuiting()) return; //sanity test\n        \n        //if time and timer are out of sync, trust time\n        time_t currentTime = getEpochTimeMillisecond();\n        time_t nextHeartbest;\n        if (currentTime < (nextHeartbest = lastHeartbeat + heartbeatInterval)) {\n            heart = schedule(&BaseDiscordClient::heartbeat, nextHeartbest - currentTime);\n            return;\n        }\n\n        if (!wasHeartbeatAcked) {\n            reconnect(1001);\n        } else {\n            sendHeartbeat();\n        }\n\n        lastHeartbeat = currentTime;\n\n        heart = schedule(&BaseDiscordClient::heartbeat, heartbeatInterval);\n    }\n\n    void BaseDiscordClient::sendHeartbeat() {\n        std::string str = std::to_string(lastSReceived);\n        std::string heartbeat;\n        //The number 18 comes from 1 plus the length of {\\"op\\":1,\\"d\\":}\n        heartbeat.reserve(18 + str.length());\n        heartbeat += \n            "{"\n                "\\"op\\":1,"\n                "\\"d\\":"; heartbeat += str; heartbeat +=\n            "}";\n        sendL(heartbeat);\n        wasHeartbeatAcked = false;\n        onHeartbeat();\n    }\n\n    //\n    //Voice\n    //\n\n#ifdef SLEEPY_VOICE_ENABLED\n\n    VoiceContext& BaseDiscordClient::createVoiceContext(Snowflake<Server> server, Snowflake<Channel> channel, BaseVoiceEventHandler * eventHandler) {\n        Snowflake<Server> serverTarget = server != "" ? server : getChannel(channel).cast().serverID;\n        voiceContexts.push_front({ serverTarget, channel, eventHandler });\n        waitingVoiceContexts.emplace_front(&voiceContexts.front());\n        return voiceContexts.front();\n    }\n\n    void BaseDiscordClient::connectToVoiceChannel(VoiceContext& voiceContext, VoiceMode settings) {\n        std::string voiceState;\n        /*The number 131 came from the number of letters in this string:\n          {"op": 4,"d" : {"guild_id": "18446744073709551615",\n          "channel_id" : "18446744073709551615","self_mute" : false,"self_deaf" : false}}\n          plus one\n        */\n        voiceState.reserve(131);  //remember to update this when making changes to voice status\n        voiceState +=\n            "{"\n                "\\"op\\": 4,"\n                "\\"d\\": {"\n                    "\\"guild_id\\": \\""; voiceState += voiceContext.serverID; voiceState += "\\","\n                    "\\"channel_id\\""": \\""; voiceState += voiceContext.channelID; voiceState += "\\","\n                    "\\"self_mute\\"" ": "; voiceState += settings & mute   ? "true" : "false"; voiceState += ","\n                    "\\"self_deaf\\"" ": "; voiceState += settings & deafen ? "true" : "false"; voiceState +=\n                "}"\n            "}";\n        sendL(voiceState);\n        /*Discord will response by sending a VOICE_STATE_UPDATE and a\n          VOICE_SERVER_UPDATE payload. Take a look at processMessage\n          function at case VOICE_STATE_UPDATE and voiceServerUpdate\n          */\n    }\n\n    VoiceContext& BaseDiscordClient::connectToVoiceChannel(Snowflake<Server> server, Snowflake<Channel> channel, VoiceMode settings) {\n        VoiceContext& target = createVoiceContext(server, channel);\n        connectToVoiceChannel(target, settings);\n        return target;\n    }\n\n    void BaseDiscordClient::connectToVoiceIfReady(VoiceContext& context) {\n        if (context.endpoint == "" || context.sessionID == "") //check that we are ready\n            return;\n\n        //remove the port numbers at the end of the endpoint string\n        std::string& givenEndpoint = context.endpoint;\n        givenEndpoint = givenEndpoint.substr(0, givenEndpoint.find(\':\'));\n\n        std::string endpoint = VoiceConnection::getWebSocketURI(givenEndpoint);\n\n        //Add a new connection to the list of connections\n        voiceConnections.emplace_front( this, context );\n        VoiceConnection& voiceConnection = voiceConnections.front();\n\n        connect(endpoint, &voiceConnection, voiceConnection.connection);\n\n        //remove from wait list\n        waitingVoiceContexts.remove_if(\n            [&context](VoiceContext* right) {\n                return &context == right;\n            }\n        );\n    }\n\n    void BaseDiscordClient::removeVoiceConnectionAndContext(VoiceConnection & connection) {\n        const VoiceContext& context = connection.getContext();\n        voiceConnections.remove_if(\n            [&connection](VoiceConnection& right) {\n                return connection == right;\n            }\n        );\n        voiceContexts.remove_if(\n            [&context](VoiceContext& right) {\n                return &context == &right;\n            }\n        );\n    }\n\n#endif\n\n    const time_t BaseDiscordClient::getEpochTimeMillisecond() {\n        auto ms = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n        return ms.time_since_epoch().count();\n    }\n\n    const std::string BaseDiscordClient::getEditPositionString(const std::vector<std::pair<std::string, uint64_t>>& positions) {\n        std::vector<std::string> params(positions.size());\n        for (auto& value : positions) {\n            params.push_back(json::createJSON({\n                { "id", json::string(value.first) },\n                { "position", json::UInteger(value.second) }\n            }));\n        }\n        return json::createJSONArray(params);\n    }\n\n    Route::Route(const std::string route, const std::initializer_list<std::string>& _values)\n        : path(route), values(_values)\n    {\n        size_t targetSize = path.length();\n        for (std::string replacement : values)\n            targetSize += replacement.length();\n        _url.reserve(targetSize);\n\n        //In the future, use string view\n\n        size_t offset = 0;\n        for (std::string replacement : values) {\n            const size_t start = path.find(\'{\', offset);\n            const size_t end = path.find(\'}\', start);\n\n            //the +1 and -1 removes the { and }\n            const std::string identifier = path.substr(start + 1, end - start - 1);\n\n            auto foundParam = majorParameters.find(identifier);\n            if (foundParam != majorParameters.end()) {\n                foundParam->second = replacement;\n            }\n\n            _url += path.substr(offset, start - offset);\n            _url += replacement;\n            offset = end + 1; //the +1 removes the }\n        }\n        _url += path.substr(offset, path.length() - offset);\n\n    }\n\n    Route::Route(const char* route) : Route(route, {}) {}\n\n    const std::string Route::bucket(RequestMethod method) {\n        std::string target;\n        std::string methodString = std::to_string(method);\n        size_t targetLength = methodString.length();\n        for (auto param : majorParameters) {\n            targetLength += param.second.length();\n        }\n        targetLength = path.length();\n        target.reserve(targetLength);\n        target += methodString;\n        for (auto param : majorParameters) {\n            target += param.second;\n        }\n        target += path;\n        return target;\n    }\n}\n')),Object(a.b)("hr",null),Object(a.b)("p",null,"Updated on 24 February 2021 at 15:10:04 UTC"))}l.isMDXComponent=!0}}]);