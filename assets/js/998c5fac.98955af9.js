"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[126],{3905:function(t,e,n){n.d(e,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?s(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(r=0;r<s.length;r++)n=s[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var o=r.createContext({}),c=function(t){var e=r.useContext(o),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=c(t.components);return r.createElement(o.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,s=t.originalType,o=t.parentName,p=l(t,["components","mdxType","originalType","parentName"]),u=c(n),m=a,y=u["".concat(o,".").concat(m)]||u[m]||d[m]||s;return n?r.createElement(y,i(i({ref:e},p),{},{components:n})):r.createElement(y,i({ref:e},p))}));function m(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var s=n.length,i=new Array(s);i[0]=u;var l={};for(var o in e)hasOwnProperty.call(e,o)&&(l[o]=e[o]);l.originalType=t,l.mdxType="string"==typeof t?t:a,i[1]=l;for(var c=2;c<s;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5142:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var r=n(3117),a=n(102),s=(n(7294),n(3905)),i=["components"],l={title:"include/sleepy_discord/gateway.h"},o=void 0,c={unversionedId:"reference/Files/gateway_8h",id:"reference/Files/gateway_8h",title:"include/sleepy_discord/gateway.h",description:"Namespaces",source:"@site/docs/reference/Files/gateway_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/gateway_8h",permalink:"/sleepy-discord/docs/reference/Files/gateway_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/gateway.h"},sidebar:"Reference",previous:{title:"sleepy_discord/gateway.cpp",permalink:"/sleepy-discord/docs/reference/Files/gateway_8cpp"},next:{title:"include/sleepy_discord/generic_compression.h",permalink:"/sleepy-discord/docs/reference/Files/generic__compression_8h"}},p=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Types",id:"types",children:[],level:2},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum Status",id:"enum-status",children:[],level:3},{value:"enum GameType",id:"enum-gametype",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],d={toc:p};function u(t){var e=t.components,n=(0,a.Z)(t,i);return(0,s.kt)("wrapper",(0,r.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"namespaces"},"Namespaces"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,s.kt)("h2",{id:"classes"},"Classes"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null}),(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_session_start_limit"},"SleepyDiscord::SessionStartLimit")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_gateway"},"SleepyDiscord::Gateway")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_game"},"SleepyDiscord::Game")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_ready"},"SleepyDiscord::Ready")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_activity_timestamp_type_helper"},"SleepyDiscord::ActivityTimestampTypeHelper")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_activity_timestamp"},"SleepyDiscord::ActivityTimestamp")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_activity_party"},"SleepyDiscord::ActivityParty")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_activity_assets"},"SleepyDiscord::ActivityAssets")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_activity_secrets"},"SleepyDiscord::ActivitySecrets")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_application"},"SleepyDiscord::Application")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_activity"},"SleepyDiscord::Activity")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_activity_1_1_activity_type_01_4"},"SleepyDiscord::GetDefault< Activity::ActivityType >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_presence_update"},"SleepyDiscord::PresenceUpdate")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_server_members_chunk"},"SleepyDiscord::ServerMembersChunk")))))),(0,s.kt)("h2",{id:"types"},"Types"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null}),(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"enum"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/gateway_8h#enum-status"},"Status"))," { statusError = 0, online, doNotDisturb, idle, invisible, offline}")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"enum"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/gateway_8h#enum-gametype"},"GameType"))," { Playing = 0, Streaming = 1}")))),(0,s.kt)("h2",{id:"types-documentation"},"Types Documentation"),(0,s.kt)("h3",{id:"enum-status"},"enum Status"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,s.kt)("th",{parentName:"tr",align:null},"Value"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"statusError"),(0,s.kt)("td",{parentName:"tr",align:null},"0"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"online"),(0,s.kt)("td",{parentName:"tr",align:null}),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"doNotDisturb"),(0,s.kt)("td",{parentName:"tr",align:null}),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"idle"),(0,s.kt)("td",{parentName:"tr",align:null}),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"invisible"),(0,s.kt)("td",{parentName:"tr",align:null}),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"offline"),(0,s.kt)("td",{parentName:"tr",align:null}),(0,s.kt)("td",{parentName:"tr",align:null})))),(0,s.kt)("h3",{id:"enum-gametype"},"enum GameType"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,s.kt)("th",{parentName:"tr",align:null},"Value"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Playing"),(0,s.kt)("td",{parentName:"tr",align:null},"0"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Streaming"),(0,s.kt)("td",{parentName:"tr",align:null},"1"),(0,s.kt)("td",{parentName:"tr",align:null})))),(0,s.kt)("h2",{id:"source-code"},"Source code"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <ctime>\n#include <array>\n#include "discord_object_interface.h"\n#include "user.h"\n#include "channel.h"\n#include "server.h"\n\nnamespace SleepyDiscord {\n    struct SessionStartLimit : public DiscordObject {\n        SessionStartLimit() = default;\n        SessionStartLimit(const json::Value & rawJSON);\n        SessionStartLimit(const nonstd::string_view & json) :\n            SessionStartLimit(json::fromJSON<SessionStartLimit>(json)) {}\n\n        int total;\n        int remaining;\n        int resetAfter;\n        int maxConcurency;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&SessionStartLimit::total        , "total"          , json::OPTIONAL_FIELD),\n                json::pair(&SessionStartLimit::remaining    , "remaining"      , json::OPTIONAL_FIELD),\n                json::pair(&SessionStartLimit::resetAfter   , "reset_after"    , json::OPTIONAL_FIELD),\n                json::pair(&SessionStartLimit::maxConcurency, "max_concurrency", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n    \n    struct Gateway {\n        Gateway() = default;\n        Gateway(const json::Value & rawJSON);\n        Gateway(const nonstd::string_view & json) :\n            Gateway(json::fromJSON<Gateway>(json)) {}\n\n        std::string url;\n        int shards;\n        SessionStartLimit sessionStartLimit;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&Gateway::url              , "url"                , json::OPTIONAL_FIELD),\n                json::pair(&Gateway::shards           , "shards"             , json::OPTIONAL_FIELD),\n                json::pair(&Gateway::sessionStartLimit, "session_start_limit", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    enum Status {\n        statusError = 0,\n        online         ,\n        doNotDisturb   ,\n        idle           ,\n        invisible      ,\n        offline        \n    };\n\n    enum GameType {\n        Playing = 0,  //calling this Game causes issues\n        Streaming = 1\n    };\n\n    struct Game : public DiscordObject {\n        std::string name = "";\n        GameType type;\n        std::string url = ""; //used when type is Streaming\n    };\n\n    struct Ready : public DiscordObject {\n    public:\n        Ready() = default;\n        //Ready(const std::string * rawJSON);\n        Ready(const json::Value & rawJSON);\n        Ready(const nonstd::string_view& json) :\n            Ready(json::fromJSON<Ready>(json)) {}\n        //Ready(const json::Values values);\n        int v;  //gateway protocol version\n        User user;\n        std::list<Channel> privateChannels;\n        std::list<UnavailableServer> servers;\n        std::string sessionID;\n        //std::vector<std::string> trace;\n        std::array<int, 2> shard = { {0, 1} };\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Ready::v              , "v"               , json::REQUIRIED_FIELD),\n                json::pair                           (&Ready::user           , "user"            , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Ready::privateChannels, "private_channels", json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Ready::servers        , "guilds"          , json::REQUIRIED_FIELD),\n                json::pair                           (&Ready::sessionID      , "session_id"      , json::REQUIRIED_FIELD),\n                //This doesn\'t work anymore\n                //json::pair(&Ready::trace          , json::toArray<std::string>      , "_trace"          , json::REQUIRIED_FIELD),\n                json::pair<json::StdArrayTypeHelper >(&Ready::shard          , "shard"           , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    template<class Type>\n    struct ActivityTimestampTypeHelper {\n        using TypeHelper = json::PrimitiveTypeHelper<Type>;\n        static inline Type toType(const json::Value& value) {\n            //For some reason Discord sends a string sometimes\n            //instead of an int\n            return value.IsString() ?\n                static_cast<Type>(\n                    std::stoll(\n                        std::string(value.GetString(),\n                        value.GetStringLength())\n                    )\n                )\n                :\n                TypeHelper::toType(value);\n        }\n        static inline bool empty(const Type& value) {\n            return TypeHelper::empty(value);\n        }\n        static inline json::Value fromType(const Type& value, json::Value::AllocatorType& allocator) {\n            return TypeHelper::fromType(value, allocator);\n        }\n        static inline bool isType(const json::Value& value) {\n            return TypeHelper::isType(value);\n        }\n    };\n\n    struct ActivityTimestamp : public DiscordObject {\n    public:\n        ActivityTimestamp() = default;\n        ~ActivityTimestamp() = default;\n        ActivityTimestamp(const json::Value & json);\n        ActivityTimestamp(const nonstd::string_view& json) :\n            ActivityTimestamp(json::fromJSON<ActivityTimestamp>(json)) {}\n        Time start;\n        Time end;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair<ActivityTimestampTypeHelper>(&ActivityTimestamp::start, "start", json::OPTIONAL_FIELD),\n                json::pair<ActivityTimestampTypeHelper>(&ActivityTimestamp::end  , "end"  , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActivityParty : public DiscordObject {\n    public:\n        ActivityParty() = default;\n        ~ActivityParty() = default;\n        ActivityParty(const json::Value & json);\n        ActivityParty(const nonstd::string_view& json) :\n            ActivityParty(json::fromJSON<ActivityParty>(json)) {}\n        std::string ID;\n        std::array<int64_t, 2> size;\n        int64_t& currentSize = size[0];\n        int64_t& maxSize = size[1];\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                          (&ActivityParty::ID  , "id"  , json::OPTIONAL_FIELD),\n                json::pair<json::StdArrayTypeHelper>(&ActivityParty::size, "size", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActivityAssets : public DiscordObject {\n    public:\n        ActivityAssets() = default;\n        ~ActivityAssets() = default;\n        ActivityAssets(const json::Value & json);\n        ActivityAssets(const nonstd::string_view& json) :\n            ActivityAssets(json::fromJSON<ActivityAssets>(json)) {}\n        std::string largeImage;\n        std::string largeText;\n        std::string smallImage;\n        std::string smallText;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&ActivityAssets::largeImage, "large_image", json::OPTIONAL_FIELD),\n                json::pair(&ActivityAssets::largeText , "large_text" , json::OPTIONAL_FIELD),\n                json::pair(&ActivityAssets::smallImage, "small_image", json::OPTIONAL_FIELD),\n                json::pair(&ActivityAssets::smallText , "small_text" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ActivitySecrets : public DiscordObject {\n    public:\n        ActivitySecrets() = default;\n        ~ActivitySecrets() = default;\n        ActivitySecrets(const json::Value & json);\n        ActivitySecrets(const nonstd::string_view& json) :\n            ActivitySecrets(json::fromJSON<ActivitySecrets>(json)) {}\n        std::string join;\n        std::string spectate;\n        std::string match;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&ActivitySecrets::join    , "join"    , json::OPTIONAL_FIELD),\n                json::pair(&ActivitySecrets::spectate, "spectate", json::OPTIONAL_FIELD),\n                json::pair(&ActivitySecrets::match   , "match"   , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    //This is here for the snowflake\n    struct Application {};\n\n    struct Activity : public DiscordObject {\n    public:\n        Activity() = default;\n        ~Activity() = default;\n        Activity(const json::Value & json);\n        Activity(const nonstd::string_view& json) :\n            Activity(json::fromJSON<Activity>(json)) {}\n        std::string name;\n        enum ActivityType {\n            ACTIVITY_TYPE_NONE = -1,\n            GAME               = 0,\n            STREAMING          = 1,\n            LISTENING          = 2,\n        } type = ACTIVITY_TYPE_NONE;\n        std::string url;\n        ActivityTimestamp timestamps;\n        Snowflake<Application> applicationID;\n        std::string details;\n        std::string state;\n        //ActivityParty party;\n        ActivityAssets assets;\n        ActivitySecrets secrets;\n        bool instance;\n        enum ActivityFlags {\n            NONE         = 0 << 0,\n            INSTANCE     = 1 << 0,\n            JOIN         = 1 << 1,\n            SPECTATE     = 1 << 2,\n            JOIN_REQUEST = 1 << 3,\n            SYNC         = 1 << 4,\n            PLAY         = 1 << 5\n        } flags = NONE;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&Activity::name         , "name"          , json::REQUIRIED_FIELD        ),\n                json::pair<json::EnumTypeHelper>(&Activity::type         , "type"          , json::REQUIRIED_FIELD        ),\n                json::pair                      (&Activity::url          , "url"           , json::OPTIONAL_NULLABLE_FIELD),\n                json::pair                      (&Activity::timestamps   , "timestamps"    , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::applicationID, "application_id", json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::details      , "details"       , json::OPTIONAL_NULLABLE_FIELD),\n                json::pair                      (&Activity::state        , "state"         , json::OPTIONAL_NULLABLE_FIELD),\n                //json::pair                      (&Activity::party        , "party"         , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::assets       , "assets"        , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::secrets      , "secrets"       , json::OPTIONAL_FIELD         ),\n                json::pair                      (&Activity::instance     , "instance"      , json::OPTIONAL_FIELD         ),\n                json::pair<json::EnumTypeHelper>(&Activity::flags        , "flags"         , json::OPTIONAL_FIELD         )\n            );\n        JSONStructEnd\n    };\n\n    template<>\n    struct GetDefault<Activity::ActivityType> {\n        static inline const Activity::ActivityType get() {\n            return Activity::ActivityType::ACTIVITY_TYPE_NONE;\n        }\n    };\n\n    struct PresenceUpdate : public DiscordObject {\n    public:\n        PresenceUpdate() = default;\n        ~PresenceUpdate() = default;\n        PresenceUpdate(const json::Value & json);\n        PresenceUpdate(const nonstd::string_view& json) :\n            PresenceUpdate(json::fromJSON<PresenceUpdate>(json)) {}\n        User user;\n        Snowflake<Server> serverID;\n        std::string status;\n        std::vector<Activity> activities;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&PresenceUpdate::user           , "user"      , json::REQUIRIED_FIELD),\n                json::pair                           (&PresenceUpdate::serverID       , "guild_id"  , json::OPTIONAL_FIELD ),\n                json::pair                           (&PresenceUpdate::status         , "status"    , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&PresenceUpdate::activities     , "activities", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct ServerMembersChunk {\n        ServerMembersChunk() = default;\n        ServerMembersChunk(const json::Value& json);\n        ServerMembersChunk(const nonstd::string_view& json) :\n            ServerMembersChunk(json::fromJSON<ServerMembersChunk>(json)) {}\n        Snowflake<Server> serverID;\n        std::vector<ServerMember> members;\n        int chunkIndex;\n        int chunkCount;\n        std::vector<PresenceUpdate> presences;\n        std::string nonce;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&ServerMembersChunk::serverID  , "guild_id"   , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&ServerMembersChunk::members   , "members"    , json::REQUIRIED_FIELD),\n                json::pair                           (&ServerMembersChunk::chunkIndex, "chunk_index", json::REQUIRIED_FIELD),\n                json::pair                           (&ServerMembersChunk::chunkCount, "chunk_count", json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&ServerMembersChunk::presences , "presences"  , json::OPTIONAL_FIELD ),\n                json::pair                           (&ServerMembersChunk::nonce     , "nonce"      , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n}\n')),(0,s.kt)("hr",null),(0,s.kt)("p",null,"Updated on 21 January 2022 at 02:36:00 UTC"))}u.isMDXComponent=!0}}]);