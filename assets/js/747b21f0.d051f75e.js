"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[1184],{6142:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"only-sleepy-discord","title":"Using only Sleepy Discord","description":"There are at 3 things that the library needs in order to function the Websocket client and Sessions. There are also a few optional parts that allow for optional features such as voice. Currently, The only one optional part is UDP.","source":"@site/docs/only-sleepy-discord.md","sourceDirName":".","slug":"/only-sleepy-discord","permalink":"/sleepy-discord/docs/only-sleepy-discord","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1758946050000,"frontMatter":{"title":"Using only Sleepy Discord"},"sidebar":"Docs","previous":{"title":"Common Errors","permalink":"/sleepy-discord/docs/common-build-errors"},"next":{"title":"Events","permalink":"/sleepy-discord/docs/events"}}');var o=s(4848),i=s(8453);const c={title:"Using only Sleepy Discord"},r=void 0,l={},a=[{value:"HTTPS",id:"https",level:2},{value:"WebSockets",id:"websockets",level:2},{value:"Async I/O",id:"async-io",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"There are at 3 things that the library needs in order to function: WebSocket Secure, HTTPS, and Async Input/Output. The library splits this up into a 2 main parts: the Websocket client and Sessions. There are also a few optional parts that allow for optional features such as voice. Currently, The only one optional part is UDP."}),"\n",(0,o.jsx)("aside",{children:" There are a actually a few libraries that is part of Sleepy Discord. They are json and string view libraries. However, those are cross-platform and shouldn't cause any issues with compatibility. "}),"\n",(0,o.jsx)(n.h2,{id:"https",children:"HTTPS"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class MySession : public SleepyDiscord::GenericSession {\n\tMySession() = default;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You'll need to create a class that inherits ",(0,o.jsx)(n.code,{children:"GenericSession"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"This rest is mostly self-explanatory. You basicity implement functions that do what it the function name suggest."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void setUrl(const std::string& _url) override;\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is self-explanatory."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void setBody(const std::string* body) override;\n"})}),"\n",(0,o.jsx)(n.p,{children:"body is the data that will be sent in the body of the HTTP request."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void setHeader(const std::vector<SleepyDiscord::HeaderPair>& header) override;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["header is a list of header fields. ",(0,o.jsx)(n.code,{children:"SleepyDiscord::HeaderPair"})," has two variables, name and value."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"void setMultipart(const std::initializer_list<SleepyDiscord::Part>& parts) override;\n"})}),"\n",(0,o.jsx)(n.p,{children:"Like header, parts is a list of parts. SleepyDiscord::Part has 3 variables, name, value, and isFile."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"SleepyDiscord::Response Post  () override;\nSleepyDiscord::Response Patch () override;\nSleepyDiscord::Response Delete() override;\nSleepyDiscord::Response Get   () override;\nSleepyDiscord::Response Put   () override;\n"})}),"\n",(0,o.jsx)(n.p,{children:"This sends the https request. The only difference between each function is that they use different HTTP methods."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Execute this line at the start of your program\nSleepyDiscord::CustomInit SleepyDiscord::Session::init = \n\t[]()->SleepyDiscord::GenericSession* { return new MySession; };\n"})}),"\n",(0,o.jsx)(n.p,{children:"You need to set SleepyDiscord::Session::init to a function that returns a pointer to a new Session. You can put this in the beginning of your cpp file after including the header file with your session class."}),"\n",(0,o.jsx)(n.h2,{id:"websockets",children:"WebSockets"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class MyWebsocketConnection : public SleepyDiscord::GenericWebsocketConnection {\npublic:\n\tMyWebsocketConnection() {}\n\tMyWebsocketConnection(std::string token) {\n\t\tstart(token);\n\t}\n\n\tMyConnectionHandle handle;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You are going to need a WebSocket Connection class that the library will pass around in a ",(0,o.jsx)(n.code,{children:"std::shared_ptr<GenericWebsocketConnection>"})," called ",(0,o.jsx)(n.code,{children:"WebsocketConnection"}),". ",(0,o.jsx)(n.code,{children:"GenericWebsocketConnection"})," is an empty class so this acts like a ",(0,o.jsx)(n.code,{children:"std::shared_ptr<void>"}),". You can put anything you want in this class, but you'll likely need to handle in there. You'll also likely want to store a reference to the ",(0,o.jsx)(n.code,{children:"GenericMessageReceiver"})," in it, but it's optional if you don't want to. We'll talk about ",(0,o.jsx)(n.code,{children:"GenericMessageReceiver"})," later. You'll also need to call ",(0,o.jsx)(n.code,{children:"start"})," at some point, the constructor isn't a bad place to do this."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"class MyWebsocketClient : public SleepyDiscord::BaseDiscordClient {\n\tMyWebsocketClient() = default;\n}\n\n//The typedef is optional.\ntypedef MyWebsocketClient DiscordClient;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The WebSocket client is actually a child of The ",(0,o.jsx)(n.code,{children:"BaseDiscordClient"})," and using a typedef is renamed to ",(0,o.jsx)(n.code,{children:"DiscordClient"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Add these function decelerations to your WebsocketClient\n//Optional: These should can be set to private\nbool connect(\n\tconst std::string & uri,\n\tGenericMessageReceiver* messageProcessor,\n\tWebsocketConnection& connection\n) override {\n\tMyConnectionHandle handle = websocket.connect(uri); //connect and get handle from websocket library\n\tconnection = std::make_shared<MyWebsocketConnection>(messageProcessor, handle);\n\treturn false; //you don't need to return a bool, it was related to a removed feature.\n}\n\nvoid disconnect(\n\tunsigned int code,\n\tconst std::string reason,\n\tWebsocketConnection& connection\n) override {\n\tconnection.get<MyWebsocketConnection>().handle.disconnect()\n}\n\nvoid send(\n\tstd::string message,\n\tWebsocketConnection& connection\n) override {\n\tconnection.get<MyWebsocketConnection>().handle.send(message);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["There are 3 virtual functions that you need to override: connect, disconnect, and send. In ",(0,o.jsx)(n.code,{children:"connect"}),", set ",(0,o.jsx)(n.code,{children:"connection"})," to a new connection object with you ",(0,o.jsx)(n.code,{children:"WebsocketConnection"})," class. Use ",(0,o.jsx)(n.code,{children:"std::shared_ptr"}),"'s ",(0,o.jsx)(n.code,{children:"get"})," to get your ",(0,o.jsx)(n.code,{children:"WebSocketConnection"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Add the equivalent code to your connect function\nwebsocket.onOpen = [=]() {\n\tmessageProcessor->initialize();\n}\n\nwebsocket.onClose = [=](int16_t closeCode) {\n\tmessageProcessor->processCloseCode(closeCode);\n}\n\nwebsocket.onMessage = [=](std::string message) {\n\tmessageProcessor->processMessage(handle.getMessage(message))\n}\n\nwebsocket.onFail = [=]() {\n\tmessageProcessor->handleFailToConnect();\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is where you'll need ",(0,o.jsx)(n.code,{children:"messageProcessor"}),", you'll need to call it's member functions in the websocket callbacks. If you can't capture ",(0,o.jsx)(n.code,{children:"messageProcessor"}),", then you'll want to have a reference to it in your connection class."]}),"\n",(0,o.jsx)(n.h2,{id:"async-io",children:"Async I/O"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Add these function declarations to your WebsocketClient class\nvoid run();\nTimer schedule(TimedTask code, const time_t milliseconds) override;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["There's 1 function you'll need to implement, ",(0,o.jsx)(n.code,{children:"schedule"}),". ",(0,o.jsx)(n.code,{children:"run"})," is optional. Async I/O is done inside the ",(0,o.jsx)(n.code,{children:"WebSocketClient"})," so place them in there."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Add the equivalent code\nTimer MyWebsocketClient::schedule(TimedTask code, const time_t milliseconds) {\n\tLibrary::Timer timer = Library::createTimer(code, milliseconds);\n\treturn Timer([timer](){\n\t\ttimer.stop();\n\t});\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Create a timer that will call ",(0,o.jsx)(n.code,{children:"code"})," in ",(0,o.jsx)(n.code,{children:"milliseconds"})," milliseconds. Then, return a function to stop the timer."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Here's an example of run\nvoid run() {\n\tLibrary::run();\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>r});var t=s(6540);const o={},i=t.createContext(o);function c(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);