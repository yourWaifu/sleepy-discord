"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[8096],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return m}});var s=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,s,r=function(e,n){if(null==e)return{};var t,s,r={},a=Object.keys(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)t=a[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=s.createContext({}),d=function(e){var n=s.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=d(e.components);return s.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},h=s.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),h=d(t),m=r,p=h["".concat(c,".").concat(m)]||h[m]||u[m]||a;return t?s.createElement(p,o(o({ref:n},l),{},{components:t})):s.createElement(p,o({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=h;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var d=2;d<a;d++)o[d]=t[d];return s.createElement.apply(null,o)}return s.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8899:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return l},default:function(){return h}});var s=t(3117),r=t(102),a=(t(7294),t(3905)),o=["components"],i={title:"sleepy_discord/client.cpp"},c=void 0,d={unversionedId:"reference/Files/client_8cpp",id:"reference/Files/client_8cpp",title:"sleepy_discord/client.cpp",description:"Namespaces",source:"@site/docs/reference/Files/client_8cpp.md",sourceDirName:"reference/Files",slug:"/reference/Files/client_8cpp",permalink:"/sleepy-discord/docs/reference/Files/client_8cpp",tags:[],version:"current",frontMatter:{title:"sleepy_discord/client.cpp"},sidebar:"Reference",previous:{title:"include/sleepy_discord/channel.h",permalink:"/sleepy-discord/docs/reference/Files/channel_8h"},next:{title:"include/sleepy_discord/client.h",permalink:"/sleepy-discord/docs/reference/Files/client_8h"}},l=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Functions",id:"functions",children:[],level:2},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function hash",id:"function-hash",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],u={toc:l};function h(e){var n=e.components,t=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,s.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"namespaces"},"Namespaces"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Name"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},(0,a.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null},"Name"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"constexpr unsigned int"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},(0,a.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/client_8cpp#function-hash"},"hash")),"(const char * key, unsigned int i =0)")))),(0,a.kt)("h2",{id:"functions-documentation"},"Functions Documentation"),(0,a.kt)("h3",{id:"function-hash"},"function hash"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"constexpr unsigned int hash(\n    const char * key,\n    unsigned int i =0\n)\n")),(0,a.kt)("h2",{id:"source-code"},"Source code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#if _MSC_VER && !__INTEL_COMPILER\n#pragma warning( disable: 4307 )  //ignore integer overflow, becuase we are taking advantage of it\n#endif\n\n#include <chrono>\n#include <functional>\n#include <sstream>\n#include <iomanip>\n#include <ctime>\n#include <cstring>\n#include "client.h"\n#include "version_helper.h"\n//#include "json.h"\n#include "rapidjson/document.h"\n#ifdef SLEEPY_USE_HARD_CODED_GATEWAY\n    #include <cstring>\n#endif\n\nnamespace SleepyDiscord {\n    void BaseDiscordClient::start(const std::string _token, const char maxNumOfThreads, int _shardID, int _shardCount) {\n        if (!scheduleHandler) {\n            setError(CANT_SCHEDULE);\n            return;\n        }\n        \n        ready = false;\n        quiting = false;\n        bot = true;\n        setToken(_token);\n        if (_shardID != 0 || _shardCount != 0)\n            setShardID(_shardID, _shardCount);\n\n        messagesRemaining = 4;\n    }\n\n    BaseDiscordClient::~BaseDiscordClient() {\n        ready = false;\n        if (heart.isValid()) heart.stop();\n    }\n\n    Response BaseDiscordClient::request(const RequestMethod method, Route path, const std::string jsonParameters,\n        const std::vector<Part>& multipartParameters, RequestCallback callback, const RequestMode mode\n    ) {\n        //check if rate limited\n        Response response;\n        const time_t currentTime = getEpochTimeMillisecond();\n        response.birth = currentTime;\n        Route::Bucket bucket = path.bucket(method);\n\n        bool shouldCallCallback = true;\n        const auto handleCallbackCall = [&]() {\n            if (shouldCallCallback && callback)\n                callback(response);\n        };\n        const auto handleExceededRateLimit = [=, &shouldCallCallback](std::time_t timeTilRetry) {\n            onExceededRateLimit(\n                rateLimiter.isGlobalRateLimited, timeTilRetry,\n                { *this, method, path, jsonParameters, multipartParameters, callback, mode },\n                shouldCallCallback\n            );\n        };\n\n        time_t nextTry = rateLimiter.getLiftTime(bucket, currentTime);\n        if (0 < nextTry) {\n            handleExceededRateLimit(nextTry - currentTime);\n            response.statusCode = TOO_MANY_REQUESTS;\n            onError(TOO_MANY_REQUESTS,\n                "Too many request going to " +\n                    std::string(getMethodName(method)) + " " +\n                    path.url());\n            handleCallbackCall();\n            return response;\n        }\n        {   //the { is used so that onResponse is called after session is removed to make debugging performance issues easier\n            //request starts here\n            Session session;\n            session.setUrl("https://discord.com/api/v8/" + path.url());\n            std::vector<HeaderPair> header = {\n                { "Authorization", bot ? "Bot " + getToken() : getToken() },\n                { "User-Agent", userAgent },\n            };\n            if (jsonParameters != "") {\n                session.setBody(&jsonParameters);\n                header.push_back({ "Content-Type"  , "application/json"                      });\n                header.push_back({ "Content-Length", std::to_string(jsonParameters.length()) });\n            } else if (0 < multipartParameters.size()) {\n                session.setMultipart(multipartParameters);\n                header.push_back({ "Content-Type", "multipart/form-data" });\n            } else {\n                header.push_back({ "Content-Length", "0" });\n            }\n            session.setHeader(header);\n\n            //Do the response\n            switch (method) {\n            case Post: case Patch: case Delete: case Get: case Put:\n                response = session.request(method);\n                break;\n            default: response.statusCode = BAD_REQUEST; break; //unexpected method\n            }\n\n            //rate limit check\n            if (response.header["X-RateLimit-Remaining"] == "0" && response.statusCode != TOO_MANY_REQUESTS) {\n                std::tm date = {};\n                //for some reason std::get_time requires gcc 5\n                std::istringstream dateStream(response.header["Date"]);\n                dateStream >> std::get_time(&date, "%a, %d %b %Y %H:%M:%S GMT");\n                const double resetTime = std::stod(response.header["X-RateLimit-Reset"]);\n                const time_t reset = time_t(resetTime) + 1; //add one second for lost precision\n                const std::string& xBucket = response.header["X-RateLimit-Bucket"];\n#if defined(_WIN32) || defined(_WIN64)\n                std::tm gmTM;\n                std::tm* const resetGM = &gmTM;\n                gmtime_s(resetGM, &reset);\n#elif defined(__STDC_LIB_EXT1__)\n                std::tm gmTM;\n                std::tm* resetGM = &gmTM;\n                gmtime_s(&reset, resetGM);\n#else\n                std::tm* resetGM = std::gmtime(&reset);\n#endif\n                const time_t resetDelta = (std::mktime(resetGM) - std::mktime(&date)) * 1000;\n                rateLimiter.limitBucket(bucket, xBucket, resetDelta + getEpochTimeMillisecond());\n                onDepletedRequestSupply(bucket, resetDelta);\n            }\n\n            //status checking\n            switch (response.statusCode) {\n            case OK: case CREATED: case NO_CONTENT: case NOT_MODIFIED: break;\n            case TOO_MANY_REQUESTS:\n                {   //this should fall down to default\n                    std::string rawRetryAfter = response.header["Retry-After"];\n                    //the 5 is an arbitrary number, and there\'s 1000 ms in a second\n                    int retryAfter = rawRetryAfter != "" ? std::stoi(rawRetryAfter) : 5;\n                    retryAfter *= 1000; //convert to milliseconds\n                    rateLimiter.isGlobalRateLimited = response.header.find("X-RateLimit-Global") != response.header.end();\n                    rateLimiter.nextRetry = getEpochTimeMillisecond() + retryAfter;\n                    const std::string& xBucket = response.header["X-RateLimit-Bucket"];\n                    if (!rateLimiter.isGlobalRateLimited) {\n                        rateLimiter.limitBucket(bucket, xBucket, rateLimiter.nextRetry);\n                        onDepletedRequestSupply(bucket, retryAfter);\n                    }\n                    handleExceededRateLimit(retryAfter);\n                }\n            default:\n                {       //error\n                    const ErrorCode code = static_cast<ErrorCode>(response.statusCode);\n                    setError(code);     //https error\n                    if (!response.text.empty()) {\n                        //json::Values values = json::getValues(response.text.c_str(),\n                        //{ "code", "message" });   //parse json to get code and message\n                        rapidjson::Document document;\n                        document.Parse(response.text.c_str());\n                        if (!document.IsObject()) {\n                            onError(GENERAL_ERROR, "No error code or message from Discord");\n                            break;\n                        }\n\n                        auto errorCode = document.FindMember("code");\n                        auto errorMessage = document.FindMember("message");\n                        if (errorCode != document.MemberEnd()) {\n                            std::size_t fullErrorMessageSize = 0;\n                            fullErrorMessageSize += response.text.length();\n                            fullErrorMessageSize += 1;\n                            std::string message =\n                                (errorMessage != document.MemberEnd() ? errorMessage->value.GetString() : "");\n                            fullErrorMessageSize += message.length();\n                            std::string fullErrorMessage;\n                            fullErrorMessage.reserve(fullErrorMessageSize);\n                            fullErrorMessage += response.text;\n                            fullErrorMessage += \'\\n\';\n                            fullErrorMessage += message;\n\n                            onError(\n                                static_cast<ErrorCode>(errorCode->value.GetInt()),\n                                std::move(fullErrorMessage)\n                            );\n                        } else if (!response.text.empty()) {\n                            onError(ERROR_NOTE, response.text);\n#if defined(__cpp_exceptions) || defined(__EXCEPTIONS)\n                            if (static_cast<int>(mode) & static_cast<int>(ThrowError))\n                                throw code;\n#endif\n                        }\n                    }\n                } break;\n            }\n\n            handleCallbackCall();\n        }\n        onResponse(response);\n        return response;\n    }\n\n    const Route BaseDiscordClient::path(const char * source, std::initializer_list<std::string> values) {\n        return Route(source, values);\n    }\n\n    std::shared_ptr<ServerCache> BaseDiscordClient::createServerCache() {\n        setServerCache(std::make_shared<ServerCache>());\n        return getServerCache();\n    }\n\n    void BaseDiscordClient::setServerCache(std::shared_ptr<ServerCache> cache) {\n        serverCache = cache;\n        if ((ready || !isBot()) && serverCache->size() == 0)\n            *serverCache = getServers().get<Cache>();\n    }\n\n    void BaseDiscordClient::onDepletedRequestSupply(const Route::Bucket&, time_t) {\n    }\n\n    void BaseDiscordClient::onExceededRateLimit(bool, std::time_t timeTilRetry, Request request, bool& continueRequest) {\n        bool shouldScheduleNewRequest =\n            static_cast<int>(request.mode) & static_cast<int>(AsyncQueue);\n        continueRequest = !shouldScheduleNewRequest;\n        if (shouldScheduleNewRequest) {\n            //since we are scheduling the request, I think we should make it async\n            request.mode = Async;\n            schedule(request, timeTilRetry);\n        }\n    }\n\n    void BaseDiscordClient::updateStatus(std::string gameName, uint64_t idleSince, Status status, bool afk) {\n        std::string statusString[] = {\n            "", "online", "dnd", "idle", "invisible", "offline"\n        };\n\n        sendL(json::createJSON({\n            { "op", json::integer(STATUS_UPDATE) },\n            { "d", json::createJSON({\n                {"since", idleSince != 0 ? json::UInteger(idleSince) : "null"},\n                {"game", gameName != "" ? json::createJSON({\n                    {"name", json::string(gameName)},\n                    {"type", json::integer(0)}\n                }) : "null"},\n                { "status", SleepyDiscord::json::string(statusString[status]) },\n                { "afk", SleepyDiscord::json::boolean(afk) }\n            })}\n        }));\n    }\n\n    void BaseDiscordClient::requestServerMembers(ServerMembersRequest request) {\n        auto data = json::toJSON(request);\n        std::string stringData = json::stringify(data);\n\n        std::string query;\n        query.reserve(14 + stringData.length());\n        query += "{\\"op\\":8,\\"d\\":";\n        query += stringData;\n        query += "}";\n\n        sendL(query);\n    }\n\n    void BaseDiscordClient::waitTilReady() {\n        while (!ready) sleep(1000);\n    }\n\n    void BaseDiscordClient::setShardID(int _shardID, int _shardCount) {\n        shardID = _shardID;\n        shardCount = _shardCount;\n    }\n\n    void BaseDiscordClient::getTheGateway() {\n#ifdef SLEEPY_USE_HARD_CODED_GATEWAY\n    #ifndef SLEEPY_HARD_CODED_GATEWAY\n        #define SLEEPY_HARD_CODED_GATEWAY "wss://gateway.discord.gg/?v=8"\n    #endif\n        theGateway = SLEEPY_HARD_CODED_GATEWAY; //This is needed for when session is disabled\n#else\n        Session session;\n        session.setUrl("https://discord.com/api/gateway");\n        Response a = session.request(Get);  //todo change this back to a post\n        if (!a.text.length()) { //error check\n            quit(false, true);\n            return setError(GATEWAY_FAILED);\n        }\n        if (!theGateway.empty())\n            theGateway.clear();\n        //getting the gateway\n        for (unsigned int position = 0, j = 0; ; ++position) {\n            if (a.text[position] == \'"\')\n                ++j;\n            else if (j == 3) {\n                const unsigned int start = position;\n                while (a.text[++position] != \'"\');\n                unsigned int size = position - start;\n                theGateway.reserve(32);\n                theGateway.append(a.text, start, size);\n                theGateway += "/?v=8";\n                break;\n            }\n        }\n#endif\n        if (useTrasportConnection == 1)\n            theGateway += "&compress=zlib-stream";\n    }\n\n    void BaseDiscordClient::sendIdentity() {\n        //{\n        //  "op":2,\n        //   "d":{\n        //      "token":my_token,\n        //      "properties":{\n        //          $os":"windows 10",\n        //          "$browser":"Sleepy_Discord",\n        //          "$device":"Sleepy_Discord",\n        //      },\n        //      "compress":false,\n        //      "large_threshold":250           /I don\'t know what this does\n        //  }\n        //}\n#if defined(_WIN32) || defined(_WIN64)\n        const char * os = "Windows";\n#elif defined(__APPLE__) || defined(__MACH__)\n        const char * os = "macOS";\n#elif defined(__linux__) || defined(linux) || defined(__linux)\n        const char * os = "Linux";\n#elif defined __FreeBSD__\n        const char * os = "FreeBSD";\n#elif defined(unix) || defined(__unix__) || defined(__unix)\n        const char * os = "Unix";\n#else\n        const char* os = "\\\\u00AF\\\\\\\\_(\\\\u30C4)_\\\\/\\\\u00AF";  //shrug I dunno\n#endif\n        std::string identity;\n        identity.reserve(272); //remember to change this number when editing identity\n        identity += \n        "{"\n            "\\"op\\":2,"\n            "\\"d\\":{"\n                "\\"token\\":\\""; identity += getToken(); identity += "\\","\n                "\\"properties\\":{"\n                    "\\"$os\\":\\""; identity += os; identity += "\\","\n                    "\\"$browser\\":\\"Sleepy_Discord\\","\n                    "\\"$device\\":\\"Sleepy_Discord\\""\n                "},"\n                "\\"compress\\":";\n                    identity += compressionHandler && useTrasportConnection != 1 ?\n                        "true" : "false"; identity += ",";\n        if (shardCount != 0 && shardID <= shardCount) {\n            identity +=\n                "\\"shard\\":[";\n            identity += \n                    std::to_string(shardID); identity += ",";\n            identity +=\n                    std::to_string(shardCount);\n            identity +=\n                "],";\n        }\n        if (hasIntents()) {\n            identity +=\n                "\\"intents\\":";\n            identity +=\n                std::to_string(intents);\n        identity +=\n                \',\';\n        }\n        identity +=\n                "\\"large_threshold\\":250"\n            "}"\n        "}";\n        sendL(identity);\n    }\n\n    void BaseDiscordClient::sendResume() {\n        std::string resume;\n        resume.reserve(208);\n        resume +=\n        "{"\n            "\\"op\\":6,"\n            "\\"d\\":{"\n                "\\"token\\":\\""; resume += getToken(); resume += "\\","\n                "\\"session_id\\":\\""; resume += sessionID; resume += "\\","\n                "\\"seq\\":"; resume += std::to_string(lastSReceived); resume +=\n            "}"\n        "}";\n        sendL(resume);\n        onResume();\n    }\n\n    void BaseDiscordClient::quit(bool isRestarting, bool isDisconnected) {\n        if (!isRestarting)\n            quiting = true;\n\n#ifdef SLEEPY_VOICE_ENABLED\n        //quit all voice connections\n        for (VoiceConnection& voiceConnection : voiceConnections)\n            voiceConnection.disconnect();\n#endif\n        if (heart.isValid()) heart.stop(); //stop heartbeating\n        if (!isDisconnected) disconnectWebsocket(1000);\n        stopClient();\n        if (quiting) onQuit();\n    }\n\n    void BaseDiscordClient::restart() {\n        quit(true);\n        connect(theGateway, this, connection);\n        onRestart();\n    }\n\n    void BaseDiscordClient::reconnect(const unsigned int status) {\n        //before disconnecting, heartbeats need to stop or it\'ll crash\n        //and if it doesn\'t, it\'ll cause another reconnect\n        if (heart.isValid()) heart.stop();\n        //reset some heartbeat values, done so we don\'t spam discord\n        wasHeartbeatAcked = true;\n        lastHeartbeat = 0;\n        heartbeatInterval = 0;\n\n        disconnectWebsocket(status);\n        //it\'s recomemeded to get the gateway again after many reconnection tries\n        // but the chance of the gateway being different is very low so this line is\n        // commmented out as it seems to cause issues\n        //if (consecutiveReconnectsCount % 16 == 10 || theGateway.empty()) getTheGateway();\n        if (reconnectTimer.isValid())\n            reconnectTimer.stop();\n        reconnectTimer = schedule([this]() {\n            //if not a successful reconnection\n            if (consecutiveReconnectsCount != 0)\n                connect(theGateway, this, connection);\n        }, getRetryDelay());\n        consecutiveReconnectsCount += 1;\n\n        if (useTrasportConnection == 1)\n            compressionHandler->resetStream();\n    }\n\n    void BaseDiscordClient::disconnectWebsocket(unsigned int code, const std::string reason) {\n        disconnect(code, reason, connection);\n        onDisconnect();\n    }\n\n    bool BaseDiscordClient::sendL(std::string message) {\n        if (nextHalfMin <= getEpochTimeMillisecond()) {\n            const unsigned int maxMessagesPerMin = 116;\n            const unsigned int halfMinMilliseconds = 30000;\n            const unsigned int maxMessagesPerHalfMin = maxMessagesPerMin / 2;\n\n            nextHalfMin += halfMinMilliseconds;\n            messagesRemaining = maxMessagesPerHalfMin;\n        }\n\n        if (--messagesRemaining < 0) {\n            messagesRemaining = 0;\n            setError(RATE_LIMITED);\n            return false;\n        }\n        send(message, connection);\n        return true;\n    }\n\n    constexpr unsigned int hash(const char* key, unsigned int i = 0) {\n        return !key[i] ? 0 : (hash(key, i + 1) * 31) + key[i] - \'A\';\n    }\n\n    void BaseDiscordClient::processMessage(const std::string &message) {\n        rapidjson::Document document;\n        document.Parse(message.c_str(), message.length());\n        //  { "op", "d", "s", "t" }\n        int op = document["op"].GetInt();\n        const json::Value& t = document["t"];\n        json::Value& d = document["d"];\n        switch (op) {\n        case DISPATCH:\n            lastSReceived = document["s"].GetInt();\n            switch (hash(json::toStdString(t).c_str())) {\n            case hash("READY"                      ): {\n                Ready readyData = d;\n                sessionID = readyData.sessionID;\n                bot = readyData.user.bot;\n                userID = readyData.user;\n                onReady(readyData);\n                ready = true;\n                consecutiveReconnectsCount = 0; //Successfully connected\n                } break;\n            case hash("RESUMED"                    ): \n                consecutiveReconnectsCount = 0; //Successfully connected\n                onResumed();\n                break;\n            case hash("GUILD_CREATE"               ): {\n                Server server(d);\n                if (serverCache)\n                    serverCache->insert(server);\n                onServer(server);\n                } break;\n            case hash("GUILD_DELETE"               ): {\n                UnavailableServer server(d);\n                if (serverCache) {\n                    findServerInCache(server.ID, [=](ServerCache::iterator& found) {\n                        serverCache->erase(found);\n                    });\n                }\n                onDeleteServer(server);\n                } break;\n            case hash("GUILD_UPDATE"               ): {\n                Server server(d);\n                accessServerFromCache(server.ID, [server](Server& foundServer) {\n                    json::mergeObj(foundServer, server);\n                });\n                onEditServer(server);\n                } break;\n            case hash("GUILD_BAN_ADD"              ): onBan  (d["guild_id"], d["user"]); break;\n            case hash("GUILD_BAN_REMOVE"           ): onUnban(d["guild_id"], d["user"]); break;\n            case hash("GUILD_INTEGRATIONS_UPDATE"  ):                          break; //to do add this\n            case hash("GUILD_MEMBER_ADD"           ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                ServerMember member(d);\n                appendObjectToCache(serverID, &Server::members, member);\n                onMember(serverID, member);\n                } break;\n            case hash("GUILD_MEMBER_REMOVE"        ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                User user = d["user"];\n                eraseObjectFromCache(serverID, &Server::members, user.ID);\n                onRemoveMember(serverID, user);\n                } break;\n            case hash("GUILD_MEMBER_UPDATE"        ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                User user = d["user"];\n                std::vector<Snowflake<Role>> roles = json::toArray<Snowflake<Role>>(d["roles"]);\n                auto nickValue = d.FindMember("nick");\n                std::string nick = nickValue != d.MemberEnd() && nickValue->value.IsString() ?\n                    json::toStdString(nickValue->value) : "";\n                accessObjectFromCache(serverID, &Server::members, user.ID,\n                    [user, roles, nick](Server&, ServerMember& member) {\n                        member.user = user;\n                        member.roles = roles;\n                        member.nick = nick;\n                    }\n                );\n                onEditMember(serverID, user, roles, nick);\n                } break;\n            case hash("GUILD_MEMBERS_CHUNK"        ): onMemberChunk       (d); break;\n            case hash("GUILD_ROLE_CREATE"          ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                Role role = d["role"];\n                appendObjectToCache(serverID, &Server::roles, role);\n                onRole(serverID, role);\n                } break;\n            case hash("GUILD_ROLE_UPDATE"):\n            {\n                Snowflake<Server> serverID = d["guild_id"];\n                Role role = d["role"];\n                accessObjectFromCache(serverID, &Server::roles, role.ID,\n                    [role](Server&, Role& foundRole) {\n                        foundRole = role;\n                    }\n                );\n                onEditRole(serverID, role);\n            } break;\n            case hash("GUILD_ROLE_DELETE"          ): {\n                Snowflake<Server> serverID = d["guild_id"];\n                Snowflake<Role> roleID = d["role_id"];\n                eraseObjectFromCache(serverID, &Server::roles, roleID);\n                onDeleteRole(serverID, roleID);\n                } break;\n            case hash("GUILD_EMOJIS_UPDATE"        ): onEditEmojis        (d["guild_id"], json::toArray<Emoji>(d["emojis"])); break;\n            case hash("CHANNEL_CREATE"             ): {\n                Channel channel = d;\n                appendObjectToCache(channel.serverID, &Server::channels, channel);\n                onChannel(d);\n                } break;\n            case hash("CHANNEL_UPDATE"             ): {\n                Channel channel = d;\n                accessObjectFromCache(channel.serverID, &Server::channels, channel.ID,\n                    [channel](Server&, Channel& foundChannel) {\n                        foundChannel = channel;\n                    }\n                );\n                onEditChannel(d); \n                } break;\n            case hash("CHANNEL_DELETE"             ): {\n                Channel channel = d;\n                eraseObjectFromCache(channel.serverID, &Server::channels, channel.ID);\n                onDeleteChannel(d);\n                } break;\n            case hash("CHANNEL_PINS_UPDATE"): {\n                const json::Value& lastPinTimeValue = d["last_pin_timestamp"];\n                onPinMessage(\n                    d["channel_id"],\n                    lastPinTimeValue.IsString() ?\n                    json::toStdString(d["last_pin_timestamp"]) : ""\n                );\n            } break;\n            case hash("PRESENCE_UPDATE"            ): onPresenceUpdate    (d); break;\n            case hash("PRESENCES_REPLACE"          ):                          break;\n            case hash("USER_UPDATE"                ): onEditUser          (d); break;\n            case hash("USER_SETTINGS_UPDATE"       ): onEditUserSettings  (d); break;\n            case hash("VOICE_STATE_UPDATE"         ): {\n                VoiceState state(d);\n#ifdef SLEEPY_VOICE_ENABLED\n                if (!waitingVoiceContexts.empty()) {\n                    auto iterator = find_if(waitingVoiceContexts.begin(), waitingVoiceContexts.end(),\n                        [&state](const VoiceContext* w) { \n                        return state.channelID == w->channelID && w->sessionID == "";\n                    });\n                    if (iterator != waitingVoiceContexts.end()) {\n                        VoiceContext& context = **iterator;\n                        context.sessionID = state.sessionID;\n                        connectToVoiceIfReady(context);\n                    }\n                }\n#endif\n                onEditVoiceState(state);\n                } break;\n            case hash("TYPING_START"               ): onTyping            (d["channel_id"], d["user_id"], d["timestamp"].GetInt64() * 1000); break;\n            case hash("MESSAGE_CREATE"             ): onMessage           (document["d"]); break;\n            case hash("MESSAGE_UPDATE"             ): onEditMessage       (d); break;\n            case hash("MESSAGE_DELETE"             ): onDeleteMessages    (d["channel_id"], { d["id"] }); break;\n            case hash("MESSAGE_DELETE_BULK"        ): onDeleteMessages    (d["channel_id"], json::toArray<Snowflake<Message>>(d["ids"])); break;\n            case hash("VOICE_SERVER_UPDATE"        ): {\n                VoiceServerUpdate voiceServer(d);\n#ifdef SLEEPY_VOICE_ENABLED\n                if (!waitingVoiceContexts.empty()) {\n                    auto iterator = find_if(waitingVoiceContexts.begin(), waitingVoiceContexts.end(),\n                        [&voiceServer](const VoiceContext* w) {\n                        return voiceServer.serverID == w->serverID && w->endpoint == "";\n                    });\n                    if (iterator != waitingVoiceContexts.end()) {\n                        VoiceContext& context = **iterator;\n                        context.token    = voiceServer.token;\n                        context.endpoint = voiceServer.endpoint;\n                        connectToVoiceIfReady(context);\n                    }\n                }\n#endif\n                onEditVoiceServer(voiceServer);\n                } break;\n            case hash("MESSAGE_REACTION_ADD"       ): onReaction          (d["user_id"], d["channel_id"], d["message_id"], d["emoji"]); break;\n            case hash("MESSAGE_REACTION_REMOVE"    ): onDeleteReaction    (d["user_id"], d["channel_id"], d["message_id"], d["emoji"]); break;\n            case hash("MESSAGE_REACTION_REMOVE_ALL"): onDeleteAllReaction (d["guild_id"], d["channel_id"], d["message_id"]); break;\n            case hash("APPLICATION_COMMAND_CREATE" ): onAppCommand        (d); break;\n            case hash("APPLICATION_COMMAND_UPDATE" ): onEditAppCommand    (d); break;\n            case hash("APPLICATION_COMMAND_DELETE" ): onDeleteAppCommand  (d); break;\n            case hash("INTERACTION_CREATE"         ): onInteraction       (document["d"]); break;\n            case hash("STAGE_INSTANCE_CREATE"      ): onStageInstance     (d); break;\n            case hash("STAGE_INSTANCE_UPDATE"      ): onEditStageInstance (d); break;\n            case hash("STAGE_INSTANCE_DELETE"      ): onDeleteStageInstance(d); break;\n            default: \n                onUnknownEvent(json::toStdString(t), d);\n                break;\n            }\n            onDispatch(d);\n        break;\n        case HELLO:\n            heartbeatInterval = d["heartbeat_interval"].GetInt();\n            heartbeat();\n            if (!ready) sendIdentity();\n            else sendResume();\n            if (reconnectTimer.isValid())\n                reconnectTimer.stop();\n            break;\n        case RECONNECT:\n            reconnect();\n            break;\n        case INVALID_SESSION:\n            if (json::toBool(d) == true) {\n                schedule(&BaseDiscordClient::sendResume, 2500);\n            } else {\n                sessionID = "";\n                schedule(&BaseDiscordClient::sendIdentity, 2500);\n            }\n            break;\n        case HEARTBEAT_ACK:\n            wasHeartbeatAcked = true;\n            onHeartbeatAck();\n            break;\n        }\n    }\n\n    void BaseDiscordClient::processMessage(const WebSocketMessage message) {\n        switch (message.opCode) {\n        case WebSocketMessage::OPCode::binary: {\n            if (!compressionHandler)\n                break;\n            compressionHandler->uncompress(message.payload);\n            \n            //when using transport connections, Discord ends streams the flush siginal\n            constexpr std::array<const char, 4> flushSiginal = { 0, 0, \'\\xFF\', \'\\xFF\'};\n            constexpr std::size_t siginalLength = flushSiginal.max_size();\n            bool endsWithFlushSiginal = false;\n            if (useTrasportConnection == 1 && siginalLength <= message.payload.length()) {\n                const auto compare = message.payload.compare(\n                    message.payload.length() - siginalLength, siginalLength,\n                    flushSiginal.data(), siginalLength);\n                endsWithFlushSiginal = compare == 0;\n            }\n\n            //trasportConnection doesn\'t stop the stream\n            bool streamEnded = useTrasportConnection != 1 && compressionHandler->streamEnded();\n\n            if (streamEnded || endsWithFlushSiginal) {\n                std::shared_ptr<std::string> uncompressed = std::make_shared<std::string>();\n                compressionHandler->getOutput(*uncompressed);\n                postTask(\n                    [this, uncompressed]() {\n                        processMessage(*uncompressed);\n                    }\n                );\n            }\n            break;\n        }\n        case WebSocketMessage::OPCode::text: {\n            postTask(\n                [this, message]() {\n                    processMessage(message.payload);\n                }\n            );\n            break;\n        }\n        default: break;\n        }\n    }\n\n    void BaseDiscordClient::processCloseCode(const int16_t code) {\n        setError(code);\n\n        switch (code) {\n        //Just reconnect\n        case 1006:\n        case UNKNOWN_ERROR:\n        case UNKNOWN_OPCODE:\n        case DECODE_ERROR:\n        case NOT_AUTHENTICATED:\n        case ALREADY_AUTHENTICATED:\n        case INVALID_SEQ:\n        case RATE_LIMITED:\n        case SESSION_TIMEOUT:\n        default:\n            break;\n\n        case 1000:\n            if (!isQuiting())\n                break;\n            //else fall through\n\n        //Might be Unrecoveralbe\n        //We may need to stop to prevent a restart loop.\n        case AUTHENTICATION_FAILED:\n        case INVALID_SHARD:\n        case SHARDING_REQUIRED:\n        case INVALID_INTENTS:\n        case DISALLOWED_INTENTS:\n            return quit(false, true);\n            break;\n\n        case 4900: //Sleepy Discord reconnect\n            //don\'t do another reconnect during a reconnect\n            return;\n        }\n        reconnect();\n    }\n\n    void BaseDiscordClient::heartbeat() {\n        if (heartbeatInterval <= 0 || isQuiting()) return; //sanity test\n        \n        //if time and timer are out of sync, trust time\n        time_t currentTime = getEpochTimeMillisecond();\n        time_t nextHeartbest;\n        if (currentTime < (nextHeartbest = lastHeartbeat + heartbeatInterval)) {\n            heart = schedule(&BaseDiscordClient::heartbeat, nextHeartbest - currentTime);\n            return;\n        }\n\n        if (!wasHeartbeatAcked) {\n            //dead connection\n            reconnect();\n            return; //don\'t heartbeat\n        }\n\n        sendHeartbeat();\n        lastHeartbeat = currentTime;\n\n        if (heart.isValid())\n            heart.stop();\n        heart = schedule(&BaseDiscordClient::heartbeat, heartbeatInterval);\n    }\n\n    //\n    //Voice\n    //\n\n#ifdef SLEEPY_VOICE_ENABLED\n\n    VoiceContext& BaseDiscordClient::createVoiceContext(Snowflake<Server> server, Snowflake<Channel> channel, BaseVoiceEventHandler * eventHandler) {\n        Snowflake<Server> serverTarget = server != "" ? server : getChannel(channel).cast().serverID;\n        voiceContexts.push_front({ serverTarget, channel, eventHandler });\n        waitingVoiceContexts.emplace_front(&voiceContexts.front());\n        return voiceContexts.front();\n    }\n\n    void BaseDiscordClient::connectToVoiceChannel(VoiceContext& voiceContext, VoiceMode settings) {\n        std::string voiceState;\n        /*The number 131 came from the number of letters in this string:\n          {"op": 4,"d" : {"guild_id": "18446744073709551615",\n          "channel_id" : "18446744073709551615","self_mute" : false,"self_deaf" : false}}\n          plus one\n        */\n        voiceState.reserve(131);  //remember to update this when making changes to voice status\n        voiceState +=\n            "{"\n                "\\"op\\": 4,"\n                "\\"d\\": {"\n                    "\\"guild_id\\": \\""; voiceState += voiceContext.serverID; voiceState += "\\","\n                    "\\"channel_id\\""": \\""; voiceState += voiceContext.channelID; voiceState += "\\","\n                    "\\"self_mute\\"" ": "; voiceState += settings & mute   ? "true" : "false"; voiceState += ","\n                    "\\"self_deaf\\"" ": "; voiceState += settings & deafen ? "true" : "false"; voiceState +=\n                "}"\n            "}";\n        sendL(voiceState);\n        /*Discord will response by sending a VOICE_STATE_UPDATE and a\n          VOICE_SERVER_UPDATE payload. Take a look at processMessage\n          function at case VOICE_STATE_UPDATE and voiceServerUpdate\n          */\n    }\n\n    VoiceContext& BaseDiscordClient::connectToVoiceChannel(Snowflake<Server> server, Snowflake<Channel> channel, VoiceMode settings) {\n        VoiceContext& target = createVoiceContext(server, channel);\n        connectToVoiceChannel(target, settings);\n        return target;\n    }\n\n    void BaseDiscordClient::connectToVoiceIfReady(VoiceContext& context) {\n        if (context.endpoint == "" || context.sessionID == "") //check that we are ready\n            return;\n\n        //remove the port numbers at the end of the endpoint string\n        std::string& givenEndpoint = context.endpoint;\n        givenEndpoint = givenEndpoint.substr(0, givenEndpoint.find(\':\'));\n\n        std::string endpoint = VoiceConnection::getWebSocketURI(givenEndpoint);\n\n        //Add a new connection to the list of connections\n        voiceConnections.emplace_front( this, context );\n        VoiceConnection& voiceConnection = voiceConnections.front();\n\n        connect(endpoint, &voiceConnection, voiceConnection.connection);\n\n        //remove from wait list\n        waitingVoiceContexts.remove_if(\n            [&context](VoiceContext* right) {\n                return &context == right;\n            }\n        );\n    }\n\n    void BaseDiscordClient::removeVoiceConnectionAndContext(VoiceConnection & connection) {\n        const VoiceContext& context = connection.getContext();\n        voiceConnections.remove_if(\n            [&connection](VoiceConnection& right) {\n                return connection == right;\n            }\n        );\n        voiceContexts.remove_if(\n            [&context](VoiceContext& right) {\n                return &context == &right;\n            }\n        );\n    }\n\n#endif\n\n    const time_t BaseDiscordClient::getEpochTimeMillisecond() {\n        auto ms = std::chrono::time_point_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now());\n        return ms.time_since_epoch().count();\n    }\n\n    const std::string BaseDiscordClient::getEditPositionString(const std::vector<std::pair<std::string, uint64_t>>& positions) {\n        std::vector<std::string> params(positions.size());\n        for (auto& value : positions) {\n            params.push_back(json::createJSON({\n                { "id", json::string(value.first) },\n                { "position", json::UInteger(value.second) }\n            }));\n        }\n        return json::createJSONArray(params);\n    }\n\n    Route::Route(const std::string route, const std::initializer_list<std::string>& _values)\n        : path(route), values(_values)\n    {\n        size_t targetSize = path.length();\n        for (std::string replacement : values)\n            targetSize += replacement.length();\n        _url.reserve(targetSize);\n\n        //In the future, use string view\n\n        size_t offset = 0;\n        for (std::string replacement : values) {\n            const size_t start = path.find(\'{\', offset);\n            const size_t end = path.find(\'}\', start);\n\n            //the +1 and -1 removes the { and }\n            const std::string identifier = path.substr(start + 1, end - start - 1);\n\n            auto foundParam = majorParameters.find(identifier);\n            if (foundParam != majorParameters.end()) {\n                foundParam->second = replacement;\n            }\n\n            _url += path.substr(offset, start - offset);\n            _url += replacement;\n            offset = end + 1; //the +1 removes the }\n        }\n        _url += path.substr(offset, path.length() - offset);\n\n    }\n\n    Route::Route(const char* route) : Route(route, {}) {}\n\n    const std::string Route::bucket(RequestMethod method) {\n        std::string target;\n        std::string methodString = std::to_string(method);\n        size_t targetLength = methodString.length();\n        for (auto param : majorParameters) {\n            targetLength += param.second.length();\n        }\n        targetLength = path.length();\n        target.reserve(targetLength);\n        target += methodString;\n        for (auto param : majorParameters) {\n            target += param.second;\n        }\n        target += path;\n        return target;\n    }\n}\n')),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Updated on 21 January 2022 at 02:36:00 UTC"))}h.isMDXComponent=!0}}]);