"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[9511],{3905:function(e,n,s){s.d(n,{Zo:function(){return p},kt:function(){return u}});var t=s(7294);function o(e,n,s){return n in e?Object.defineProperty(e,n,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[n]=s,e}function r(e,n){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),s.push.apply(s,t)}return s}function a(e){for(var n=1;n<arguments.length;n++){var s=null!=arguments[n]?arguments[n]:{};n%2?r(Object(s),!0).forEach((function(n){o(e,n,s[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):r(Object(s)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(s,n))}))}return e}function i(e,n){if(null==e)return{};var s,t,o=function(e,n){if(null==e)return{};var s,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)s=r[t],n.indexOf(s)>=0||(o[s]=e[s]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)s=r[t],n.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(o[s]=e[s])}return o}var l=t.createContext({}),c=function(e){var n=t.useContext(l),s=n;return e&&(s="function"==typeof e?e(n):a(a({},n),e)),s},p=function(e){var n=c(e.components);return t.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},g=t.forwardRef((function(e,n){var s=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),g=c(s),u=o,m=g["".concat(l,".").concat(u)]||g[u]||d[u]||r;return s?t.createElement(m,a(a({ref:n},p),{},{components:s})):t.createElement(m,a({ref:n},p))}));function u(e,n){var s=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=s.length,a=new Array(r);a[0]=g;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var c=2;c<r;c++)a[c]=s[c];return t.createElement.apply(null,a)}return t.createElement.apply(null,s)}g.displayName="MDXCreateElement"},3814:function(e,n,s){s.r(n),s.d(n,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return g}});var t=s(3117),o=s(102),r=(s(7294),s(3905)),a=["components"],i={title:"sleepy_discord/endpoints.cpp"},l=void 0,c={unversionedId:"reference/Files/endpoints_8cpp",id:"reference/Files/endpoints_8cpp",title:"sleepy_discord/endpoints.cpp",description:"Namespaces",source:"@site/docs/reference/Files/endpoints_8cpp.md",sourceDirName:"reference/Files",slug:"/reference/Files/endpoints_8cpp",permalink:"/sleepy-discord/docs/reference/Files/endpoints_8cpp",tags:[],version:"current",frontMatter:{title:"sleepy_discord/endpoints.cpp"},sidebar:"Reference",previous:{title:"include/sleepy_discord/embed.h",permalink:"/sleepy-discord/docs/reference/Files/embed_8h"},next:{title:"include/sleepy_discord/error.h",permalink:"/sleepy-discord/docs/reference/Files/error_8h"}},p=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Functions",id:"functions",children:[],level:2},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function createMessageBody",id:"function-createmessagebody",children:[],level:3},{value:"function convertEmojiToURL",id:"function-convertemojitourl",children:[],level:3},{value:"function optionalWebhookToken",id:"function-optionalwebhooktoken",children:[],level:3},{value:"function CDN_path",id:"function-cdn_path",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],d={toc:p};function g(e){var n=e.components,s=(0,o.Z)(e,a);return(0,r.kt)("wrapper",(0,t.Z)({},d,s,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"namespaces"},"Namespaces"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/endpoints_8cpp#function-createmessagebody"},"createMessageBody")),"(std::string & message, Embed & embed, MessageReference & replyingTo, TTS tts)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/endpoints_8cpp#function-convertemojitourl"},"convertEmojiToURL")),"(const std::string emoji)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"const char *"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/endpoints_8cpp#function-optionalwebhooktoken"},"optionalWebhookToken")),"(std::string webhookToken)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"std::string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},(0,r.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/endpoints_8cpp#function-cdn-path"},"CDN_path")),"(const std::initializer_list< std::string > path)")))),(0,r.kt)("h2",{id:"functions-documentation"},"Functions Documentation"),(0,r.kt)("h3",{id:"function-createmessagebody"},"function createMessageBody"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::string createMessageBody(\n    std::string & message,\n    Embed & embed,\n    MessageReference & replyingTo,\n    TTS tts\n)\n")),(0,r.kt)("h3",{id:"function-convertemojitourl"},"function convertEmojiToURL"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::string convertEmojiToURL(\n    const std::string emoji\n)\n")),(0,r.kt)("h3",{id:"function-optionalwebhooktoken"},"function optionalWebhookToken"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"inline const char * optionalWebhookToken(\n    std::string webhookToken\n)\n")),(0,r.kt)("h3",{id:"function-cdn_path"},"function CDN_path"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::string CDN_path(\n    const std::initializer_list< std::string > path\n)\n")),(0,r.kt)("h2",{id:"source-code"},"Source code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <functional>\n#include "client.h"\n#include "discord_object_interface.h"\n#include "vector"\n\n#if _MSC_VER && !__INTEL_COMPILER\n#pragma warning( disable: 4458 ) //warns about variables that hide class members\n#endif\n\n//important note, all requests on sync mode throw on an http error\n\nnamespace SleepyDiscord {\n    void BaseDiscordClient::testFunction(std::string teststring) {\n\n    }\n    //\n    //channel functions\n    //\n\n    //ObjectResponse<Message> BaseDiscordClient::sendMessage(Snowflake<Channel> channelID, CreateMessageParams& params) {\n    //  return ObjectResponse<Message>{ request(Post, path("channels/{channel.id}/messages", { channelID }), json::stringifyObj(params)) };\n    //}\n\n    std::string createMessageBody(std::string& message, Embed& embed, MessageReference& replyingTo, TTS tts) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        rapidjson::Value content;\n        auto& allocator = doc.GetAllocator();\n        content.SetString(message.c_str(), message.length());\n        doc.AddMember("content", content, allocator);\n        if (tts == TTS::EnableTTS) doc.AddMember("tts", true, allocator);\n        if (!embed.empty()) doc.AddMember("embed", json::toJSON(embed, allocator), allocator);\n        if (!replyingTo.messageID.empty()) doc.AddMember("message_reference", json::toJSON(embed, allocator), allocator);\n        return json::stringify(doc);\n    }\n\n    ObjectResponse<Gateway> BaseDiscordClient::getGateway(RequestSettings<ObjectResponse<Gateway>> settings) {\n        return ObjectResponse<Gateway>{ request(Get, "gateway/bot", settings) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::sendMessage(Snowflake<Channel> channelID, std::string message, Embed embed, MessageReference replyingTo, TTS tts, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Post, path("channels/{channel.id}/messages", { channelID }), settings, createMessageBody(message, embed, replyingTo, tts)) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::sendMessage(SendMessageParams params, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Post, path("channels/{channel.id}/messages", { params.channelID }), settings, json::stringifyObj(params)) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::uploadFile(Snowflake<Channel> channelID, std::string fileLocation, std::string message, Embed embed, MessageReference replyingTo, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{\n            request(Post, path("channels/{channel.id}/messages", { channelID }), settings, "", {\n                { "file", filePathPart{fileLocation} },\n                { "payload_json", createMessageBody(message, embed, replyingTo, TTS::DisableTTS) }\n            })\n        };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::uploadFile(SendMessageParams params, std::string fileLocation, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{\n            request(Post, path("channels/{channel.id}/messages", { params.channelID }), settings, "", {\n                { "file", filePathPart{fileLocation} },\n                { "payload_json", json::stringifyObj(params) }\n            })\n        };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::editMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string newMessage, Embed embed, RequestSettings<ObjectResponse<Message>> settings) {\n        MessageReference mr{};\n        return ObjectResponse<Message>{ request(Patch, path("channels/{channel.id}/messages/{message.id}", { channelID, messageID }), settings, createMessageBody(newMessage, embed, mr, TTS::DisableTTS)) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::editMessage(EditMessageParams params, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Patch, path("channels/{channel.id}/messages/{message.id}", { params.channelID, params.messageID }), settings, json::stringifyObj(params)) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("channels/{channel.id}/messages/{message.id}", { channelID, messageID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::bulkDeleteMessages(Snowflake<Channel> channelID, std::vector<Snowflake<Message>> messageIDs, RequestSettings<BoolResponse> settings) {\n        std::string JSON = "{\\"messages\\":[";\n        for (Snowflake<Message> messageID : messageIDs) {\n            JSON += messageID;\n            JSON += \',\';\n        }\n        if (messageIDs.size())\n            JSON.pop_back();\n        JSON += "]}";\n        return { request(Post, path("channels/{channel.id}/messages/bulk-delete", { channelID }), settings, JSON), EmptyRespFn() };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::editChannel(Snowflake<Channel> channelID, std::string name, std::string topic, RequestSettings<ObjectResponse<Channel>> settings) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        rapidjson::Value nameValue;\n        if (name != "") {\n            nameValue.SetString(name.c_str(), name.length());\n            doc.AddMember("name", nameValue, allocator);\n        }\n        rapidjson::Value topicValue;\n        if (topic != "") {\n            topicValue.SetString(topic.c_str(), topic.length());\n            doc.AddMember("topic", topicValue, allocator);\n        }\n        return ObjectResponse<Channel>{ request(Patch, path("channels/{channel.id}", { channelID }), settings, json::stringify(doc)) };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::editChannelName(Snowflake<Channel> channelID, std::string name, RequestSettings<ObjectResponse<Channel>> settings) {\n        return editChannel(channelID, name, "", settings);\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::editChannelTopic(Snowflake<Channel> channelID, std::string topic, RequestSettings<ObjectResponse<Channel>> settings) {\n        return editChannel(channelID, "", topic, settings);\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::deleteChannel(Snowflake<Channel> channelID, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{ request(Delete, path("channels/{channel.id}", { channelID }), settings) };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::getChannel(Snowflake<Channel> channelID, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{ request(Get, path("channels/{channel.id}", { channelID }), settings) };\n    }\n\n    ArrayResponse<Message> BaseDiscordClient::getMessages(Snowflake<Channel> channelID, GetMessagesKey when, Snowflake<Message> messageID, uint8_t _limit) {\n        const uint8_t trueLimit = 100 < _limit ? 100 : _limit;\n        std::string key;\n        switch (when) {\n        case around: key = "?around=" + messageID; break;\n        case before: key = "?before=" + messageID; break;\n        case after:  key = "?after="  + messageID; break;\n        case limit:  key = "?"                    ; break;\n        default:     key = ""                     ; break;\n        }\n        if (trueLimit != 0 && when != limit) key += \'&\';\n        return ArrayResponse<Message>{\n            request(Get,\n                path("channels/{channel.id}/messages{key}{limit}", { channelID, key,\n                (trueLimit != 0 ? "limit=" + std::to_string(trueLimit) : "") })\n            )\n        };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::getMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<ObjectResponse<Message>> settings) {\n        return ObjectResponse<Message>{ request(Get, path("channels/{channel.id}/messages/{message.id}", { channelID, messageID }), settings) };\n    }\n\n    std::string convertEmojiToURL(const std::string emoji) {\n        if(emoji.empty() || emoji[0] == \'%\')\n            return emoji; //no need to convert\n        return escapeURL(emoji);\n    }\n\n    BoolResponse BaseDiscordClient::addReaction(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, RequestSettings<BoolResponse> settings) {\n        return { request(Put, path("channels/{channel.id}/messages/{message.id}/reactions/{emoji}/@me", { channelID, messageID, convertEmojiToURL(emoji) }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::removeReaction(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, Snowflake<User> userID) {\n        return { request(Delete, path("channels/{channel.id}/messages/{message.id}/reactions/{emoji}/{user.id}", { channelID, messageID, convertEmojiToURL(emoji), userID })), EmptyRespFn() };\n    }\n\n    ArrayResponse<User> BaseDiscordClient::getReactions(Snowflake<Channel> channelID, Snowflake<Message> messageID, std::string emoji, RequestSettings<ArrayResponse<Reaction>> settings) {\n        return ArrayResponse<User>{ request(Get, path("channels/{channel.id}/messages/{message.id}/reactions/{emoji}", { channelID, messageID, convertEmojiToURL(emoji) }), settings) };\n    }\n\n    StandardResponse BaseDiscordClient::removeAllReactions(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<StandardResponse> settings) {\n        return StandardResponse{ request(Delete, path("channels/{channel.id}/messages/{message.id}/reactions", { channelID, messageID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::editChannelPermissions(Snowflake<Channel> channelID, Snowflake<Overwrite> overwriteID, int allow, int deny, std::string type) {\n        return { request(\n            Put,\n            path("channels/{channel.id}/permissions/{overwrite.id}", { channelID, overwriteID }),\n            json::createJSON({\n                { "allow", std::to_string(allow) },\n                { "deny", std::to_string(deny) },\n                { "type", json::string(type) }\n        })), EmptyRespFn() };\n    }\n\n    ArrayResponse<Invite> BaseDiscordClient::getChannelInvites(Snowflake<Channel> channelID, RequestSettings<ArrayResponse<Invite>> settings) {\n        return ArrayResponse<Invite>{ request(Get, path("channels/{channel.id}/invites", { channelID }), settings) };\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::createChannelInvite(Snowflake<Channel> channelID, const uint64_t maxAge, const uint64_t maxUses, const bool temporary, const bool unique) {\n        return ObjectResponse<Invite>{\n            request(Post, path("channels/{channel.id}/invites", { channelID }),\n                json::createJSON({\n                    {"max_age", json::optionalUInteger(maxAge) },\n                    {"max_uses", json::optionalUInteger(maxUses) },\n                    { "temporary", temporary ? "true" : ""},\n                    { "unique", unique ? "true" : ""}\n                }\n            ))\n        };\n    }\n\n    BoolResponse BaseDiscordClient::removeChannelPermission(Snowflake<Channel> channelID, std::string ID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("channels/{channel.id}/permissions/{overwrite.id}", { channelID, ID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::sendTyping(Snowflake<Channel> channelID, RequestSettings<BoolResponse> settings) {\n        return { request(Post, path("channels/{channel.id}/typing", { channelID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<Message> BaseDiscordClient::getPinnedMessages(Snowflake<Channel> channelID, RequestSettings<ArrayResponse<Message>> settings) {\n        return ArrayResponse<Message>{ request(Get, path("channels/{channel.id}/pins", { channelID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::pinMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings) {\n        return { request(Put, path("channels/{channel.id}/pins/{message.id}", { channelID, messageID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::unpinMessage(Snowflake<Channel> channelID, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("channels/{channel.id}/pins/{message.id}", { channelID, messageID }), settings), EmptyRespFn() };\n    }\n\n    StandardResponse BaseDiscordClient::addRecipient(Snowflake<Channel> channelID, Snowflake<User> userID, RequestSettings<StandardResponse> settings) {\n        return StandardResponse{ request(Put, path("channels/{channel.id}/recipients/{user.id}", { channelID, userID }), settings) };\n    }\n\n    StandardResponse BaseDiscordClient::removeRecipient(Snowflake<Channel> channelID, Snowflake<User> userID, RequestSettings<StandardResponse> settings) {\n        return StandardResponse{ request(Delete, path("channels/{channel.id}/recipients/{user.id}", { channelID, userID }), settings) };\n    }\n\n    //\n    //server functions\n    //\n    ObjectResponse<Channel> BaseDiscordClient::createTextChannel(Snowflake<Server> serverID, std::string name, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{\n            request(Post, path("guilds/{guild.id}/channels", { serverID }), settings, "{\\"name\\": " + json::string(name) + ", \\"type\\": 0}")\n        };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::createChannel(Snowflake<Server> serverID, std::string name, Channel::ChannelType ChannelType, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{\n            request(Post, path("guilds/{guild.id}/channels", { serverID }), settings, "{\\"name\\": " + json::string(name) + ", \\"type\\": "+ std::to_string(ChannelType) +"}")\n        };\n    }\n\n    ArrayResponse<Channel> BaseDiscordClient::editChannelPositions(Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Channel>> settings) {\n        return ArrayResponse<Channel>{ request(Patch, path("guilds/{guild.id}/channels", { serverID }), getEditPositionString(positions)) };\n    }\n\n    ObjectResponse<ServerMember> SleepyDiscord::BaseDiscordClient::getMember(Snowflake<Server> serverID, Snowflake<User> userID, RequestSettings<ObjectResponse<ServerMember>> settings) {\n        return ObjectResponse<ServerMember>{ request(Get, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), settings) };\n    }\n\n    ArrayResponse<ServerMember> BaseDiscordClient::listMembers(Snowflake<Server> serverID, uint16_t limit, std::string after, RequestSettings<ArrayResponse<ServerMember>> settings) {\n        //Todo better Query String Params support\n        std::string limitParm = limit != 0 ? "?limit=" + std::to_string(limit) : "";\n        std::string afterParm = after != "" ? "after=" + after : "";\n        if (afterParm != "" && limitParm != "") limitParm += \'&\';\n        else if (afterParm != "" && limitParm == "") limitParm += \'?\';\n        return ArrayResponse<ServerMember>{ request(Get, path("guilds/{guild.id}/members{limit}{after}", { serverID, limitParm, afterParm }), settings) };\n    }\n\n    ObjectResponse<ServerMember> BaseDiscordClient::addMember(Snowflake<Server> serverID, Snowflake<User> userID, std::string accesToken, std::string nick, std::vector<Role> roles, bool mute, bool deaf) {\n        std::string rolesString = "";\n        if (roles.empty()){\n            rolesString = "";\n        } else {\n            int i = -1;\n            std::vector<std::string> values(roles.size());\n            for (Role role : roles) {\n                values[++i] = json::createJSON({\n                    { "id"         , json::string  (role.ID         ) },\n                    { "name"       , json::string  (role.name       ) },\n                    { "color"      , json::UInteger(role.color      ) },\n                    { "hoist"      , json::boolean (role.hoist      ) },\n                    { "position"   , json::integer (role.position   ) },\n                    { "managed"    , json::boolean (role.managed    ) },\n                    { "mentionable", json::boolean (role.mentionable) }\n                });\n            }\n            rolesString = json::createJSONArray(values);\n        }\n\n        return ObjectResponse<ServerMember>{\n            request(Put, path("guilds/{guild.id}/members/{user.id}"), json::createJSON({\n                { "access_token", json::string (accesToken) },\n                { "nick"        , json::string (nick)       },\n                { "roles"       , rolesString               },\n                { "mute"        , json::boolean(mute)       },\n                { "deaf"        , json::boolean(deaf)       }\n            })) \n        };\n    }\n\n    BoolResponse BaseDiscordClient::editMember(Snowflake<Server> serverID, Snowflake<User> userID, std::string nickname, std::vector<Snowflake<Role>> roles, int8_t mute, int8_t deaf, Snowflake<Channel> channelID) {\n        const std::string muteString = mute != -1 ? json::boolean(mute) : "";\n        const std::string deafString = deaf != -1 ? json::boolean(deaf) : "";\n\n        return { request(Patch, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), json::createJSON({\n            { "nick"      , json::string(nickname)       },\n            { "roles"     , json::createJSONArray(roles) },\n            { "mute"      , muteString                   },\n            { "deaf"      , deafString                   },\n            { "channel_id", json::string(channelID)      },\n        })), EmptyRespFn() };\n    }\n\n    ArrayResponse<Role> BaseDiscordClient::editRolePosition(Snowflake<Server> serverID, std::vector<std::pair<std::string, uint64_t>> positions, RequestSettings<ArrayResponse<Role>> settings) {\n        return ArrayResponse<Role>{ request(Patch, path("guilds/{guild.id}/roles", { serverID }), settings, getEditPositionString(positions)) };\n    }\n\n\n    StringResponse BaseDiscordClient::editRole(Snowflake<Server> serverID, Snowflake<Role> roleID, std::string name, Permission permissions, uint32_t color, int8_t hoist, int8_t mentionable) {\n        const std::string colorString       = color       >> 24 == 0 ? std::to_string(color      ) : "";    //if over 24 bits, do not change color\n        const std::string hoistString       = hoist       >> 1  == 0 ? json::boolean (hoist      ) : "";    //if larger then 1 bit, do change hoist\n        const std::string mentionableString = mentionable >> 1  == 0 ? json::boolean (mentionable) : "";\n\n        return StringResponse{\n            request(Patch, path("guilds/{guild.id}/roles/{role.id}", { serverID, roleID }), json::createJSON({\n                { "name"       , json::string(name)         },\n                { "permissions", json::integer(permissions) },\n                { "color"      , colorString                },\n                { "hoist"      , hoistString                },\n                { "mentionable", mentionableString          }\n            }))\n        };\n    }\n\n    BoolResponse SleepyDiscord::BaseDiscordClient::deleteRole(Snowflake<Server> serverID, Snowflake<Role> roleID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/roles/{role.id}", { serverID, roleID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::muteServerMember(Snowflake<Server> serverID, Snowflake<User> userID, bool mute, RequestSettings<BoolResponse> settings) {\n        return { request(Patch, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), settings, mute ? "{\\"mute\\":true}" : "{\\"mute\\":false}"), EmptyRespFn() };\n    }\n\n    //needs ablily to turn channel into json\n    /*ObjectResponse<Server> BaseDiscordClient::createServer(std::string name, std::string region, std::string icon, int verificationLevel, int defaultMessageNotifications, int explicitContentLevel, std::vector<Role> roles, std::vector<Channel> channels) {\n        request(Post, "guilds", json::createJSON({\n            { "name"                         , json::string (name) },\n            { "region"                       , json::string(region) },\n            { "icon"                         , json::string(icon) },\n            { "verification_level"           , json::integer(verificationLevel) },\n            { "default_message_notifications", json::integer(defaultMessageNotifications) },\n            { "explicit_content_filter"      , json::integer(explicitContentLevel) },\n            { "roles"                        , json::createJSONArray(roles) },\n            { "channels"                     , json::createJSONArray(channels) }\n        }));\n    }*/\n\n    ObjectResponse<Server> BaseDiscordClient::getServer(Snowflake<Server> serverID, RequestSettings<ObjectResponse<Server>> settings) {\n        return ObjectResponse<Server>{ request(Get, path("guilds/{guild.id}", { serverID }), settings) };\n    }\n\n    ObjectResponse<Server> BaseDiscordClient::deleteServer(Snowflake<Server> serverID, RequestSettings<ObjectResponse<Server>> settings) {\n        return ObjectResponse<Server>{ request(Delete, path("guilds/{guild.id}", { serverID }), settings) };\n    }\n\n    ArrayResponse<Channel> SleepyDiscord::BaseDiscordClient::getServerChannels(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Channel>> settings) {\n        return ArrayResponse<Channel>{ request(Get, path("guilds/{guild.id}/channels", { serverID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::editNickname(Snowflake<Server> serverID, std::string newNickname, RequestSettings<BoolResponse> settings) {\n        return { request(Patch, path("guilds/{guild.id}/members/@me/nick", { serverID }), settings, "{\\"nick\\":" + json::string(newNickname) + "}"), StandardRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::addRole(Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID, RequestSettings<BoolResponse> settings) {\n        return { request(Put, path("guilds/{guild.id}/members/{user.id}/roles/{role.id}", { serverID, userID, roleID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::removeRole(Snowflake<Server> serverID, Snowflake<User> userID, Snowflake<Role> roleID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/members/{user.id}/roles/{role.id}", { serverID, userID, roleID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::kickMember(Snowflake<Server> serverID, Snowflake<User> userID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/members/{user.id}", { serverID, userID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<User> BaseDiscordClient::getBans(Snowflake<Server> serverID, RequestSettings<ArrayResponse<User>> settings) {\n        return ArrayResponse<User>{ request(Get, path("guilds/{guild.id}/bans", { serverID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::banMember(Snowflake<Server> serverID, Snowflake<User> userID, int deleteMessageDays, std::string reason, RequestSettings<BoolResponse> settings) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        if (deleteMessageDays == -1)\n            doc.AddMember("delete_message_days", deleteMessageDays, allocator);\n        if (!reason.empty()) {\n            rapidjson::Value reasonValue;\n            reasonValue.SetString(reason.c_str(), reason.length());\n            doc.AddMember("reason", reasonValue, allocator);\n        }\n        return { request(Put, path("guilds/{guild.id}/bans/{user.id}", { serverID, userID }), settings, json::stringify(doc)), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::unbanMember(Snowflake<Server> serverID, Snowflake<User> userID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/bans/{user.id}", { serverID, userID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<Role> BaseDiscordClient::getRoles(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Role>> settings) {\n        return ArrayResponse<Role>{ request(Get, path("guilds/{guild.id}/roles", { serverID }), settings) };\n    }\n\n    ObjectResponse<Role> BaseDiscordClient::createRole(Snowflake<Server> serverID, std::string name, Permission permissions, unsigned int color, bool hoist, bool mentiionable) {\n        return ObjectResponse<Role>{\n            request(Post, path("guilds/{guild.id}/roles", { serverID }), json::createJSON({\n                { "name"       , json::string (name        ) },\n                { "permissions", json::integer(permissions ) },\n                { "color"      , json::integer(color       ) },\n                { "hoist"      , json::boolean(hoist       ) },\n                { "mentionable", json::boolean(mentiionable) }\n            }))\n        };\n    }\n\n    StandardResponse BaseDiscordClient::pruneMembers(Snowflake<Server> serverID, const unsigned int numOfDays, RequestSettings<StandardResponse> settings) {\n        if (numOfDays == 0) return StandardResponse{ BAD_REQUEST };\n        return StandardResponse{ request(Post, path("guilds/{guild.id}/prune", { serverID }), settings, "{\\"days\\":" + std::to_string(numOfDays) + \'}\') };\n    }\n\n    ArrayResponse<VoiceRegion> BaseDiscordClient::getVoiceRegions(RequestSettings<ArrayResponse<VoiceRegion>> settings) {\n        return ArrayResponse<VoiceRegion>{ request(Get, path("guilds/{guild.id}/regions"), settings) };\n    }\n\n    ArrayResponse<Invite> BaseDiscordClient::getServerInvites(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Invite>> settings) {\n        return ArrayResponse<Invite>{ request(Get, path("guilds/{guild.id}/invites", { serverID }), settings) };\n    }\n\n    StringResponse BaseDiscordClient::getIntegrations(Snowflake<Server> serverID, RequestSettings<StringResponse> settings) {\n        return StringResponse{ request(Get, path("guilds/{guild.id}/integrations", { serverID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::createIntegration(Snowflake<Server> serverID, std::string type, std::string integrationID, RequestSettings<BoolResponse> settings) {\n        return { request(Post, path("guilds/{guild.id}/integrations", { serverID }), settings, json::createJSON({\n            { "type", json::string(type) },\n            { "id", json::string(integrationID) }\n        })), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::editIntergration(Snowflake<Server> serverID, std::string integrationID, int expireBegavior, int expireGracePeriod, bool enbleEmoticons) {\n        return { request(Patch, path("guilds/{guild.id}/integrations/{integration.id}", { serverID, integrationID }), json::createJSON({\n            { "expire_behavior", json::integer(expireBegavior) },\n            { "expire_grace_period", json::integer(expireGracePeriod) },\n            { "enable_emoticons", json::boolean(enbleEmoticons) }\n        })), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::deleteIntegration(Snowflake<Server> serverID, std::string integrationID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("guilds/{guild.id}/integrations/{integration.id}", { serverID, integrationID }), settings), EmptyRespFn() };\n    }\n\n    BoolResponse BaseDiscordClient::syncIntegration(Snowflake<Server> serverID, std::string integrationID, RequestSettings<BoolResponse> settings) {\n        return { request(Post, path("guilds/{guild.id}/integrations/{integration.id}/sync", { serverID, integrationID }), settings), EmptyRespFn() };\n    }\n\n    ObjectResponse<ServerWidget> BaseDiscordClient::getServerWidget(Snowflake<Server> serverID, RequestSettings<ObjectResponse<ServerWidget>> settings) {\n        return ObjectResponse<ServerWidget>{ request(Get, path("guilds/{guild.id}/widget", { serverID }), settings) };\n    }\n\n    //\n    //Invite functions\n    //\n    ObjectResponse<Invite> BaseDiscordClient::inviteEndpoint(RequestMethod method, std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return ObjectResponse<Invite>{ request(method, path("invites/{invite.code}", { inviteCode }), settings) };\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::getInvite(std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return inviteEndpoint(Get, inviteCode, settings);\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::deleteInvite(std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return inviteEndpoint(Delete, inviteCode, settings);\n    }\n\n    ObjectResponse<Invite> BaseDiscordClient::acceptInvite(std::string inviteCode, RequestSettings<ObjectResponse<Invite>> settings) {\n        return inviteEndpoint(Post, inviteCode, settings);\n    }\n    //\n    //User functions\n    //\n    ObjectResponse<User> BaseDiscordClient::getCurrentUser(RequestSettings<ObjectResponse<User>> settings) {\n        return ObjectResponse<User>{ request(Get, "users/@me", settings) };\n    }\n\n    ObjectResponse<User> BaseDiscordClient::getUser(Snowflake<User> userID, RequestSettings<ObjectResponse<User>> settings) {\n        return ObjectResponse<User>{ request(Get, path("users/{user.id}", { userID }), settings) };\n    }\n\n    ArrayResponse<Server> BaseDiscordClient::getServers(RequestSettings<ArrayResponse<Server>> settings) {\n        return ArrayResponse<Server>{ request(Get, "users/@me/guilds", settings) };\n    }\n\n    BoolResponse BaseDiscordClient::leaveServer(Snowflake<Server> serverID, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path("users/@me/guilds/{guild.id}", { serverID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<Channel> BaseDiscordClient::getDirectMessageChannels(RequestSettings<ArrayResponse<Channel>> settings) {\n        return ArrayResponse<Channel>{ request(Get, "users/@me/channels", settings) };\n    }\n\n    ObjectResponse<Channel> BaseDiscordClient::createDirectMessageChannel(std::string recipientID, RequestSettings<ObjectResponse<Channel>> settings) {\n        return ObjectResponse<Channel>{ request(Post, "users/@me/channels", settings, json::createJSON({ { "recipient_id", recipientID } })) };\n    }\n\n    ArrayResponse<Connection> BaseDiscordClient::getUserConnections(RequestSettings<ArrayResponse<Connection>> settings) {\n        return ArrayResponse<Connection>{ request(Get, "users/@me/connections", settings) };\n    }\n\n    //\n    //Webhook functions\n    //\n    ObjectResponse<Webhook> BaseDiscordClient::createWebhook(Snowflake<Channel> channelID, std::string name, std::string avatar, RequestSettings<ObjectResponse<Webhook>> settings) {\n        return ObjectResponse<Webhook>{ request(Post, path("channels/{channel.id}/webhooks", { channelID }), settings, json::createJSON({\n            {"name", json::string(name)},\n            {"avatar", json::string(avatar)}\n        })) };\n    }\n\n    ArrayResponse<Webhook> BaseDiscordClient::getChannelWebhooks(Snowflake<Channel> channelID, RequestSettings<ArrayResponse<Webhook>> settings) {\n        return ArrayResponse<Webhook>{ request(Get, path("channels/{channel.id}/webhooks", { channelID }), settings) };\n    }\n\n    ArrayResponse<Webhook> BaseDiscordClient::getServerWebhooks(Snowflake<Server> serverID, RequestSettings<ArrayResponse<Webhook>> settings) {\n        return ArrayResponse<Webhook>{ request(Get, path("guilds/{guild.id}/webhooks", { serverID }), settings) };\n    }\n\n    inline const char* optionalWebhookToken(std::string webhookToken) {\n        return webhookToken != "" ? "webhooks/{webhook.id}/{webhook.token}" : "webhooks/{webhook.id}";\n    }\n\n    ObjectResponse<Webhook> BaseDiscordClient::getWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, RequestSettings<ObjectResponse<Webhook>> settings) {\n        return ObjectResponse<Webhook>{ request(Get, path(optionalWebhookToken(webhookToken), { webhookID, webhookToken }), settings) };\n    }\n\n    ObjectResponse<Webhook> BaseDiscordClient::editWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::string name, std::string avatar) {\n        return ObjectResponse<Webhook>{ request(Patch, path(optionalWebhookToken(webhookToken), { webhookID, webhookToken }), json::createJSON({\n            { "name", json::string(name) },\n            { "avatar", json::string(avatar) }\n        })) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, RequestSettings<BoolResponse> settings) {\n        return { request(Delete, path(optionalWebhookToken(webhookToken), { webhookID, webhookToken }), settings), EmptyRespFn() };\n    }\n\n    //excute webhook\n\n    ObjectResponse<Webhook> BaseDiscordClient::requestExecuteWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::pair<std::string, std::string> pair, bool wait, std::string username, std::string avatar_url, bool tts) {\n        return ObjectResponse<Webhook>{\n            request(Post, path("webhooks/{webhook.id}/{webhook.token}{wait}", { webhookID, webhookToken, (wait ? "?around=true" : "") }), json::createJSON({\n                pair,\n                { "username"  , json::string(username  ) },\n                { "avatar_url", json::string(avatar_url) },\n                { "tts"       , (tts ? "true" : "")      }\n            })) };\n    }\n\n    ObjectResponse<Webhook> BaseDiscordClient::executeWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::string content, bool wait, std::string username, std::string avatar_url, bool tts) {\n        return ObjectResponse<Webhook>{ requestExecuteWebhook(webhookID, webhookToken, { "content", json::string(content) }, wait, username, avatar_url, tts) };\n    }\n\n    //Webhook SleepyDiscord::BaseDiscordClient::executeWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, std::vector<Embed> embeds, bool wait, std::string username, std::string avatar_url bool tts) {\n    //  \n    //  return requestExecuteWebhook(webhookID, webhookToken, { "embeds", crazy stuff happens here }, wait, username, avatar_url, tts);\n    //}\n    \n    ObjectResponse<Webhook> BaseDiscordClient::executeWebhook(Snowflake<Webhook> webhookID, std::string webhookToken, filePathPart file, bool /*wait*/, std::string username, std::string avatar_url, bool tts) {\n        return ObjectResponse<Webhook>{ request(Post, path("webhooks/{webhook.id}/{webhook.token}", { webhookID, webhookToken }), "", {\n            { "file"      , filePathPart(file)  },\n            { "username"  , username            },\n            { "avatar_url", avatar_url          },\n            { "tts"       , (tts ? "true" : "") }\n        }) };\n    }\n\n    ArrayResponse<AppCommand> BaseDiscordClient::getGlobalAppCommands(Snowflake<DiscordObject>::RawType applicationID, RequestSettings<ArrayResponse<AppCommand>> settings) {\n        return ArrayResponse<AppCommand>{ request(Get, path("applications/{application.id}/commands", { applicationID }), settings) };\n    }\n\n    ObjectResponse<AppCommand> BaseDiscordClient::getGlobalAppCommand(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<AppCommand> commandID,\n        RequestSettings<ObjectResponse<AppCommand>> settings\n    ) {\n        return ObjectResponse<AppCommand>{ request(Get, path("applications/{application.id}/commands/{command.id}", { applicationID, commandID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteGlobalAppCommand(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<AppCommand> commandID, RequestSettings<BoolResponse> settings\n    ) {\n        return { request(Delete, path("applications/{application.id}/commands/{command.id}", { applicationID, commandID }), settings), EmptyRespFn() };\n    }\n\n    ArrayResponse<AppCommand> BaseDiscordClient::getServerAppCommands(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, RequestSettings<ArrayResponse<AppCommand>> settings\n    ) {\n        return ArrayResponse<AppCommand>{ request(Get, path("applications/{application.id}/guilds/{guild.id}/commands", { applicationID, serverID }), settings) };\n    }\n\n    ObjectResponse<AppCommand> BaseDiscordClient::getServerAppCommand(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID,\n        RequestSettings<ObjectResponse<AppCommand>> settings\n    ) {\n        return ObjectResponse<AppCommand>{ request(Get, path("applications/{application.id}/guilds/{guild.id}/commands/{command.id}", { applicationID, serverID, commandID }), settings) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteServerAppCommand(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<BoolResponse> settings\n    ) {\n        return { request(Delete, path("applications/{application.id}/guilds/{guild.id}/commands/{command.id}", { applicationID, serverID, commandID }), settings), EmptyRespFn() };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::editOriginalInteractionResponse(\n        Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, EditWebhookParams params, RequestSettings<BoolResponse> settings\n    ) {\n        return ObjectResponse<Message>{ request(Patch, path("webhooks/{application.id}/{interaction.token}/messages/@original", { applicationID, interactionToken }), settings, json::stringifyObj(params)) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteOriginalInteractionResponse(\n        Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, RequestSettings<BoolResponse> settings\n    ) {\n        return { request(Delete, path("webhooks/{application.id}/{interaction.token}/messages/@original", { applicationID, interactionToken }), settings), EmptyRespFn() };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::createFollowupMessage(\n        Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, FollowupMessage params, RequestSettings<BoolResponse> settings\n    ) {\n        return ObjectResponse<Message>{ request(Post, path("webhooks/{application.id}/{interaction.token}", { applicationID, interactionToken }), settings, json::stringifyObj(params)) };\n    }\n\n    ObjectResponse<Message> BaseDiscordClient::editFollowupMessage(\n        Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, Snowflake<Message> messageID, EditWebhookParams params, RequestSettings<BoolResponse> settings\n    ) {\n        return ObjectResponse<Message>{ request(Patch, path("webhooks/{application.id}/{interaction.token}/messages/{message.id}", { applicationID, interactionToken, messageID }), settings, json::stringifyObj(params)) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteFollowupMessage(\n        Snowflake<DiscordObject>::RawType applicationID, std::string interactionToken, Snowflake<Message> messageID, RequestSettings<BoolResponse> settings\n    ) {\n        return { request(Delete, path("webhooks/{application.id}/{interaction.token}/messages/{message.id}", { applicationID, interactionToken, messageID }), settings), EmptyRespFn() };\n    }\n    BoolResponse BaseDiscordClient::batchEditAppCommandPermissions(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, std::vector<ServerAppCommandPermissions> permissions, RequestSettings<BoolResponse> settings\n    ) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        for (auto& command : permissions) {\n            doc.AddMember("id", command.ID.number(), allocator);\n            rapidjson::Value arr{ rapidjson::Type::kArrayType };\n            for (auto& permission : command.permissions) {\n                arr.PushBack(json::toJSON(permission, allocator), allocator);\n            }\n            doc.AddMember("permissions", arr, allocator);\n        }\n        return BoolResponse{ request(Put, path("applications/{application.id}/guilds/{guild.id}/commands/permissions", { applicationID, serverID }), settings , json::stringify(doc)) };\n    }\n    BoolResponse BaseDiscordClient::editServerAppCommandPermission(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, std::vector<AppCommand::Permissions> permissions, RequestSettings<BoolResponse> settings\n    ) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        rapidjson::Value arr{ rapidjson::Type::kArrayType };\n        for (auto& permission : permissions) {\n            arr.PushBack(json::toJSON(permission, allocator), allocator);\n        }\n        doc.AddMember("permissions", arr, allocator);\n        return BoolResponse{ request(Put, path("applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions", { applicationID, serverID, commandID }), settings , json::stringify(doc)) };\n    }\n    ArrayResponse<ServerAppCommandPermissions> BaseDiscordClient::getServerAppCommandPermissions(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, RequestSettings<ArrayResponse<ServerAppCommandPermissions>> settings\n    ) {\n        return ArrayResponse<ServerAppCommandPermissions>{ request(Get, path("applications/{application.id}/guilds/{guild.id}/commands/permissions", { applicationID, serverID }), settings) };\n    }\n    ObjectResponse<ServerAppCommandPermissions> BaseDiscordClient::getAppCommandPermissions(\n        Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<ObjectResponse<ServerAppCommandPermissions>> settings\n    ) {\n        return ObjectResponse<ServerAppCommandPermissions>{ request(Get, path("applications/{application.id}/guilds/{guild.id}/commands/{command.id}/permissions", { applicationID, serverID, commandID }), settings) };\n    }\n\n    ArrayResponse<AppCommand> BaseDiscordClient::getAppCommands(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, RequestSettings<ArrayResponse<AppCommand>> settings) {\n        if (serverID.empty()) return getGlobalAppCommands(applicationID, settings);\n        return getServerAppCommands(applicationID, serverID, settings);\n    }\n\n    ObjectResponse<AppCommand> BaseDiscordClient::getAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<ObjectResponse<AppCommand>> settings) {\n        if (serverID.empty()) return getGlobalAppCommand(applicationID, commandID, settings);\n        return getServerAppCommand(applicationID, serverID, commandID,  settings);\n    }\n\n    BoolResponse BaseDiscordClient::deleteAppCommand(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, Snowflake<AppCommand> commandID, RequestSettings<BoolResponse> settings) {\n        if (serverID.empty()) return deleteGlobalAppCommand(applicationID, commandID, settings);\n        return deleteServerAppCommand(applicationID, serverID, commandID, settings);\n    }\n\n    BoolResponse BaseDiscordClient::bulkOverwriteServerAppCommands(Snowflake<DiscordObject>::RawType applicationID, Snowflake<Server> serverID, std::vector<AppCommand> commands, RequestSettings<BoolResponse> settings) {\n        rapidjson::Document doc;\n        doc.SetArray();\n        auto& allocator = doc.GetAllocator();\n        for (auto& command : commands) {\n            doc.PushBack(json::toJSON(command, allocator), allocator);\n        }\n        return BoolResponse{ request(Put, path("applications/{application.id}/guilds/{guild.id}/commands", {applicationID, serverID}), settings, json::stringify(doc)) };\n    }\n\n    BoolResponse BaseDiscordClient::bulkOverwriteGlobalAppCommands(Snowflake<DiscordObject>::RawType applicationID, std::vector<AppCommand> commands, RequestSettings<BoolResponse> settings) {\n        rapidjson::Document doc;\n        doc.SetArray();\n        auto& allocator = doc.GetAllocator();\n        for (auto& command : commands) {\n            doc.PushBack(json::toJSON(command, allocator), allocator);\n        }\n        return BoolResponse{ request(Put, path("applications/{application.id}/commands", {applicationID}), settings, json::stringify(doc)) };\n    }\n\n    ObjectResponse<User> BaseDiscordClient::createStageInstance(Snowflake<Channel> channelID, std::string topic, StageInstance::PrivacyLevel privacyLevel, RequestSettings<ObjectResponse<User>> settings) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        const std::string& channelIDStr = channelID.string();\n        doc.AddMember("channel_id", rapidjson::Value::StringRefType{ channelIDStr.c_str(), channelIDStr.length() }, allocator);\n        doc.AddMember("topic", rapidjson::Value::StringRefType{ topic.c_str(), topic.length() }, allocator);\n        if (privacyLevel != StageInstance::PrivacyLevel::NotSet)\n            doc.AddMember("privacy_level", static_cast<StageInstance::PrivacyLevelRaw>(privacyLevel), allocator);\n        return ObjectResponse<User>{\n            request(Post, path("/stage-instances", {}), settings, json::stringify(doc))\n        };\n    }\n\n    ObjectResponse<StageInstance> BaseDiscordClient::getStageInstance(Snowflake<Channel> channelID, RequestSettings<ObjectResponse<StageInstance>> settings) {\n        return ObjectResponse<StageInstance>{ request(Get, path("/stage-instances/{channel.id}", { channelID }), settings)};\n    }\n\n    BoolResponse BaseDiscordClient::editStageInstance(Snowflake<Channel> channelID, std::string topic, StageInstance::PrivacyLevel privacyLevel, RequestSettings<BoolResponse> settings) {\n        rapidjson::Document doc;\n        doc.SetObject();\n        auto& allocator = doc.GetAllocator();\n        doc.AddMember("topic", rapidjson::Value::StringRefType{ topic.c_str(), topic.length() }, allocator);\n        if (privacyLevel != StageInstance::PrivacyLevel::NotSet)\n            doc.AddMember("privacy_level", static_cast<StageInstance::PrivacyLevelRaw>(privacyLevel), allocator);\n        return BoolResponse{ request(Patch, path("/stage-instances/{channel.id}", {channelID}), settings, json::stringify(doc)) };\n    }\n\n    BoolResponse BaseDiscordClient::deleteStageInstance(Snowflake<Channel> channelID, RequestSettings<BoolResponse> settings) {\n        return BoolResponse{ request(Delete, path("/stage-instances/{channel.id}", {channelID}), settings) };\n    }\n\n    std::string CDN_path(const std::initializer_list<std::string> path) {\n        static constexpr auto CDN_URL = BaseDiscordClient::getCDN_URL();\n        std::size_t pathLength = CDN_URL.length();\n        for (const std::string& str : path) {\n            pathLength += str.length();\n        }\n        std::string CDN_path;\n        CDN_path.reserve(pathLength);\n        CDN_path += CDN_URL.data();\n        for (const std::string& str : path) {\n            CDN_path += str;\n        }\n        return CDN_path;\n    }\n\n    //CDN\n    void BaseDiscordClient::getServerBanner(Snowflake<Server> serverID, std::string banner, std::string format, std::function<void(StandardResponse&)> callback) {\n        static constexpr const char* pathMid = "banners/";\n        const std::string path = CDN_path({pathMid, serverID, "/", banner, format});\n        postTask([path, callback]() {\n            Session session;\n            session.setUrl(path);\n            auto response = StandardResponse{session.request(Get)};\n            callback(response);\n        });\n    }\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Updated on 29 January 2022 at 04:47:26 UTC"))}g.isMDXComponent=!0}}]);