"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[8552],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return u}});var r=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function d(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function a(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var i=r.createContext({}),l=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):d(d({},n),e)),t},m=function(e){var n=l(e.components);return r.createElement(i.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,s=e.mdxType,o=e.originalType,i=e.parentName,m=a(e,["components","mdxType","originalType","parentName"]),p=l(t),u=s,b=p["".concat(i,".").concat(u)]||p[u]||c[u]||o;return t?r.createElement(b,d(d({ref:n},m),{},{components:t})):r.createElement(b,d({ref:n},m))}));function u(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var o=t.length,d=new Array(o);d[0]=p;var a={};for(var i in n)hasOwnProperty.call(n,i)&&(a[i]=n[i]);a.originalType=e,a.mdxType="string"==typeof e?e:s,d[1]=a;for(var l=2;l<o;l++)d[l]=t[l];return r.createElement.apply(null,d)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},809:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return a},contentTitle:function(){return i},metadata:function(){return l},toc:function(){return m},default:function(){return p}});var r=t(3117),s=t(102),o=(t(7294),t(3905)),d=["components"],a={title:"include/sleepy_discord/embed.h"},i=void 0,l={unversionedId:"reference/Files/embed_8h",id:"reference/Files/embed_8h",title:"include/sleepy_discord/embed.h",description:"Namespaces",source:"@site/docs/reference/Files/embed_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/embed_8h",permalink:"/sleepy-discord/docs/reference/Files/embed_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/embed.h"},sidebar:"Reference",previous:{title:"sleepy_discord/embed.cpp",permalink:"/sleepy-discord/docs/reference/Files/embed_8cpp"},next:{title:"sleepy_discord/endpoints.cpp",permalink:"/sleepy-discord/docs/reference/Files/endpoints_8cpp"}},m=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Source code",id:"source-code",children:[],level:2}],c={toc:m};function p(e){var n=e.components,t=(0,s.Z)(e,d);return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"namespaces"},"Namespaces"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,o.kt)("h2",{id:"classes"},"Classes"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null}),(0,o.kt)("th",{parentName:"tr",align:null},"Name"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_thumbnail"},"SleepyDiscord::EmbedThumbnail")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_video"},"SleepyDiscord::EmbedVideo")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_image"},"SleepyDiscord::EmbedImage")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_provider"},"SleepyDiscord::EmbedProvider")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_author"},"SleepyDiscord::EmbedAuthor")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_footer"},"SleepyDiscord::EmbedFooter")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed_field"},"SleepyDiscord::EmbedField")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_embed"},"SleepyDiscord::Embed")))))),(0,o.kt)("h2",{id:"source-code"},"Source code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <string>\n#include "discord_object_interface.h"\n\nnamespace SleepyDiscord {\n    struct SendMessageParams;\n\n    struct EmbedThumbnail : public DiscordObject {\n    public:\n        EmbedThumbnail() = default;\n        //EmbedThumbnail(const std::string * rawJSON);\n        EmbedThumbnail(const json::Value & json);\n        EmbedThumbnail(const nonstd::string_view & json) :\n            EmbedThumbnail(json::fromJSON<EmbedThumbnail>(json)) {\n        }\n        //EmbedThumbnail(const json::Values values);\n        std::string url;\n        std::string proxyUrl;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty();\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedThumbnail::url     , "url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::proxyUrl, "proxy_url", json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::height  , "height"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedThumbnail::width   , "width"    , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedVideo : public DiscordObject {\n    public:\n        EmbedVideo() = default;\n        EmbedVideo(const json::Value & json);\n        EmbedVideo(const nonstd::string_view & json) :\n            EmbedVideo(json::fromJSON<EmbedVideo>(json)) {\n        }\n        std::string url;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedVideo::url   , "url"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedVideo::height, "height", json::OPTIONAL_FIELD),\n                json::pair(&EmbedVideo::width , "width" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n\n    struct EmbedImage : public DiscordObject {\n    public:\n        EmbedImage() = default;\n        EmbedImage(const json::Value & json);\n        EmbedImage(const nonstd::string_view & json) :\n            EmbedImage(json::fromJSON<EmbedImage>(json)) {\n        }\n        std::string url;\n        std::string proxyUrl;\n        int64_t height = 0;\n        int64_t width = 0;\n\n        bool empty() const {\n            return url.empty() && proxyUrl.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedImage::url     , "url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::proxyUrl, "proxy_url", json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::height  , "height"   , json::OPTIONAL_FIELD),\n                json::pair(&EmbedImage::width   , "width"    , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedProvider : public DiscordObject {\n    public:\n        EmbedProvider() = default;\n        //EmbedProvider(const std::string * rawJSON);\n        EmbedProvider(const json::Value & json);\n        EmbedProvider(const nonstd::string_view & json) :\n            EmbedProvider(json::fromJSON<EmbedProvider>(json)) {\n        }\n        //EmbedProvider(const json::Values values);\n        std::string name;\n        std::string url;\n\n        bool empty() const {\n            return name.empty() && url.empty();\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedProvider::name, "name", json::OPTIONAL_FIELD),\n                json::pair(&EmbedProvider::url , "url" , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedAuthor : public DiscordObject {\n    public:\n        EmbedAuthor() = default;\n        EmbedAuthor(const json::Value & json);\n        EmbedAuthor(const nonstd::string_view & json) :\n            EmbedAuthor(json::fromJSON<EmbedAuthor>(json)) {\n        }\n        std::string name;\n        std::string url;\n        std::string iconUrl;\n        std::string proxyIconUrl;\n\n        bool empty() const {\n            return name.empty() && url.empty() && iconUrl.empty() && proxyIconUrl.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedAuthor::name        , "name"          , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::url         , "url"           , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::iconUrl     , "icon_url"      , json::OPTIONAL_FIELD),\n                json::pair(&EmbedAuthor::proxyIconUrl, "proxy_icon_url", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedFooter : public DiscordObject {\n    public:\n        EmbedFooter() = default;\n        EmbedFooter(const json::Value & json);\n        EmbedFooter(const nonstd::string_view & json) :\n            EmbedFooter(json::fromJSON<EmbedFooter>(json)) {\n        }\n        std::string text;\n        std::string iconUrl;\n        std::string proxyIconUrl;\n\n        bool empty() const {\n            return text.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedFooter::text        , "text"          , json::REQUIRIED_FIELD),\n                json::pair(&EmbedFooter::iconUrl     , "icon_url"      , json::OPTIONAL_FIELD ),\n                json::pair(&EmbedFooter::proxyIconUrl, "proxy_icon_url", json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    struct EmbedField : public DiscordObject {\n    public:\n        EmbedField() = default;\n        EmbedField(const json::Value & json);\n        EmbedField(const nonstd::string_view & json) :\n            EmbedField(json::fromJSON<EmbedField>(json)) {}\n        EmbedField(std::string _name, std::string _value, bool _isInline = false)\n            : name(_name), value(_value), isInline(_isInline) {}\n        std::string name = "";\n        std::string value = "";\n        bool isInline = false;\n\n        bool empty() const {\n            return value.empty();\n        }\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&EmbedField::name    , "name"  , json::OPTIONAL_FIELD),\n                json::pair(&EmbedField::value   , "value" , json::OPTIONAL_FIELD),\n                json::pair(&EmbedField::isInline, "inline", json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    struct Embed : public DiscordObject {\n    public:\n        Embed() = default;\n        //Embed(const std::string * rawJSON);\n        Embed(const json::Value & json);\n        Embed(const nonstd::string_view & json) :\n            Embed(json::fromJSON<Embed>(json)) {}\n        //Embed(const json::Values values);\n        enum class Flag {\n            INVALID_EMBED = 0,\n            VALID_EMBED = 1\n        };\n        Embed(const Flag f) : flags(f) {}\n        std::string title;\n        std::string type;\n        std::string description;\n        std::string url;\n        std::string timestamp;\n        int32_t color = -1;\n        EmbedFooter footer;\n        EmbedImage image;\n        EmbedThumbnail thumbnail;\n        EmbedVideo video;\n        EmbedProvider provider;\n        EmbedAuthor author;\n        std::vector<EmbedField> fields;\n\n        bool empty() const {\n            return (flags == Flag::INVALID_EMBED) || (title.empty() && description.empty() && url.empty() &&\n                color == -1 && footer.empty() && image.empty() && thumbnail.empty() && video.empty() &&\n                provider.empty() && author.empty() && fields.empty());\n        }\n\n        //const static std::initializer_list<const char*const> fields;\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&Embed::title      , "title"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::type       , "type"       , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::description, "description", json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::url        , "url"        , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::timestamp  , "timestamp"  , json::OPTIONAL_FIELD),\n                json::pair<-1                       >(&Embed::color      , "color"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::footer     , "footer"     , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::image      , "image"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::thumbnail  , "thumbnail"  , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::video      , "video"      , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::provider   , "provider"   , json::OPTIONAL_FIELD),\n                json::pair                           (&Embed::author     , "author"     , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&Embed::fields     , "fields"     , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n\n    private:\n        friend BaseDiscordClient;\n        friend SendMessageParams;\n\n        Flag flags = Flag::VALID_EMBED;\n    };\n}\n')),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Updated on 26 January 2022 at 07:43:59 UTC"))}p.isMDXComponent=!0}}]);