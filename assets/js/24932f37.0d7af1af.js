"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[9118],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return u}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),i=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=i(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=i(t),u=r,_=m["".concat(p,".").concat(u)]||m[u]||d[u]||s;return t?a.createElement(_,o(o({ref:n},c),{},{components:t})):a.createElement(_,o({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,o=new Array(s);o[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var i=2;i<s;i++)o[i]=t[i];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5087:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return i},toc:function(){return c},default:function(){return m}});var a=t(3117),r=t(102),s=(t(7294),t(3905)),o=["components"],l={title:"include/sleepy_discord/slash_commands.h"},p=void 0,i={unversionedId:"reference/Files/slash__commands_8h",id:"reference/Files/slash__commands_8h",title:"include/sleepy_discord/slash_commands.h",description:"Namespaces",source:"@site/docs/reference/Files/slash__commands_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/slash__commands_8h",permalink:"/sleepy-discord/docs/reference/Files/slash__commands_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/slash_commands.h"},sidebar:"Reference",previous:{title:"sleepy_discord/slash_commands.cpp",permalink:"/sleepy-discord/docs/reference/Files/slash__commands_8cpp"},next:{title:"include/sleepy_discord/sleepy_discord.h",permalink:"/sleepy-discord/docs/reference/Files/sleepy__discord_8h"}},c=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Types",id:"types",children:[],level:2},{value:"Functions",id:"functions",children:[],level:2},{value:"Types Documentation",id:"types-documentation",children:[{value:"enum IntCallBackT",id:"enum-intcallbackt",children:[],level:3},{value:"using isInt",id:"using-isint",children:[],level:3},{value:"using isNum",id:"using-isnum",children:[],level:3},{value:"using InteractionAppCommandCallbackData",id:"using-interactionappcommandcallbackdata",children:[],level:3},{value:"using InteractionCallbackType",id:"using-interactioncallbacktype",children:[],level:3}],level:2},{value:"Functions Documentation",id:"functions-documentation",children:[{value:"function AppCommand::Option::Choice::set&lt; json::Value &gt;",id:"function-appcommandoptionchoiceset-jsonvalue-",children:[],level:3}],level:2},{value:"Source code",id:"source-code",children:[],level:2}],d={toc:c};function m(e){var n=e.components,t=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"namespaces"},"Namespaces"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord_1_1_interaction_callback"},"SleepyDiscord::InteractionCallback")))))),(0,s.kt)("h2",{id:"classes"},"Classes"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null}),(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command"},"SleepyDiscord::AppCommand")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option"},"SleepyDiscord::AppCommand::Option")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper"},"SleepyDiscord::AppCommand::Option::TypeHelper")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_impl"},"SleepyDiscord::AppCommand::Option::TypeHelperImpl")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_choice"},"SleepyDiscord::AppCommand::Option::Choice")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_permissions"},"SleepyDiscord::AppCommand::Permissions")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01bool_00_01void_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< bool, void >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01std_1_1string_00_01void_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< std::string, void >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01const_01char_01_5_00_01void_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< const char *, void >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01_channel_00_01void_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< Channel, void >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01_role_00_01void_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< Role, void >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01_user_00_01void_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< User, void >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01_int_00_01typename_01is_int_3_01_int_01_4_1_1type_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< Int, typename isInt< Int >::type >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_app_command_1_1_option_1_1_type_helper_3_01_num_00_01typename_01is_num_3_01_num_01_4_1_1type_01_4"},"SleepyDiscord::AppCommand::Option::TypeHelper< Num, typename isNum< Num >::type >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_server_app_command_permissions"},"SleepyDiscord::ServerAppCommandPermissions")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_app_command_1_1_option_1_1_default_01_4"},"SleepyDiscord::GetDefault< AppCommand::Option::Default >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_1_1_base_data"},"SleepyDiscord::InteractionCallback::BaseData")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_1_1_empty_data"},"SleepyDiscord::InteractionCallback::EmptyData")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_1_1_message"},"SleepyDiscord::InteractionCallback::Message")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_1_1_edit_message"},"SleepyDiscord::InteractionCallback::EditMessage")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_1_1_autocomplete"},"SleepyDiscord::InteractionCallback::Autocomplete")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_get_default_3_01_interaction_callback_1_1_message_1_1_flags_01_4"},"SleepyDiscord::GetDefault< InteractionCallback::Message::Flags >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_data"},"SleepyDiscord::InteractionData")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_data_1_1_option"},"SleepyDiscord::InteractionData::Option")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_data_1_1_resolved_data"},"SleepyDiscord::InteractionData::ResolvedData")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_data_1_1_resolved_data_1_1_data"},"SleepyDiscord::InteractionData::ResolvedData::Data")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper"},"SleepyDiscord::InteractionCallbackTypeHelper")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper_3_01_int_call_back_t_1_1_pong_01_4"},"SleepyDiscord::InteractionCallbackTypeHelper< IntCallBackT::Pong >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper_3_01_int_call_back_t_1_1_channel_message_with_source_01_4"},"SleepyDiscord::InteractionCallbackTypeHelper< IntCallBackT::ChannelMessageWithSource >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper_3_01_int_call_back_t_1_1_def_channel_message_w_score_01_4"},"SleepyDiscord::InteractionCallbackTypeHelper< IntCallBackT::DefChannelMessageWScore >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper_3_01_int_call_back_t_1_1_deferred_update_message_01_4"},"SleepyDiscord::InteractionCallbackTypeHelper< IntCallBackT::DeferredUpdateMessage >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper_3_01_int_call_back_t_1_1_update_message_01_4"},"SleepyDiscord::InteractionCallbackTypeHelper< IntCallBackT::UpdateMessage >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_type_helper_3_01_int_call_back_t_1_1_app_command_autocomplete_01_4"},"SleepyDiscord::InteractionCallbackTypeHelper< IntCallBackT::AppCommandAutocomplete >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_helper"},"SleepyDiscord::InteractionCallbackHelper")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_helper_3_01_interaction_callback_1_1_autocomplete_01_4"},"SleepyDiscord::InteractionCallbackHelper< InteractionCallback::Autocomplete >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_callback_helper_3_01_interaction_callback_1_1_edit_message_01_4"},"SleepyDiscord::InteractionCallbackHelper< InteractionCallback::EditMessage >")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction"},"SleepyDiscord::Interaction")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_interaction_1_1_response"},"SleepyDiscord::Interaction::Response")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"struct"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_followup_message"},"SleepyDiscord::FollowupMessage")))))),(0,s.kt)("h2",{id:"types"},"Types"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null}),(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"enum int"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/slash__commands_8h#enum-intcallbackt"},"IntCallBackT"))," { NONE = 0, Pong = 1, ChannelMessageWithSource = 4, DeferredChannelMessageWithSource = 5, DefChannelMessageWScore = DeferredChannelMessageWithSource, DeferredUpdateMessage = 6, UpdateMessage = 7, ApplicationCommandAutocompleteResult = 8, AppCommandAutocomplete = ApplicationCommandAutocompleteResult}")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"template <class Int ",">"," ",(0,s.kt)("br",null),"using typename std::enable_if< std::is_integral< Int >::value >"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/slash__commands_8h#using-isint"},"isInt")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"template <class Num ",">"," ",(0,s.kt)("br",null),"using typename std::enable_if< std::is_floating_point< Num >::value >"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/slash__commands_8h#using-isnum"},"isNum")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"using InteractionCallback::Message"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/slash__commands_8h#using-interactionappcommandcallbackdata"},"InteractionAppCommandCallbackData")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"using IntCallBackT"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/slash__commands_8h#using-interactioncallbacktype"},"InteractionCallbackType")))))),(0,s.kt)("h2",{id:"functions"},"Functions"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null}),(0,s.kt)("th",{parentName:"tr",align:null},"Name"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"void"),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Files/slash__commands_8h#function-appcommandoptionchoiceset%3C-jsonvalue-%3E"},"AppCommand::Option::Choice::set< json::Value >")),"(json::Value & _val)")))),(0,s.kt)("h2",{id:"types-documentation"},"Types Documentation"),(0,s.kt)("h3",{id:"enum-intcallbackt"},"enum IntCallBackT"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Enumerator"),(0,s.kt)("th",{parentName:"tr",align:null},"Value"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"NONE"),(0,s.kt)("td",{parentName:"tr",align:null},"0"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Pong"),(0,s.kt)("td",{parentName:"tr",align:null},"1"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"ChannelMessageWithSource"),(0,s.kt)("td",{parentName:"tr",align:null},"4"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"DeferredChannelMessageWithSource"),(0,s.kt)("td",{parentName:"tr",align:null},"5"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"DefChannelMessageWScore"),(0,s.kt)("td",{parentName:"tr",align:null},"DeferredChannelMessageWithSource"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"DeferredUpdateMessage"),(0,s.kt)("td",{parentName:"tr",align:null},"6"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"UpdateMessage"),(0,s.kt)("td",{parentName:"tr",align:null},"7"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"ApplicationCommandAutocompleteResult"),(0,s.kt)("td",{parentName:"tr",align:null},"8"),(0,s.kt)("td",{parentName:"tr",align:null})),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"AppCommandAutocomplete"),(0,s.kt)("td",{parentName:"tr",align:null},"ApplicationCommandAutocompleteResult"),(0,s.kt)("td",{parentName:"tr",align:null})))),(0,s.kt)("h3",{id:"using-isint"},"using isInt"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Int >\nusing SleepyDiscord::isInt = typedef typename std::enable_if < std::is_integral< Int >::value >;\n")),(0,s.kt)("h3",{id:"using-isnum"},"using isNum"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class Num >\nusing SleepyDiscord::isNum = typedef typename std::enable_if < std::is_floating_point< Num >::value >;\n")),(0,s.kt)("h3",{id:"using-interactionappcommandcallbackdata"},"using InteractionAppCommandCallbackData"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::InteractionAppCommandCallbackData = typedef InteractionCallback::Message;\n")),(0,s.kt)("h3",{id:"using-interactioncallbacktype"},"using InteractionCallbackType"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"using SleepyDiscord::InteractionCallbackType = typedef IntCallBackT;\n")),(0,s.kt)("h2",{id:"functions-documentation"},"Functions Documentation"),(0,s.kt)("h3",{id:"function-appcommandoptionchoiceset-jsonvalue-"},"function AppCommand::Option::Choice::set< json::Value >"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"inline void AppCommand::Option::Choice::set< json::Value >(\n    json::Value & _val\n)\n")),(0,s.kt)("h2",{id:"source-code"},"Source code"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <vector>\n#include "discord_object_interface.h"\n#include "snowflake.h"\n#include "server.h"\n#include "channel.h"\n#include "embed.h"\n#include "message.h"\n#include "user.h"\n\nnamespace SleepyDiscord {\n    \n    struct InteractionData;\n\n    // isInt is mostly for the Auto Docs, because without it, auto docs will generate\n    // very confusing links that confues the docs framework being used.\n    template<class Int>\n    using isInt = typename std::enable_if < std::is_integral< Int >::value >;\n\n    template<class Num>\n    using isNum = typename std::enable_if < std::is_floating_point< Num >::value >;\n\n    struct AppCommand : public IdentifiableDiscordObject<AppCommand> {\n        AppCommand() = default;\n        AppCommand(json::Value & json);\n        AppCommand(const nonstd::string_view& json) :\n            AppCommand(json::fromJSON<AppCommand>(json)) {}\n        \n        struct Option : public DiscordObject {\n            Option() = default;\n            Option(json::Value & json);\n            Option(const nonstd::string_view& json) :\n                AppCommand::Option(json::fromJSON<AppCommand::Option>(json)) {}\n\n            enum class Type : int {\n                NONE              = 0, //made up type\n                SUB_COMMAND       = 1,\n                SUB_COMMAND_GROUP = 2,\n                STRING            = 3,\n                INTEGER           = 4,\n                BOOLEAN           = 5,\n                USER              = 6,\n                CHANNEL           = 7,\n                ROLE              = 8,\n                MENTIONABLE       = 9,\n                NUMBER            = 10\n            };\n\n            template<class T, class C = void>\n            struct TypeHelper {};\n\n            template<Type type, class T>\n            struct TypeHelperImpl {\n                static constexpr Type getType() { return _type; }\n            private:\n                static constexpr Type _type = type;\n            };\n\n            struct Choice : public DiscordObject {\n                Choice() = default;\n                Choice(json::Value & json);\n                Choice(const nonstd::string_view& json) :\n                    AppCommand::Option::Choice(json::fromJSON<AppCommand::Option::Choice>(json)) {}\n\n                std::string name;\n                json::Value value;\n\n                //warning crashes if type isn\'t correct\n                template<class Type>\n                inline const Type get() {\n                    return json::ClassTypeHelper<Type>::toType(value);\n                }\n\n                template<class Type>\n                inline const bool get(Type& target) {\n                    return json::castValue<json::ClassTypeHelper<Type>>(target, value);\n                }\n\n                template<class Type>\n                inline void setCopy(Type& val) {\n                    value = json::copy(json::ClassTypeHelper<Type>::fromType(val));\n                }\n\n                template<class Type>\n                inline void setView(Type& val) {\n                    value = json::ClassTypeHelper<Type>::fromType(val);\n                }\n\n                //preforms a deep copy\n                Choice copy() {\n                    Choice choice;\n                    choice.name = name;\n                    choice.value = json::copy(value);\n                    return choice;\n                }\n\n                template<class Type>\n                inline void set(Type& val) {\n                    setView(val);\n                }\n\n                JSONStructStart\n                    std::make_tuple(\n                        json::pair(&AppCommand::Option::Choice::name , "name" , json::REQUIRIED_FIELD),\n                        json::pair(&AppCommand::Option::Choice::value, "value", json::REQUIRIED_FIELD)\n                    );\n                JSONStructEnd\n            };\n\n            Type type;\n            std::string name;\n            std::string description;\n            enum class Default : char {\n                True = true,\n                False = false,\n                Undefined = -1\n            };\n            Default isDefault = Default::Undefined; //default is an already taken keyword\n            bool isRequired = false;\n            std::vector<Choice> choices;\n            std::vector<Option> options;\n            std::vector<Channel::ChannelType> channelTypes;\n            double minValue = std::numeric_limits<double>::quiet_NaN();\n            double maxValue = std::numeric_limits<double>::quiet_NaN();\n            bool autocomplete = false;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper     >(&AppCommand::Option::type        , "type"        , json::REQUIRIED_FIELD),\n                    json::pair                           (&AppCommand::Option::name        , "name"        , json::REQUIRIED_FIELD),\n                    json::pair                           (&AppCommand::Option::description , "description" , json::OPTIONAL_FIELD ),\n                    json::pair                           (&AppCommand::Option::isRequired  , "required"    , json::OPTIONAL_FIELD ),\n                    json::pair<json::ContainerTypeHelper>(&AppCommand::Option::choices     , "choices"     , json::OPTIONAL_FIELD ),\n                    json::pair<json::ContainerTypeHelper>(&AppCommand::Option::options     , "options"     , json::OPTIONAL_FIELD ),\n                    json::pair                           (&AppCommand::Option::autocomplete, "autocomplete", json::OPTIONAL_FIELD )\n                );\n            JSONStructEnd\n        };\n\n        struct Permissions : public IdentifiableDiscordObject<DiscordObject> {\n            enum class Type : int {\n                ROLE = 1,\n                USER = 2\n            };\n            Permissions::Type Type;\n            bool Permission;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair                      (&Permissions::ID        , "id"        , json::REQUIRIED_FIELD),\n                    json::pair<json::EnumTypeHelper>(&Permissions::Type      , "type"      , json::REQUIRIED_FIELD),\n                    json::pair                      (&Permissions::Permission, "permission", json::REQUIRIED_FIELD)\n                );\n            JSONStructEnd\n        };\n\n        using InteractionData = SleepyDiscord::InteractionData;\n\n        enum class Type : int {\n            NONE       = 0, //made up for interal library use\n            CHAT_INPUT = 1,\n            USER       = 2,\n            MESSAGE    = 3\n        };\n        Type type = Type::CHAT_INPUT;\n        Snowflake<DiscordObject> applicationID;\n        std::string name;\n        std::string description;\n        std::vector<Option> options;\n        Snowflake<Server> serverID;\n        bool defaultPermission = true;\n        Snowflake<DiscordObject> version;\n\n        using EmptyOptions = std::nullptr_t;\n        static constexpr EmptyOptions emptyOptions = nullptr;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&AppCommand::ID               , "id"                , json::REQUIRIED_FIELD),\n                json::pair<json::EnumTypeHelper     >(&AppCommand::type             , "type"              , json::OPTIONAL_FIELD ),\n                json::pair                           (&AppCommand::applicationID    , "application_id"    , json::REQUIRIED_FIELD),\n                json::pair                           (&AppCommand::name             , "name"              , json::REQUIRIED_FIELD),\n                json::pair                           (&AppCommand::description      , "description"       , json::OPTIONAL_FIELD ),\n                json::pair                           (&AppCommand::defaultPermission, "default_permission", json::OPTIONAL_FIELD ),\n                json::pair<json::ContainerTypeHelper>(&AppCommand::options          , "options"           , json::OPTIONAL_FIELD ),\n                json::pair                           (&AppCommand::serverID         , "guild_id"          , json::OPTIONAL_FIELD ),\n                json::pair                           (&AppCommand::version          , "version"           , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    template<> struct AppCommand::Option::TypeHelper<bool       , void> :\n        public AppCommand::Option::TypeHelperImpl<Type::BOOLEAN, bool       > {};\n    template<> struct AppCommand::Option::TypeHelper<std::string, void> :\n        public AppCommand::Option::TypeHelperImpl<Type::STRING , std::string> {};\n    template<> struct AppCommand::Option::TypeHelper<const char*, void> :\n        public AppCommand::Option::TypeHelperImpl<Type::STRING , std::string> {};\n    template<> struct AppCommand::Option::TypeHelper<Channel    , void> :\n        public AppCommand::Option::TypeHelperImpl<Type::CHANNEL, Channel    > {};\n    template<> struct AppCommand::Option::TypeHelper<Role       , void> :\n        public AppCommand::Option::TypeHelperImpl<Type::ROLE   , Role       > {};\n    template<> struct AppCommand::Option::TypeHelper<User       , void> :\n        public AppCommand::Option::TypeHelperImpl<Type::USER   , User       > {};\n\n    template<class Int>\n    struct AppCommand::Option::TypeHelper<\n        Int, typename isInt<Int>::type\n    > : public AppCommand::Option::TypeHelperImpl< Type::INTEGER, Int > {};\n\n    template<class Num>\n    struct AppCommand::Option::TypeHelper<\n        Num, typename isNum<Num>::type\n    > : public AppCommand::Option::TypeHelperImpl< Type::NUMBER, Num > {};\n\n    struct ServerAppCommandPermissions : IdentifiableDiscordObject<AppCommand> {\n        Snowflake<User> applicationID;\n        Snowflake<Server> serverID;\n        std::vector<AppCommand::Permissions> permissions;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&ServerAppCommandPermissions::ID           , "id"            , json::REQUIRIED_FIELD),\n                json::pair                           (&ServerAppCommandPermissions::applicationID, "application_id", json::REQUIRIED_FIELD),\n                json::pair                           (&ServerAppCommandPermissions::serverID     , "guild_id"      , json::REQUIRIED_FIELD),\n                json::pair<json::ContainerTypeHelper>(&ServerAppCommandPermissions::permissions  , "permissions"   , json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    template<>\n    struct GetDefault<AppCommand::Option::Default> {\n        static inline const AppCommand::Option::Default get() {\n            return AppCommand::Option::Default::Undefined;\n        }\n    };\n\n    template<>\n    inline void AppCommand::Option::Choice::set<decltype(nullptr)>(decltype(nullptr)&) {\n        value.SetNull();\n    }\n\n    template<>\n    inline void AppCommand::Option::Choice::set<json::Value>(json::Value& _val) {\n        value = _val; //moves\n    }\n\n    namespace InteractionCallback {\n        struct BaseData : public DiscordObject {};\n        struct EmptyData : public DiscordObject {\n            EmptyData() = default;\n            EmptyData(json::Value & json);\n            EmptyData(const nonstd::string_view & json) :\n                EmptyData(json::fromJSON<EmptyData>(json)) {}\n\n            inline const bool empty() const {\n                return true;\n            }\n\n            JSONStructStart\n                std::make_tuple();\n            JSONStructEnd\n        };\n\n        struct Message : public WebHookParams {\n            Message() = default;\n            Message(json::Value & json);\n            Message(const nonstd::string_view& json) :\n                Message(json::fromJSON<Message>(json)) {}\n\n            inline const bool empty() const { return content.empty() && embeds.empty() && components.empty(); }\n\n            bool tts = false;\n            enum class Flags : int {\n                UNDEFINED = -1,\n                NONE = 0,\n                Ephemeral = 1 << 6\n            } flags = Flags::UNDEFINED;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair                           (&Message::tts            , "tts"             , json::OPTIONAL_FIELD),\n                    json::pair                           (&Message::content        , "content"         , json::OPTIONAL_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&Message::embeds         , "embeds"          , json::OPTIONAL_FIELD),\n                    json::pair                           (&Message::allowedMentions, "allowed_mentions", json::OPTIONAL_FIELD),\n                    json::pair<json::EnumTypeHelper     >(&Message::flags          , "flags"           , json::OPTIONAL_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&Message::components     , "components"      , json::OPTIONAL_FIELD)\n                );\n            JSONStructEnd\n        };\n\n        struct EditMessage : public BaseEditWebhookParams<EditWebhookParams> {\n            EditMessage() = default;\n            EditMessage(json::Value& json);\n            EditMessage(const nonstd::string_view& json) :\n                EditMessage(json::fromJSON<EditMessage>(json)) {}\n\n            inline const bool empty() const { return !(content || embeds || components); }\n\n            Message::Flags flags = Message::Flags::UNDEFINED;\n\n            JSONStructStart\n                std::tuple_cat(\n                    BaseEditWebhookParams<EditWebhookParams>::JSONStruct,\n                    std::make_tuple(\n                        json::pair<json::EnumTypeHelper>(&EditMessage::flags, "flags", json::OPTIONAL_FIELD)\n                    )\n                );\n            JSONStructEnd\n        };\n\n        struct Autocomplete : public DiscordObject {\n            Autocomplete() = default;\n            Autocomplete(json::Value & json);\n            Autocomplete(const nonstd::string_view & json) :\n                Autocomplete(json::fromJSON<Autocomplete>(json)) {}\n\n            std::vector<AppCommand::Option::Choice> choices;\n\n            bool empty() const {\n                return choices.empty();\n            }\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair<json::ContainerTypeHelper>(&Autocomplete::choices, "choices", json::REQUIRIED_FIELD)\n                );\n            JSONStructEnd\n        };\n    }\n\n    template<>\n    struct GetDefault<InteractionCallback::Message::Flags> {\n        static inline const InteractionCallback::Message::Flags get() {\n            return InteractionCallback::Message::Flags::UNDEFINED;\n        }\n    };\n\n    // for backwards compatibility, oops\n    using InteractionAppCommandCallbackData = InteractionCallback::Message;\n\n    struct InteractionData : public DiscordObject {\n        InteractionData() = default;\n        InteractionData(json::Value& json);\n        InteractionData(const nonstd::string_view& json) :\n            InteractionData(json::fromJSON<InteractionData>(json)) {}\n\n        struct Option : public DiscordObject {\n            Option() = default;\n            Option(json::Value& json);\n            Option(const nonstd::string_view& json) :\n                InteractionData::Option(json::fromJSON<InteractionData::Option>(json)) {}\n\n            std::string name;\n            AppCommand::Option::Type type = AppCommand::Option::Type::NONE;\n            json::Value value;\n            std::vector<Option> options;\n            bool focused = false;\n\n            //warning crashes on type error\n            template<class Type>\n            Type get() {\n                return json::ClassTypeHelper<Type>::toType(value);\n            }\n\n            template<class Type>\n            bool get(Type& target) {\n                return json::castValue<json::ClassTypeHelper<Type>>(target, value);\n            }\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair                           (&InteractionData::Option::name   , "name"   , json::OPTIONAL_FIELD),\n                    json::pair<json::EnumTypeHelper     >(&InteractionData::Option::type   , "type"   , json::OPTIONAL_FIELD),\n                    json::pair                           (&InteractionData::Option::value  , "value"  , json::OPTIONAL_FIELD),\n                    json::pair<json::ContainerTypeHelper>(&InteractionData::Option::options, "options", json::OPTIONAL_FIELD),\n                    json::pair                           (&InteractionData::Option::focused, "focused", json::OPTIONAL_FIELD)\n                );\n            JSONStructEnd\n        };\n\n        struct ResolvedData : public DiscordObject {\n            ResolvedData() = default;\n            ResolvedData(json::Value& json);\n            ResolvedData(const nonstd::string_view& json) :\n                ResolvedData(json::fromJSON<ResolvedData>(json)) {}\n\n            template<typename Type>\n            struct Data {\n                using JSONTypeHelper = json::ClassTypeHelper<json::Value>;\n                using Identifier = typename Type::Identifier;\n\n                Data() = default;\n                Data(json::Value & json) {\n                    data = JSONTypeHelper::toType(json); //moves\n                }\n                Data(const nonstd::string_view & json) :\n                    Data(json::fromJSON<Data>(json)) {}\n\n            private:\n\n                inline json::Value::MemberIterator find(const std::string& ID) {\n                    return data.FindMember(\n                        json::Value(json::Value::StringRefType(ID.c_str(), ID.length()))\n                    );\n                }\n\n                const bool find(const std::string& ID, Type& object) {\n                    auto member = find(ID);\n                    if (member != data.MemberEnd()) {\n                        object = member->value;\n                        return true;\n                    }\n                    return false;\n                }\n\n            public:\n\n                inline json::Value serialize(typename json::Value::AllocatorType& alloc) const {\n                    return JSONTypeHelper::fromType(data, alloc);\n                }\n\n                inline const bool empty() const { return JSONTypeHelper::empty(data); }\n\n                static inline const bool isType(const typename json::Value& value) {\n                    return value.IsObject();\n                }\n\n                inline json::Value::MemberIterator find(const Identifier& ID) {\n                    return find(ID.string());\n                }\n                \n                // useful for target_id since it can be a snowflake muliple discord objects\n                inline json::Value::MemberIterator find(const Snowflake<DiscordObject>& ID) {\n                    return find(ID.string());\n                }\n\n                inline json::Value::MemberIterator end() {\n                    return data.MemberEnd();\n                }\n\n                inline Type cast(json::Value::MemberIterator& member) {\n                    return member->value;\n                }\n\n                inline const bool find(const Identifier& ID, Type& object) {\n                    return find(ID.string(), object);\n                }\n\n                inline const bool find(const Snowflake<DiscordObject>& ID, Type& object) {\n                    return find(ID.string(), object);\n                }\n\n                inline std::unordered_map<Identifier, Type> createUnorderedMap() {\n                    return json::MapTypeHelper<\n                        std::unordered_map<Identifier, Type>,\n                        json::ClassTypeHelper>::toType(data);\n                }\n\n                json::Value data;\n            };\n\n            Data<User> users;\n            Data<ServerMember> members;\n            Data<Role> roles;\n            Data<Channel> channels;\n            Data<Message> messages;\n\n            //Note: JSON structure works very different here\n            //JSON is used as a dictionary here\n            JSONStructStart\n                std::make_tuple(\n                    json::pair(&InteractionData::ResolvedData::users   , "users"   , json::OPTIONAL_FIELD),\n                    json::pair(&InteractionData::ResolvedData::members , "members" , json::OPTIONAL_FIELD),\n                    json::pair(&InteractionData::ResolvedData::roles   , "roles"   , json::OPTIONAL_FIELD),\n                    json::pair(&InteractionData::ResolvedData::channels, "channels", json::OPTIONAL_FIELD),\n                    json::pair(&InteractionData::ResolvedData::messages, "messages", json::OPTIONAL_FIELD)\n                );\n            JSONStructEnd\n        };\n\n        Snowflake<AppCommand> ID;\n        std::string name;\n        AppCommand::Type type = AppCommand::Type::NONE;\n        ResolvedData resolved;\n        std::vector<Option> options;\n        std::string customID;\n        ComponentType componentType;\n        std::vector<std::string> values;\n        Snowflake<DiscordObject> targetID;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                           (&InteractionData::ID           , "id"            , json::OPTIONAL_FIELD),\n                json::pair                           (&InteractionData::name         , "name"          , json::OPTIONAL_FIELD),\n                json::pair<json::EnumTypeHelper     >(&InteractionData::type         , "type"          , json::OPTIONAL_FIELD),\n                json::pair                           (&InteractionData::resolved     , "resolved"      , json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&InteractionData::options      , "options"       , json::OPTIONAL_FIELD),\n                json::pair                           (&InteractionData::customID     , "custom_id"     , json::OPTIONAL_FIELD),\n                json::pair<json::EnumTypeHelper     >(&InteractionData::componentType, "component_type", json::OPTIONAL_FIELD),\n                json::pair<json::ContainerTypeHelper>(&InteractionData::values       , "values"        , json::OPTIONAL_FIELD),\n                json::pair                           (&InteractionData::targetID     , "target_id"     , json::OPTIONAL_FIELD)\n            );\n        JSONStructEnd\n    };\n\n    /*\n    * to do implement json maps first\n    struct ResolvedData : public DiscordObject {\n        ResolvedData() = default;\n        ResolvedData(json::Value& json);\n        ResolvedData(const nonstd::string_view& json) :\n            ResolvedData(json::fromJSON<ResolvedData>(json)) {}\n\n\n    };\n    */\n\n    // The names of these Types and Enum values are so long that it\'s\n    // causing doxybook2 to output links that are cut off.\n    // I\'m aware that the short hands make it harder to read.\n\n    enum class IntCallBackT : int {\n        NONE = 0, //made up type\n        Pong = 1,\n        ChannelMessageWithSource = 4,\n        DeferredChannelMessageWithSource = 5,\n        DefChannelMessageWScore = DeferredChannelMessageWithSource, //Def = deferred W = with\n        DeferredUpdateMessage = 6,\n        UpdateMessage = 7,\n        ApplicationCommandAutocompleteResult = 8,\n        AppCommandAutocomplete = ApplicationCommandAutocompleteResult //short hand\n    };\n\n    //shorthand\n    using InteractionCallbackType = IntCallBackT;\n\n    template<InteractionCallbackType type>\n    struct InteractionCallbackTypeHelper {\n        using Type = json::Value;\n    };\n    template<> struct InteractionCallbackTypeHelper<IntCallBackT::Pong> {\n        using Type = InteractionCallback::EmptyData;\n    };\n    template<> struct InteractionCallbackTypeHelper<IntCallBackT::ChannelMessageWithSource> {\n        using Type = InteractionCallback::Message;\n    };\n    template<> struct InteractionCallbackTypeHelper<IntCallBackT::DefChannelMessageWScore> {\n        using Type = InteractionCallback::EmptyData;\n    };\n    template<> struct InteractionCallbackTypeHelper<IntCallBackT::DeferredUpdateMessage> {\n        using Type = InteractionCallback::EmptyData;\n    };\n    template<> struct InteractionCallbackTypeHelper<IntCallBackT::UpdateMessage> {\n        using Type = InteractionCallback::EditMessage;\n    };\n    template<> struct InteractionCallbackTypeHelper<IntCallBackT::AppCommandAutocomplete> {\n        using Type = InteractionCallback::Autocomplete;\n    };\n    template<typename Type>\n    struct InteractionCallbackHelper {\n        static constexpr InteractionCallbackType getType() { return InteractionCallbackType::NONE; }\n    };\n    template<> struct InteractionCallbackHelper<InteractionCallback::Autocomplete> {\n        static constexpr InteractionCallbackType getType() { return InteractionCallbackType::ApplicationCommandAutocompleteResult; }\n    };\n    template<> struct InteractionCallbackHelper<InteractionCallback::EditMessage> {\n        static constexpr InteractionCallbackType getType() { return InteractionCallbackType::UpdateMessage; }\n    };\n\n    struct Interaction : IdentifiableDiscordObject<Interaction> {\n        Interaction() = default;\n        Interaction(json::Value & json);\n        Interaction(const nonstd::string_view& json) :\n            Interaction(json::fromJSON<Interaction>(json)) {}\n\n        using CallbackType = InteractionCallbackType;\n\n        template<InteractionCallbackType _type = InteractionCallbackType::ChannelMessageWithSource>\n        struct Response : public DiscordObject {\n            Response() = default;\n            Response(json::Value & json) :\n                Response(json::fromJSON<Response>(json)) {}\n            Response(const nonstd::string_view& json) :\n                Response(json::fromJSON<Response>(json)) {}\n\n            using Type = CallbackType;\n            using DataType = typename InteractionCallbackTypeHelper<_type>::Type;\n            Type type = _type;\n            DataType data;\n\n            JSONStructStart\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper>(&Interaction::Response<_type>::type, "type", json::REQUIRIED_FIELD),\n                    json::pair                      (&Interaction::Response<_type>::data, "data", json::OPTIONAL_FIELD)\n                );\n            JSONStructEnd\n        };\n\n        template<typename Type>\n        using Callback = Response<InteractionCallbackHelper<Type>::getType()>;\n\n        using AutocompleteResponse = Callback<InteractionCallback::Autocomplete>;\n        using MessageResponse = Response<InteractionCallbackType::ChannelMessageWithSource>;\n        using EditMessageResponse = Response<InteractionCallbackType::UpdateMessage>;\n\n        using AppCommandCallbackData = InteractionAppCommandCallbackData;\n        using Type = InteractionType;\n        InteractionType type;\n        Snowflake<DiscordObject> applicationID;\n        InteractionData data;\n        Snowflake<Server> serverID;\n        Snowflake<Channel> channelID;\n        ServerMember member;\n        User user;\n        std::string token;\n        int version = 1;\n        Message message;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&Interaction::ID           , "id"            , json::REQUIRIED_FIELD),\n                json::pair                      (&Interaction::applicationID, "application_id", json::OPTIONAL_FIELD ),\n                json::pair<json::EnumTypeHelper>(&Interaction::type         , "type"          , json::REQUIRIED_FIELD),\n                json::pair                      (&Interaction::data         , "data"          , json::OPTIONAL_FIELD ),\n                json::pair                      (&Interaction::serverID     , "guild_id"      , json::OPTIONAL_FIELD ),\n                json::pair                      (&Interaction::channelID    , "channel_id"    , json::OPTIONAL_FIELD ),\n                json::pair                      (&Interaction::member       , "member"        , json::OPTIONAL_FIELD ),\n                json::pair                      (&Interaction::user         , "user"          , json::OPTIONAL_FIELD ),\n                json::pair                      (&Interaction::token        , "token"         , json::OPTIONAL_FIELD ),\n                json::pair<                   1>(&Interaction::version      , "version"       , json::OPTIONAL_FIELD ),\n                json::pair                      (&Interaction::message      , "message"       , json::OPTIONAL_FIELD )\n            );\n        JSONStructEnd\n    };\n\n    struct FollowupMessage : public BaseWebHookParams<FollowupMessage> {\n        FollowupMessage() = default;\n        FollowupMessage(json::Value& json);\n        FollowupMessage(const nonstd::string_view& json) :\n            FollowupMessage(json::fromJSON<FollowupMessage>(json)) {}\n        InteractionCallback::Message::Flags flags = InteractionCallback::Message::Flags::UNDEFINED;\n\n        JSONStructStart\n            std::tuple_cat(\n                BaseWebHookParams<FollowupMessage>::JSONStruct,\n                std::make_tuple(\n                    json::pair<json::EnumTypeHelper>(&FollowupMessage::flags, "flags", json::OPTIONAL_FIELD)\n                )\n            );\n        JSONStructEnd\n    };\n\n}; // namespace SleepyDiscord\n')),(0,s.kt)("hr",null),(0,s.kt)("p",null,"Updated on 29 January 2022 at 04:47:26 UTC"))}m.isMDXComponent=!0}}]);