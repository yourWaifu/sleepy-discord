"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[5634],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,s=function(e,n){if(null==e)return{};var t,r,s={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(t),m=s,f=p["".concat(c,".").concat(m)]||p[m]||d[m]||o;return t?r.createElement(f,a(a({ref:n},u),{},{components:t})):r.createElement(f,a({ref:n},u))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var o=t.length,a=new Array(o);a[0]=p;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:s,a[1]=i;for(var l=2;l<o;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9965:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var r=t(3117),s=t(102),o=(t(7294),t(3905)),a=["components"],i={title:"include/sleepy_discord/user.h"},c=void 0,l={unversionedId:"reference/Files/user_8h",id:"reference/Files/user_8h",title:"include/sleepy_discord/user.h",description:"Namespaces",source:"@site/docs/reference/Files/user_8h.md",sourceDirName:"reference/Files",slug:"/reference/Files/user_8h",permalink:"/sleepy-discord/docs/reference/Files/user_8h",tags:[],version:"current",frontMatter:{title:"include/sleepy_discord/user.h"},sidebar:"Reference",previous:{title:"sleepy_discord/user.cpp",permalink:"/sleepy-discord/docs/reference/Files/user_8cpp"},next:{title:"include/sleepy_discord/uwebsockets_connection.h",permalink:"/sleepy-discord/docs/reference/Files/uwebsockets__connection_8h"}},u=[{value:"Namespaces",id:"namespaces",children:[],level:2},{value:"Classes",id:"classes",children:[],level:2},{value:"Source code",id:"source-code",children:[],level:2}],d={toc:u};function p(e){var n=e.components,t=(0,s.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"namespaces"},"Namespaces"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Namespaces/namespace_sleepy_discord"},"SleepyDiscord")))))),(0,o.kt)("h2",{id:"classes"},"Classes"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null}),(0,o.kt)("th",{parentName:"tr",align:null},"Name"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_user"},"SleepyDiscord::User")))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"struct"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"td"},(0,o.kt)("a",{parentName:"strong",href:"/sleepy-discord/docs/reference/Classes/struct_sleepy_discord_1_1_connection"},"SleepyDiscord::Connection")))))),(0,o.kt)("h2",{id:"source-code"},"Source code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'#pragma once\n#include <string>\n#include "discord_object_interface.h"\n#include "snowflake.h"\n#include "permissions.h"\n\nnamespace SleepyDiscord {\n    /*\n    User Structure\n\n    Field           Type        Description                                                 Required OAuth2 Scope\n    id              snowflake   the user\'s id                                               identify\n    username        string      the user\'s username, not unique across the platform         identify\n    discriminator   string      the user\'s 4-digit discord-tag                              identify\n    avatar          string      the user\'s avatar hash                                      identify\n    bot             bool        whether the user belongs to an OAuth2 application           identify\n    mfa_enabled     bool        whether the user has two factor enabled on their account    identify\n    verified        bool        whether the email on this account has been verified         email\n    email           string      the user\'s email                                            email\n    */\n    struct User : public IdentifiableDiscordObject<User> {\n    public:\n        User() = default;\n        //~User();\n        //User(const std::string * rawJSON);\n        User(const nonstd::string_view& json) :\n            User(json::fromJSON<User>(json)) {}\n        User(const json::Value& json);\n        //User(const json::Values values);\n\n        enum class Flags {\n            None = 0,\n            Discord_Employee       = 1 << 0,\n            Discord_Partner        = 1 << 1,\n            HypeSquad_Events       = 1 << 2,\n            Bug_Hunter_Level_1     = 1 << 3,\n            House_Bravery          = 1 << 6,\n            House_Brilliance       = 1 << 7,\n            House_Balance          = 1 << 8,\n            Early_Supporter        = 1 << 9,\n            Team_User              = 1 << 10,\n            System                 = 1 << 12,\n            Bug_Hunter_Level_2     = 1 << 14,\n            Verified_Bot           = 1 << 16,\n            Verified_Bot_Developer = 1 << 17,\n            Discord_Certified_Moderator = 1 << 18,\n        };\n\n        enum class PremiumType : int {\n            None = 0,\n            Nitro_Classic = 1,\n            Nitro = 2,\n        };\n\n        std::string username;\n        std::string discriminator;\n        std::string avatar;         //base64 encoded jpeg image\n        //these are optional\n        bool bot = false;\n        bool mfa_enabled = false;   //true if two-factor authentication is enabled\n        bool verified = false;      //true if email has been verified\n        std::string email = "";\n        std::string locale = "";   //the user\'s chosen language\n        Flags flags = Flags::None;\n        PremiumType premiumType = PremiumType::None;\n        Flags publieFlags = Flags::None;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair                      (&User::ID           , "id"           , json::REQUIRIED_FIELD        ),\n                json::pair                      (&User::username     , "username"     , json::OPTIONAL_FIELD         ),\n                json::pair                      (&User::discriminator, "discriminator", json::OPTIONAL_FIELD         ),\n                json::pair                      (&User::avatar       , "avatar"       , json::OPTIONAL_NULLABLE_FIELD),\n                json::pair                      (&User::bot          , "bot"          , json::OPTIONAL_FIELD         ),\n                json::pair                      (&User::mfa_enabled  , "mfa_enabled"  , json::OPTIONAL_FIELD         ),\n                json::pair                      (&User::verified     , "verified"     , json::OPTIONAL_FIELD         ),\n                json::pair                      (&User::locale       , "locale"       , json::OPTIONAL_FIELD         ),\n                json::pair<json::EnumTypeHelper>(&User::flags        , "flags"        , json::OPTIONAL_FIELD         ),\n                json::pair<json::EnumTypeHelper>(&User::premiumType  , "premium_type" , json::OPTIONAL_FIELD         ),\n                json::pair<json::EnumTypeHelper>(&User::publieFlags  , "public_flags" , json::OPTIONAL_FIELD         ),\n                json::pair                      (&User::email        , "email"        , json::OPTIONAL_FIELD         )\n            );\n        JSONStructEnd\n    };\n\n    /*Connection Structure  The connection object that the user has attached.\n\n    Field           Type    Description\n    id              string  id of the connection account\n    name            string  the username of the connection account\n    type            string  the service of the connection (twitch, youtube)\n    revoked         bool    whether the connection is revoked\n    integrations    array   an array of partial server integrations\n    */\n    struct Connection : public IdentifiableDiscordObject<Connection> {\n    public:\n        Connection() = default;\n        Connection(const nonstd::string_view& json) :\n            Connection(json::fromJSON<Connection>(json)) {}\n        Connection(const json::Value& json);\n        std::string name;\n        std::string type;\n        bool revoked;\n\n        JSONStructStart\n            std::make_tuple(\n                json::pair(&Connection::ID     , "id"     , json::REQUIRIED_FIELD),\n                json::pair(&Connection::name   , "name"   , json::REQUIRIED_FIELD),\n                json::pair(&Connection::type   , "type"   , json::REQUIRIED_FIELD),\n                json::pair(&Connection::revoked, "revoked", json::REQUIRIED_FIELD)\n            );\n        JSONStructEnd\n    };\n}\n')),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Updated on  4 March 2022 at 12:37:36 UTC"))}p.isMDXComponent=!0}}]);