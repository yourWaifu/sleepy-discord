"use strict";(self.webpackChunksleepy_discord_docs=self.webpackChunksleepy_discord_docs||[]).push([[7113],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var i=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=i.createContext({}),s=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=s(e.components);return i.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(t),h=o,m=p["".concat(c,".").concat(h)]||p[h]||u[h]||a;return t?i.createElement(m,r(r({ref:n},d),{},{components:t})):i.createElement(m,r({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=p;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var s=2;s<a;s++)r[s]=t[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},2078:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return d},default:function(){return p}});var i=t(3117),o=t(102),a=(t(7294),t(3905)),r=["components"],l={title:"Voice"},c=void 0,s={unversionedId:"voice",id:"voice",title:"Voice",description:"Connect to a Voice Channel",source:"@site/docs/voice.md",sourceDirName:".",slug:"/voice",permalink:"/sleepy-discord/docs/voice",tags:[],version:"current",lastUpdatedAt:1641077799,formattedLastUpdatedAt:"1/1/2022",frontMatter:{title:"Voice"},sidebar:"Docs",previous:{title:"Requests",permalink:"/sleepy-discord/docs/requests"},next:{title:"Unicode and Emojis",permalink:"/sleepy-discord/docs/unicode"}},d=[{value:"Connect to a Voice Channel",id:"connect-to-a-voice-channel",children:[],level:2},{value:"Event Handling",id:"event-handling",children:[],level:2},{value:"Linking the needed libraries",id:"linking-the-needed-libraries",children:[{value:"Sodium",id:"sodium",children:[],level:3},{value:"Opus",id:"opus",children:[],level:3},{value:"A UDP library",id:"a-udp-library",children:[],level:3}],level:2},{value:"Sending Audio",id:"sending-audio",children:[{value:"Audio Sources",id:"audio-sources",children:[{value:"AudioPointerSource",id:"audiopointersource",children:[],level:4},{value:"AudioVectorSource",id:"audiovectorsource",children:[],level:4},{value:"Related Articles",id:"related-articles",children:[],level:4}],level:3},{value:"Speak",id:"speak",children:[],level:3}],level:2},{value:"Receiving Audio",id:"receiving-audio",children:[],level:2},{value:"Disconnecting",id:"disconnecting",children:[],level:2},{value:"Voice State Management",id:"voice-state-management",children:[],level:2}],u={toc:d};function p(e){var n=e.components,t=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"connect-to-a-voice-channel"},"Connect to a Voice Channel"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'myClient.connectToVoiceChannel("channelID", "serverID");\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'myClient.connectToVoiceChannel(myClient.createVoiceContext("channelID", "serverID", nullptr));\n')),(0,a.kt)("p",null,"There are a few ways to connect to a voice channel but the first example, calling ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseDiscordClient::connectToVoiceChannel")," with just a ",(0,a.kt)("inlineCode",{parentName:"p"},"channelID")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"serverID"),", is the simplest."),(0,a.kt)("h2",{id:"event-handling"},"Event Handling"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'class VoiceEventHandler : public SleepyDiscord::BaseVoiceEventHandler {\npublic:\n    VoiceEventHandler() {}\n    void onReady(SleepyDiscord::VoiceConnection& connection) {\n        /*Do stuff when ready to start sending audio*/\n    }\n}\nVoiceEventHandler voiceEventHandler;\n\n//somewhere else in your code\nSleepyDiscord::VoiceContext& context = myClient.createContext("channelID", "serverID", voiceEventHandler);\n//or\ncontext.setVoiceHandler(voiceEventHandler);\n')),(0,a.kt)("p",null,"Event handling is done in a separated inherited object, a VoiceEventHandler, creating one is done by simply creating a class that inherits traits from ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseVoiceEventHandler"),"."),(0,a.kt)("p",null,"During runtime, a reference of or pointer to your VoiceEventHandler will need to be given to a ",(0,a.kt)("inlineCode",{parentName:"p"},"VoiceContext"),". This object should live longer then the VoiceContexts that hold the pointer to your VoiceEventHandler (VoiceContexts are destroyed after closing the connection). Not doing so will cause the client to crash."),(0,a.kt)("p",null,"One useful event being the ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseVoiceEventHandler::onReady")," event. This is called when the client has finished connecting and is ready to start sending data to one of Discord's voice servers. Some of you maybe confused as to why this is done via a callback and asking \"Shouldn't the client be ready after calling ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseDiscordClient::connectToVoiceChannel"),"?\". This is because, there's a number of steps involved with getting ready that happen outside the function call."),(0,a.kt)("h2",{id:"linking-the-needed-libraries"},"Linking the needed libraries"),(0,a.kt)("p",null,"You'll need those if you want to send or receive audio."),(0,a.kt)("h3",{id:"sodium"},"Sodium"),(0,a.kt)("p",null,"Instructions on ",(0,a.kt)("a",{parentName:"p",href:"https://download.libsodium.org/doc/installation/"},"libsodium's website")),(0,a.kt)("h3",{id:"opus"},"Opus"),(0,a.kt)("p",null,"Download the source from ",(0,a.kt)("a",{parentName:"p",href:"https://opus-codec.org/downloads/"},"opus's website"),". It will contain instructions for compiling with make. You can also compile using Visual Studio from the files inside win32."),(0,a.kt)("h3",{id:"a-udp-library"},"A UDP library"),(0,a.kt)("p",null,"Two options, using a custom one or you may instead use ASIO, which you should already have if you are using Websockets++ or uWebSockets."),(0,a.kt)("h2",{id:"sending-audio"},"Sending Audio"),(0,a.kt)("p",null,"Once connected to a voice server with all needed library linked, we can begin sending Audio to over to Discord. To do this, create a ",(0,a.kt)("inlineCode",{parentName:"p"},"AudioSource"),", and then call ",(0,a.kt)("inlineCode",{parentName:"p"},"VoiceConnection::startSpeaking"),"."),(0,a.kt)("h3",{id:"audio-sources"},"Audio Sources"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'struct Music : public SleepyDiscord::AudioPointerSource {\n    Music() : SleepyDiscord::AudioPointerSource() {\n        File musicFile("music.raw");\n        musicLength = musicFile.getSize() / sizeof int16_t;\n        music = musicFile.get<int16_t>();\n    }\n    constexpr inline bool isOpusEncoded() { return false; } //optional, will be false by default\n    void read(SleepyDiscord::AudioTransmissionDetails& details, int16_t*& buffer, std::size_t& length) {\n        buffer = &music[progress];\n        length = details.proposedLength() < (musicLength - progress) ? details.proposedLength() : 0;\n        progress += details.proposedLength();\n        //note: set length to 0 to stop speaking\n    }\n    std::size_t progress = 0;\n    std::vector<int16_t> music;\n    std::size_t musicLength;\n};\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct SquareWave : public SleepyDiscord::AudioVectorSource {\n    SquareWave() : SleepyDiscord::AudioVectorSource(), sampleOffset(0) {}\n    std::vector<int16_t> read(SleepyDiscord::AudioTransmissionDetails& details) {\n        std::vector<int16_t> target(details.proposedLength());\n        for (int16_t& sample : target) {\n                //2000 is the volume\n                //100 is how long half the square wave is\n                sample = (++sampleOffset / 100) % 2 ? 2000 : -2000;\n        }\n        return target;\n        //note: return vector with a size of 0 to stop speaking\n    }\n    std::size_t sampleOffset = 0;\n};\n")),(0,a.kt)("p",null,"Creating an AudioSource is done by creating a class that inherits a type of AudioSource and filling in the virtual function, ",(0,a.kt)("inlineCode",{parentName:"p"},"read"),"."),(0,a.kt)("p",null,"This read function should, by default, output PCM stereo audio samples at 48000 Hz with the 2 channels interleaved.\nIf you aren't familiar with digital audio samples, ",(0,a.kt)("a",{parentName:"p",href:"http://manual.audacityteam.org/man/digital_audio.html"},"here's a good article about it"),".\nIn the ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," function, you'll be given a ",(0,a.kt)("inlineCode",{parentName:"p"},"SleepyDiscord::AudioTransmissionDetails"),", this will give details about what audio settings to use and some other stuff like how much audio has been sent since last time.\nDon't worry about calling read, the library will instead call ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," when audio data is needed while sending audio."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"You can also send Opus encoded audio instead of PMC audio")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Music : public SleepyDiscord::AudioPointerSource {\n    constexpr inline bool isOpusEncoded() { return true; }\n}\n")),(0,a.kt)("p",null,"As of when this was written, there are two types of ",(0,a.kt)("inlineCode",{parentName:"p"},"AudioSources"),", pointer and vector. They differ in their read function."),(0,a.kt)("h4",{id:"audiopointersource"},"AudioPointerSource"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"read")," points a pointer to a buffer of audio data and sets the length."),(0,a.kt)("h4",{id:"audiovectorsource"},"AudioVectorSource"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"read")," returns a vector of audio data"),(0,a.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"The sizes of audio buffers should 960. Which is .02 seconds of 48kHz stereo audio."))),(0,a.kt)("h4",{id:"related-articles"},"Related Articles"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"http://manual.audacityteam.org/man/digital_audio.html"},"Digital Audio Fundamentals")),(0,a.kt)("h3",{id:"speak"},"Speak"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"//In your VoiceEventHandler\nvoid onReady(SleepyDiscord::VoiceConnection& connection) {\n    connection.startSpeaking<SquareWave>(/*Parameters to pass over to SquareWave's constructor*/);\n}\n")),(0,a.kt)("p",null,"To start speaking, call ",(0,a.kt)("inlineCode",{parentName:"p"},"VoiceConnection::startSpeaking")," with your AudioSource as the template parameter. To stop, send a buffer with the length of zero in your AudioSource's read function. If your AudioSource has any parameters in it's constructor, you pass them to this function. You may also use ",(0,a.kt)("inlineCode",{parentName:"p"},"VoiceConnection::stopSpeaking")," to stop speaking."),(0,a.kt)("h2",{id:"receiving-audio"},"Receiving Audio"),(0,a.kt)("p",null,"Not implemented yet."),(0,a.kt)("h2",{id:"disconnecting"},"Disconnecting"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void onEndSpeaking(SleepyDiscord::VoiceConnection& connection) {\n    connection.disconnect();\n}\n")),(0,a.kt)("p",null,"There are a few ways to disconnect, the simplest being calling ",(0,a.kt)("inlineCode",{parentName:"p"},"VoiceConnection::disconnect"),". You can also disconnect with a VoiceContext or channelID by using ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseDiscordClient::disconnectVoiceContext")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseDiscordClient:disconnectFromVoiceChannel"),"."),(0,a.kt)("h2",{id:"voice-state-management"},"Voice State Management"),(0,a.kt)("p",null,"Using voice states, you can info about the state of users in voice chat. This data includes the joining and leaving of voice channels, deaf, mute, etc. You can keep track of voice states via the ",(0,a.kt)("inlineCode",{parentName:"p"},"onEditVoiceState")," event on your Discord Client and ",(0,a.kt)("inlineCode",{parentName:"p"},"server.voiceStates")," during the ",(0,a.kt)("inlineCode",{parentName:"p"},"onServer")," event."))}p.isMDXComponent=!0}}]);